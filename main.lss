
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002c  00800100  00004302  00004396  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004302  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006c1  0080012c  0080012c  000043c2  2**0
                  ALLOC
  3 .debug_aranges 000000e0  00000000  00000000  000043c2  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000b50  00000000  00000000  000044a2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003e85  00000000  00000000  00004ff2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000b93  00000000  00000000  00008e77  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003377  00000000  00000000  00009a0a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007c0  00000000  00000000  0000cd84  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000182e  00000000  00000000  0000d544  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002526  00000000  00000000  0000ed72  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000e0  00000000  00000000  00011298  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 c5 1e 	jmp	0x3d8a	; 0x3d8a <__vector_13>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 a8 01 	jmp	0x350	; 0x350 <__vector_18>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 f5 01 	jmp	0x3ea	; 0x3ea <__vector_24>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d8 e0       	ldi	r29, 0x08	; 8
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	e2 e0       	ldi	r30, 0x02	; 2
      90:	f3 e4       	ldi	r31, 0x43	; 67
      92:	02 c0       	rjmp	.+4      	; 0x98 <.do_copy_data_start>

00000094 <.do_copy_data_loop>:
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0

00000098 <.do_copy_data_start>:
      98:	ac 32       	cpi	r26, 0x2C	; 44
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <.do_copy_data_loop>

0000009e <__do_clear_bss>:
      9e:	17 e0       	ldi	r17, 0x07	; 7
      a0:	ac e2       	ldi	r26, 0x2C	; 44
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	ad 3e       	cpi	r26, 0xED	; 237
      aa:	b1 07       	cpc	r27, r17
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 86 08 	call	0x110c	; 0x110c <main>
      b2:	0c 94 7f 21 	jmp	0x42fe	; 0x42fe <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <setSegments>:
#define delay 2

uint8_t Segments[4][4] = {{0,0,0,0},{0,0,0,0}};

void setSegments (uint8_t s00, uint8_t s01, uint8_t s02, uint8_t s03, uint8_t s10, uint8_t s11, uint8_t s12, uint8_t s13) 
{    
      ba:	af 92       	push	r10
      bc:	cf 92       	push	r12
      be:	ef 92       	push	r14
      c0:	0f 93       	push	r16
	Segments[0][0] = s00; Segments[0][1] = s01; Segments[0][2] = s02; Segments[0][3] = s03;
      c2:	80 93 2c 01 	sts	0x012C, r24
      c6:	60 93 2d 01 	sts	0x012D, r22
      ca:	40 93 2e 01 	sts	0x012E, r20
      ce:	20 93 2f 01 	sts	0x012F, r18
    Segments[1][0] = s10; Segments[1][1] = s11; Segments[1][2] = s12; Segments[1][3] = s13;
      d2:	00 93 30 01 	sts	0x0130, r16
      d6:	e0 92 31 01 	sts	0x0131, r14
      da:	c0 92 32 01 	sts	0x0132, r12
      de:	a0 92 33 01 	sts	0x0133, r10
	
}
      e2:	0f 91       	pop	r16
      e4:	ef 90       	pop	r14
      e6:	cf 90       	pop	r12
      e8:	af 90       	pop	r10
      ea:	08 95       	ret

000000ec <SEGs0>:

uint8_t Segments[4][4] = {{0,0,0,0},{0,0,0,0}};

void setSegments (uint8_t s00, uint8_t s01, uint8_t s02, uint8_t s03, uint8_t s10, uint8_t s11, uint8_t s12, uint8_t s13) 
{    
	Segments[0][0] = s00; Segments[0][1] = s01; Segments[0][2] = s02; Segments[0][3] = s03;
      ec:	81 e0       	ldi	r24, 0x01	; 1
      ee:	80 93 2c 01 	sts	0x012C, r24
      f2:	10 92 2d 01 	sts	0x012D, r1
      f6:	80 93 2e 01 	sts	0x012E, r24
      fa:	80 93 2f 01 	sts	0x012F, r24
    Segments[1][0] = s10; Segments[1][1] = s11; Segments[1][2] = s12; Segments[1][3] = s13;
      fe:	80 93 30 01 	sts	0x0130, r24
     102:	80 93 31 01 	sts	0x0131, r24
     106:	80 93 32 01 	sts	0x0132, r24
     10a:	10 92 33 01 	sts	0x0133, r1
	
}

void SEGs0() { setSegments(1,0,1,1, 1,1,1,0); } //A "0" szegmensei COM0..3 fuggvenyeben
     10e:	08 95       	ret

00000110 <SEGs1>:

uint8_t Segments[4][4] = {{0,0,0,0},{0,0,0,0}};

void setSegments (uint8_t s00, uint8_t s01, uint8_t s02, uint8_t s03, uint8_t s10, uint8_t s11, uint8_t s12, uint8_t s13) 
{    
	Segments[0][0] = s00; Segments[0][1] = s01; Segments[0][2] = s02; Segments[0][3] = s03;
     110:	10 92 2c 01 	sts	0x012C, r1
     114:	10 92 2d 01 	sts	0x012D, r1
     118:	10 92 2e 01 	sts	0x012E, r1
     11c:	10 92 2f 01 	sts	0x012F, r1
    Segments[1][0] = s10; Segments[1][1] = s11; Segments[1][2] = s12; Segments[1][3] = s13;
     120:	10 92 30 01 	sts	0x0130, r1
     124:	81 e0       	ldi	r24, 0x01	; 1
     126:	80 93 31 01 	sts	0x0131, r24
     12a:	80 93 32 01 	sts	0x0132, r24
     12e:	10 92 33 01 	sts	0x0133, r1
	
}

void SEGs0() { setSegments(1,0,1,1, 1,1,1,0); } //A "0" szegmensei COM0..3 fuggvenyeben
void SEGs1() { setSegments(0,0,0,0, 0,1,1,0); }
     132:	08 95       	ret

00000134 <SEGs2>:

uint8_t Segments[4][4] = {{0,0,0,0},{0,0,0,0}};

void setSegments (uint8_t s00, uint8_t s01, uint8_t s02, uint8_t s03, uint8_t s10, uint8_t s11, uint8_t s12, uint8_t s13) 
{    
	Segments[0][0] = s00; Segments[0][1] = s01; Segments[0][2] = s02; Segments[0][3] = s03;
     134:	10 92 2c 01 	sts	0x012C, r1
     138:	81 e0       	ldi	r24, 0x01	; 1
     13a:	80 93 2d 01 	sts	0x012D, r24
     13e:	80 93 2e 01 	sts	0x012E, r24
     142:	80 93 2f 01 	sts	0x012F, r24
    Segments[1][0] = s10; Segments[1][1] = s11; Segments[1][2] = s12; Segments[1][3] = s13;
     146:	80 93 30 01 	sts	0x0130, r24
     14a:	80 93 31 01 	sts	0x0131, r24
     14e:	10 92 32 01 	sts	0x0132, r1
     152:	10 92 33 01 	sts	0x0133, r1
	
}

void SEGs0() { setSegments(1,0,1,1, 1,1,1,0); } //A "0" szegmensei COM0..3 fuggvenyeben
void SEGs1() { setSegments(0,0,0,0, 0,1,1,0); }
void SEGs2() { setSegments(0,1,1,1, 1,1,0,0); }
     156:	08 95       	ret

00000158 <SEGs3>:

uint8_t Segments[4][4] = {{0,0,0,0},{0,0,0,0}};

void setSegments (uint8_t s00, uint8_t s01, uint8_t s02, uint8_t s03, uint8_t s10, uint8_t s11, uint8_t s12, uint8_t s13) 
{    
	Segments[0][0] = s00; Segments[0][1] = s01; Segments[0][2] = s02; Segments[0][3] = s03;
     158:	10 92 2c 01 	sts	0x012C, r1
     15c:	81 e0       	ldi	r24, 0x01	; 1
     15e:	80 93 2d 01 	sts	0x012D, r24
     162:	10 92 2e 01 	sts	0x012E, r1
     166:	80 93 2f 01 	sts	0x012F, r24
    Segments[1][0] = s10; Segments[1][1] = s11; Segments[1][2] = s12; Segments[1][3] = s13;
     16a:	80 93 30 01 	sts	0x0130, r24
     16e:	80 93 31 01 	sts	0x0131, r24
     172:	80 93 32 01 	sts	0x0132, r24
     176:	10 92 33 01 	sts	0x0133, r1
}

void SEGs0() { setSegments(1,0,1,1, 1,1,1,0); } //A "0" szegmensei COM0..3 fuggvenyeben
void SEGs1() { setSegments(0,0,0,0, 0,1,1,0); }
void SEGs2() { setSegments(0,1,1,1, 1,1,0,0); }
void SEGs3() { setSegments(0,1,0,1, 1,1,1,0); }
     17a:	08 95       	ret

0000017c <SEGs4>:

uint8_t Segments[4][4] = {{0,0,0,0},{0,0,0,0}};

void setSegments (uint8_t s00, uint8_t s01, uint8_t s02, uint8_t s03, uint8_t s10, uint8_t s11, uint8_t s12, uint8_t s13) 
{    
	Segments[0][0] = s00; Segments[0][1] = s01; Segments[0][2] = s02; Segments[0][3] = s03;
     17c:	81 e0       	ldi	r24, 0x01	; 1
     17e:	80 93 2c 01 	sts	0x012C, r24
     182:	80 93 2d 01 	sts	0x012D, r24
     186:	10 92 2e 01 	sts	0x012E, r1
     18a:	10 92 2f 01 	sts	0x012F, r1
    Segments[1][0] = s10; Segments[1][1] = s11; Segments[1][2] = s12; Segments[1][3] = s13;
     18e:	10 92 30 01 	sts	0x0130, r1
     192:	80 93 31 01 	sts	0x0131, r24
     196:	80 93 32 01 	sts	0x0132, r24
     19a:	10 92 33 01 	sts	0x0133, r1

void SEGs0() { setSegments(1,0,1,1, 1,1,1,0); } //A "0" szegmensei COM0..3 fuggvenyeben
void SEGs1() { setSegments(0,0,0,0, 0,1,1,0); }
void SEGs2() { setSegments(0,1,1,1, 1,1,0,0); }
void SEGs3() { setSegments(0,1,0,1, 1,1,1,0); }
void SEGs4() { setSegments(1,1,0,0, 0,1,1,0); }
     19e:	08 95       	ret

000001a0 <SEGs5>:

uint8_t Segments[4][4] = {{0,0,0,0},{0,0,0,0}};

void setSegments (uint8_t s00, uint8_t s01, uint8_t s02, uint8_t s03, uint8_t s10, uint8_t s11, uint8_t s12, uint8_t s13) 
{    
	Segments[0][0] = s00; Segments[0][1] = s01; Segments[0][2] = s02; Segments[0][3] = s03;
     1a0:	81 e0       	ldi	r24, 0x01	; 1
     1a2:	80 93 2c 01 	sts	0x012C, r24
     1a6:	80 93 2d 01 	sts	0x012D, r24
     1aa:	10 92 2e 01 	sts	0x012E, r1
     1ae:	80 93 2f 01 	sts	0x012F, r24
    Segments[1][0] = s10; Segments[1][1] = s11; Segments[1][2] = s12; Segments[1][3] = s13;
     1b2:	80 93 30 01 	sts	0x0130, r24
     1b6:	10 92 31 01 	sts	0x0131, r1
     1ba:	80 93 32 01 	sts	0x0132, r24
     1be:	10 92 33 01 	sts	0x0133, r1
void SEGs0() { setSegments(1,0,1,1, 1,1,1,0); } //A "0" szegmensei COM0..3 fuggvenyeben
void SEGs1() { setSegments(0,0,0,0, 0,1,1,0); }
void SEGs2() { setSegments(0,1,1,1, 1,1,0,0); }
void SEGs3() { setSegments(0,1,0,1, 1,1,1,0); }
void SEGs4() { setSegments(1,1,0,0, 0,1,1,0); }
void SEGs5() { setSegments(1,1,0,1, 1,0,1,0); }
     1c2:	08 95       	ret

000001c4 <SEGs6>:

uint8_t Segments[4][4] = {{0,0,0,0},{0,0,0,0}};

void setSegments (uint8_t s00, uint8_t s01, uint8_t s02, uint8_t s03, uint8_t s10, uint8_t s11, uint8_t s12, uint8_t s13) 
{    
	Segments[0][0] = s00; Segments[0][1] = s01; Segments[0][2] = s02; Segments[0][3] = s03;
     1c4:	81 e0       	ldi	r24, 0x01	; 1
     1c6:	80 93 2c 01 	sts	0x012C, r24
     1ca:	80 93 2d 01 	sts	0x012D, r24
     1ce:	80 93 2e 01 	sts	0x012E, r24
     1d2:	80 93 2f 01 	sts	0x012F, r24
    Segments[1][0] = s10; Segments[1][1] = s11; Segments[1][2] = s12; Segments[1][3] = s13;
     1d6:	80 93 30 01 	sts	0x0130, r24
     1da:	10 92 31 01 	sts	0x0131, r1
     1de:	80 93 32 01 	sts	0x0132, r24
     1e2:	10 92 33 01 	sts	0x0133, r1
void SEGs1() { setSegments(0,0,0,0, 0,1,1,0); }
void SEGs2() { setSegments(0,1,1,1, 1,1,0,0); }
void SEGs3() { setSegments(0,1,0,1, 1,1,1,0); }
void SEGs4() { setSegments(1,1,0,0, 0,1,1,0); }
void SEGs5() { setSegments(1,1,0,1, 1,0,1,0); }
void SEGs6() { setSegments(1,1,1,1, 1,0,1,0); }
     1e6:	08 95       	ret

000001e8 <SEGs7>:

uint8_t Segments[4][4] = {{0,0,0,0},{0,0,0,0}};

void setSegments (uint8_t s00, uint8_t s01, uint8_t s02, uint8_t s03, uint8_t s10, uint8_t s11, uint8_t s12, uint8_t s13) 
{    
	Segments[0][0] = s00; Segments[0][1] = s01; Segments[0][2] = s02; Segments[0][3] = s03;
     1e8:	10 92 2c 01 	sts	0x012C, r1
     1ec:	10 92 2d 01 	sts	0x012D, r1
     1f0:	10 92 2e 01 	sts	0x012E, r1
     1f4:	10 92 2f 01 	sts	0x012F, r1
    Segments[1][0] = s10; Segments[1][1] = s11; Segments[1][2] = s12; Segments[1][3] = s13;
     1f8:	81 e0       	ldi	r24, 0x01	; 1
     1fa:	80 93 30 01 	sts	0x0130, r24
     1fe:	80 93 31 01 	sts	0x0131, r24
     202:	80 93 32 01 	sts	0x0132, r24
     206:	10 92 33 01 	sts	0x0133, r1
void SEGs2() { setSegments(0,1,1,1, 1,1,0,0); }
void SEGs3() { setSegments(0,1,0,1, 1,1,1,0); }
void SEGs4() { setSegments(1,1,0,0, 0,1,1,0); }
void SEGs5() { setSegments(1,1,0,1, 1,0,1,0); }
void SEGs6() { setSegments(1,1,1,1, 1,0,1,0); }
void SEGs7() { setSegments(0,0,0,0, 1,1,1,0); }
     20a:	08 95       	ret

0000020c <SEGs8>:

uint8_t Segments[4][4] = {{0,0,0,0},{0,0,0,0}};

void setSegments (uint8_t s00, uint8_t s01, uint8_t s02, uint8_t s03, uint8_t s10, uint8_t s11, uint8_t s12, uint8_t s13) 
{    
	Segments[0][0] = s00; Segments[0][1] = s01; Segments[0][2] = s02; Segments[0][3] = s03;
     20c:	81 e0       	ldi	r24, 0x01	; 1
     20e:	80 93 2c 01 	sts	0x012C, r24
     212:	80 93 2d 01 	sts	0x012D, r24
     216:	80 93 2e 01 	sts	0x012E, r24
     21a:	80 93 2f 01 	sts	0x012F, r24
    Segments[1][0] = s10; Segments[1][1] = s11; Segments[1][2] = s12; Segments[1][3] = s13;
     21e:	80 93 30 01 	sts	0x0130, r24
     222:	80 93 31 01 	sts	0x0131, r24
     226:	80 93 32 01 	sts	0x0132, r24
     22a:	10 92 33 01 	sts	0x0133, r1
void SEGs3() { setSegments(0,1,0,1, 1,1,1,0); }
void SEGs4() { setSegments(1,1,0,0, 0,1,1,0); }
void SEGs5() { setSegments(1,1,0,1, 1,0,1,0); }
void SEGs6() { setSegments(1,1,1,1, 1,0,1,0); }
void SEGs7() { setSegments(0,0,0,0, 1,1,1,0); }
void SEGs8() { setSegments(1,1,1,1, 1,1,1,0); }
     22e:	08 95       	ret

00000230 <SEGs9>:

uint8_t Segments[4][4] = {{0,0,0,0},{0,0,0,0}};

void setSegments (uint8_t s00, uint8_t s01, uint8_t s02, uint8_t s03, uint8_t s10, uint8_t s11, uint8_t s12, uint8_t s13) 
{    
	Segments[0][0] = s00; Segments[0][1] = s01; Segments[0][2] = s02; Segments[0][3] = s03;
     230:	81 e0       	ldi	r24, 0x01	; 1
     232:	80 93 2c 01 	sts	0x012C, r24
     236:	80 93 2d 01 	sts	0x012D, r24
     23a:	10 92 2e 01 	sts	0x012E, r1
     23e:	80 93 2f 01 	sts	0x012F, r24
    Segments[1][0] = s10; Segments[1][1] = s11; Segments[1][2] = s12; Segments[1][3] = s13;
     242:	80 93 30 01 	sts	0x0130, r24
     246:	80 93 31 01 	sts	0x0131, r24
     24a:	80 93 32 01 	sts	0x0132, r24
     24e:	10 92 33 01 	sts	0x0133, r1
void SEGs4() { setSegments(1,1,0,0, 0,1,1,0); }
void SEGs5() { setSegments(1,1,0,1, 1,0,1,0); }
void SEGs6() { setSegments(1,1,1,1, 1,0,1,0); }
void SEGs7() { setSegments(0,0,0,0, 1,1,1,0); }
void SEGs8() { setSegments(1,1,1,1, 1,1,1,0); }
void SEGs9() { setSegments(1,1,0,1, 1,1,1,0); }
     252:	08 95       	ret

00000254 <OVERLOAD>:

uint8_t Segments[4][4] = {{0,0,0,0},{0,0,0,0}};

void setSegments (uint8_t s00, uint8_t s01, uint8_t s02, uint8_t s03, uint8_t s10, uint8_t s11, uint8_t s12, uint8_t s13) 
{    
	Segments[0][0] = s00; Segments[0][1] = s01; Segments[0][2] = s02; Segments[0][3] = s03;
     254:	10 92 2c 01 	sts	0x012C, r1
     258:	10 92 2d 01 	sts	0x012D, r1
     25c:	10 92 2e 01 	sts	0x012E, r1
     260:	10 92 2f 01 	sts	0x012F, r1
    Segments[1][0] = s10; Segments[1][1] = s11; Segments[1][2] = s12; Segments[1][3] = s13;
     264:	10 92 30 01 	sts	0x0130, r1
     268:	10 92 31 01 	sts	0x0131, r1
     26c:	10 92 32 01 	sts	0x0132, r1
     270:	81 e0       	ldi	r24, 0x01	; 1
     272:	80 93 33 01 	sts	0x0133, r24
void SEGs5() { setSegments(1,1,0,1, 1,0,1,0); }
void SEGs6() { setSegments(1,1,1,1, 1,0,1,0); }
void SEGs7() { setSegments(0,0,0,0, 1,1,1,0); }
void SEGs8() { setSegments(1,1,1,1, 1,1,1,0); }
void SEGs9() { setSegments(1,1,0,1, 1,1,1,0); }
void OVERLOAD() { setSegments(0,0,0,0, 0,0,0,1); }
     276:	08 95       	ret

00000278 <decimal>:

uint8_t Segments[4][4] = {{0,0,0,0},{0,0,0,0}};

void setSegments (uint8_t s00, uint8_t s01, uint8_t s02, uint8_t s03, uint8_t s10, uint8_t s11, uint8_t s12, uint8_t s13) 
{    
	Segments[0][0] = s00; Segments[0][1] = s01; Segments[0][2] = s02; Segments[0][3] = s03;
     278:	10 92 2c 01 	sts	0x012C, r1
     27c:	10 92 2d 01 	sts	0x012D, r1
     280:	10 92 2e 01 	sts	0x012E, r1
     284:	10 92 2f 01 	sts	0x012F, r1
    Segments[1][0] = s10; Segments[1][1] = s11; Segments[1][2] = s12; Segments[1][3] = s13;
     288:	10 92 30 01 	sts	0x0130, r1
     28c:	10 92 31 01 	sts	0x0131, r1
     290:	10 92 32 01 	sts	0x0132, r1
     294:	81 e0       	ldi	r24, 0x01	; 1
     296:	80 93 33 01 	sts	0x0133, r24
void SEGs6() { setSegments(1,1,1,1, 1,0,1,0); }
void SEGs7() { setSegments(0,0,0,0, 1,1,1,0); }
void SEGs8() { setSegments(1,1,1,1, 1,1,1,0); }
void SEGs9() { setSegments(1,1,0,1, 1,1,1,0); }
void OVERLOAD() { setSegments(0,0,0,0, 0,0,0,1); }
void decimal() { setSegments(0,0,0,0, 0,0,0,1); }
     29a:	08 95       	ret

0000029c <UP_pressed>:

void LCD_print(uint8_t m1, uint8_t m2, uint8_t m3, uint8_t m4, uint8_t c1, uint8_t c2, uint8_t c3, uint8_t c4, uint8_t overload); //m - measured, c - configured

uint8_t UP_pressed()
{
	if (!(PINA & (1<<UP))) //ha le van nyomva
     29c:	80 b1       	in	r24, 0x00	; 0
     29e:	86 95       	lsr	r24
     2a0:	86 95       	lsr	r24
     2a2:	80 95       	com	r24
	{
		return 1; 
	}
	return 0; 
}
     2a4:	81 70       	andi	r24, 0x01	; 1
     2a6:	08 95       	ret

000002a8 <DOWN_pressed>:

uint8_t DOWN_pressed()
{
	if (!(PINA & (1<<DOWN))) //ha le van nyomva
     2a8:	80 b1       	in	r24, 0x00	; 0
     2aa:	86 95       	lsr	r24
     2ac:	80 95       	com	r24
	{
		return 1;
	}
	return 0;
}
     2ae:	81 70       	andi	r24, 0x01	; 1
     2b0:	08 95       	ret

000002b2 <RESET_pressed>:

uint8_t RESET_pressed()
{
	if (!(PINA & (1<<RESET))) //ha le van nyomva
     2b2:	80 b1       	in	r24, 0x00	; 0
     2b4:	86 95       	lsr	r24
     2b6:	86 95       	lsr	r24
     2b8:	86 95       	lsr	r24
     2ba:	80 95       	com	r24
	{
		return 1;
	}
	return 0;
}
     2bc:	81 70       	andi	r24, 0x01	; 1
     2be:	08 95       	ret

000002c0 <start_timer0>:

void start_timer0()
{
	TCCR0B |= (1<< CS02); //CLK/256, start
     2c0:	85 b5       	in	r24, 0x25	; 37
     2c2:	84 60       	ori	r24, 0x04	; 4
     2c4:	85 bd       	out	0x25, r24	; 37
	TIMSK0= (1<<TOIE0);  //enable overflow interrupt
     2c6:	81 e0       	ldi	r24, 0x01	; 1
     2c8:	80 93 6e 00 	sts	0x006E, r24
	sei(); //set the I-bit in SREG
     2cc:	78 94       	sei
}
     2ce:	08 95       	ret

000002d0 <stop_timer0>:

void stop_timer0()
{
	TCCR0B &= ~(1<< CS02); //nincs orajel => az idozito megall
     2d0:	85 b5       	in	r24, 0x25	; 37
     2d2:	8b 7f       	andi	r24, 0xFB	; 251
     2d4:	85 bd       	out	0x25, r24	; 37
}
     2d6:	08 95       	ret

000002d8 <initPORTs>:

void initPORTs()
{
	DDRA |= (1<<PA4) | (1<<PA5) | (1<<PA6) | (1<<PA7); //kimenet szegmenscsoportoknak
     2d8:	81 b1       	in	r24, 0x01	; 1
     2da:	80 6f       	ori	r24, 0xF0	; 240
     2dc:	81 b9       	out	0x01, r24	; 1
	DDRA &= ~((1<<UP) | (1<<DOWN) | (1<<RESET));//bemenet a gomboknak
     2de:	81 b1       	in	r24, 0x01	; 1
     2e0:	81 7f       	andi	r24, 0xF1	; 241
     2e2:	81 b9       	out	0x01, r24	; 1
	PORTA |= (1<<UP)|(1<<DOWN)|(1<<RESET); //felhuzo ellenallasok a gomboknak
     2e4:	82 b1       	in	r24, 0x02	; 2
     2e6:	8e 60       	ori	r24, 0x0E	; 14
     2e8:	82 b9       	out	0x02, r24	; 2
	DDRB |= (1<<PB0); //kimenet a relenek
     2ea:	20 9a       	sbi	0x04, 0	; 4
	DDRC = 0xff; //kimenet szegmenscsoportoknak
     2ec:	8f ef       	ldi	r24, 0xFF	; 255
     2ee:	87 b9       	out	0x07, r24	; 7
	DDRD |= (1<<PD4) | (1<<PD5) | (1<<PD6) | (1<<PD7);  //kimenet szegmens-csoportoknak 
     2f0:	8a b1       	in	r24, 0x0a	; 10
     2f2:	80 6f       	ori	r24, 0xF0	; 240
     2f4:	8a b9       	out	0x0a, r24	; 10
}
     2f6:	08 95       	ret

000002f8 <initADC>:

void initADC()
{
	ADCSRA |= (1 << ADPS2) | (1 << ADPS0); //16MHz/32=500kHz)
     2f8:	ea e7       	ldi	r30, 0x7A	; 122
     2fa:	f0 e0       	ldi	r31, 0x00	; 0
     2fc:	80 81       	ld	r24, Z
     2fe:	85 60       	ori	r24, 0x05	; 5
     300:	80 83       	st	Z, r24
	ADMUX |= (1 << REFS0); //ADC referencia = AVCC
     302:	ac e7       	ldi	r26, 0x7C	; 124
     304:	b0 e0       	ldi	r27, 0x00	; 0
     306:	8c 91       	ld	r24, X
     308:	80 64       	ori	r24, 0x40	; 64
     30a:	8c 93       	st	X, r24
	//Mux4..0=0 - ADC0 csatorna
	ADCSRA |= (1<<ADIE); //Enable ADC interrupt
     30c:	80 81       	ld	r24, Z
     30e:	88 60       	ori	r24, 0x08	; 8
     310:	80 83       	st	Z, r24
	ADCSRA |= (1<<ADATE); //Enable auto-triggering
     312:	80 81       	ld	r24, Z
     314:	80 62       	ori	r24, 0x20	; 32
     316:	80 83       	st	Z, r24
	ADCSRA |= (1<<ADEN); //Enable ADC
     318:	80 81       	ld	r24, Z
     31a:	80 68       	ori	r24, 0x80	; 128
     31c:	80 83       	st	Z, r24
	sei();
     31e:	78 94       	sei
	ADCSRA |= (1<<ADSC); //start first ADC conversion
     320:	ea e7       	ldi	r30, 0x7A	; 122
     322:	f0 e0       	ldi	r31, 0x00	; 0
     324:	80 81       	ld	r24, Z
     326:	80 64       	ori	r24, 0x40	; 64
     328:	80 83       	st	Z, r24
	converted = 1;
     32a:	81 e0       	ldi	r24, 0x01	; 1
     32c:	80 93 da 07 	sts	0x07DA, r24
}
     330:	08 95       	ret

00000332 <adc_read>:

void adc_read()
{
	ADCSRA |= (1<<ADSC); //start ADC
     332:	ea e7       	ldi	r30, 0x7A	; 122
     334:	f0 e0       	ldi	r31, 0x00	; 0
     336:	80 81       	ld	r24, Z
     338:	80 64       	ori	r24, 0x40	; 64
     33a:	80 83       	st	Z, r24
	ADCSRA |= (1<<ADIE); //Enable ADC interrupt
     33c:	80 81       	ld	r24, Z
     33e:	88 60       	ori	r24, 0x08	; 8
     340:	80 83       	st	Z, r24
}
     342:	08 95       	ret

00000344 <sleep>:

void sleep()
{
	ADMUX |= (1 << REFS1); //internal 2.56V
     344:	ec e7       	ldi	r30, 0x7C	; 124
     346:	f0 e0       	ldi	r31, 0x00	; 0
     348:	80 81       	ld	r24, Z
     34a:	80 68       	ori	r24, 0x80	; 128
     34c:	80 83       	st	Z, r24
}
     34e:	08 95       	ret

00000350 <__vector_18>:
	return 0;

}

ISR (TIMER0_OVF_vect) // timer0 overflow interrupt
{	
     350:	1f 92       	push	r1
     352:	0f 92       	push	r0
     354:	0f b6       	in	r0, 0x3f	; 63
     356:	0f 92       	push	r0
     358:	11 24       	eor	r1, r1
     35a:	2f 93       	push	r18
     35c:	3f 93       	push	r19
     35e:	8f 93       	push	r24
     360:	9f 93       	push	r25

void LCD_print(uint8_t m1, uint8_t m2, uint8_t m3, uint8_t m4, uint8_t c1, uint8_t c2, uint8_t c3, uint8_t c4, uint8_t overload); //m - measured, c - configured

uint8_t UP_pressed()
{
	if (!(PINA & (1<<UP))) //ha le van nyomva
     362:	02 99       	sbic	0x00, 2	; 0
     364:	14 c0       	rjmp	.+40     	; 0x38e <__vector_18+0x3e>

ISR (TIMER0_OVF_vect) // timer0 overflow interrupt
{	
	if (UP_pressed())
	{
		if (set_value<1600 && overflows == 0) {overflows++; return;}
     366:	20 91 0f 01 	lds	r18, 0x010F
     36a:	30 91 10 01 	lds	r19, 0x0110
     36e:	86 e0       	ldi	r24, 0x06	; 6
     370:	20 34       	cpi	r18, 0x40	; 64
     372:	38 07       	cpc	r19, r24
     374:	60 f4       	brcc	.+24     	; 0x38e <__vector_18+0x3e>
     376:	80 91 3c 01 	lds	r24, 0x013C
     37a:	90 91 3d 01 	lds	r25, 0x013D
     37e:	00 97       	sbiw	r24, 0x00	; 0
     380:	a9 f0       	breq	.+42     	; 0x3ac <__vector_18+0x5c>
		if (set_value<=1599 && overflows >= 120) {set_value+=1; overflows++; return;}
     382:	88 37       	cpi	r24, 0x78	; 120
     384:	91 05       	cpc	r25, r1
     386:	18 f0       	brcs	.+6      	; 0x38e <__vector_18+0x3e>
     388:	2f 5f       	subi	r18, 0xFF	; 255
     38a:	3f 4f       	sbci	r19, 0xFF	; 255
     38c:	17 c0       	rjmp	.+46     	; 0x3bc <__vector_18+0x6c>
	return 0; 
}

uint8_t DOWN_pressed()
{
	if (!(PINA & (1<<DOWN))) //ha le van nyomva
     38e:	01 99       	sbic	0x00, 1	; 0
     390:	1a c0       	rjmp	.+52     	; 0x3c6 <__vector_18+0x76>
		if (set_value<=1599 && overflows >= 120) {set_value+=1; overflows++; return;}
	}
	
	if (DOWN_pressed())
	{
		if (set_value>0 && overflows == 0) {overflows++; return;}
     392:	20 91 0f 01 	lds	r18, 0x010F
     396:	30 91 10 01 	lds	r19, 0x0110
     39a:	21 15       	cp	r18, r1
     39c:	31 05       	cpc	r19, r1
     39e:	99 f0       	breq	.+38     	; 0x3c6 <__vector_18+0x76>
     3a0:	80 91 3c 01 	lds	r24, 0x013C
     3a4:	90 91 3d 01 	lds	r25, 0x013D
     3a8:	00 97       	sbiw	r24, 0x00	; 0
     3aa:	19 f4       	brne	.+6      	; 0x3b2 <__vector_18+0x62>
     3ac:	81 e0       	ldi	r24, 0x01	; 1
     3ae:	90 e0       	ldi	r25, 0x00	; 0
     3b0:	0f c0       	rjmp	.+30     	; 0x3d0 <__vector_18+0x80>
		if (set_value>=1 && overflows >= 120) {set_value-=1; overflows++; return;}
     3b2:	88 37       	cpi	r24, 0x78	; 120
     3b4:	91 05       	cpc	r25, r1
     3b6:	38 f0       	brcs	.+14     	; 0x3c6 <__vector_18+0x76>
     3b8:	21 50       	subi	r18, 0x01	; 1
     3ba:	30 40       	sbci	r19, 0x00	; 0
     3bc:	30 93 10 01 	sts	0x0110, r19
     3c0:	20 93 0f 01 	sts	0x010F, r18
     3c4:	04 c0       	rjmp	.+8      	; 0x3ce <__vector_18+0x7e>
	} 
	
	overflows++;
     3c6:	80 91 3c 01 	lds	r24, 0x013C
     3ca:	90 91 3d 01 	lds	r25, 0x013D
     3ce:	01 96       	adiw	r24, 0x01	; 1
     3d0:	90 93 3d 01 	sts	0x013D, r25
     3d4:	80 93 3c 01 	sts	0x013C, r24
}
     3d8:	9f 91       	pop	r25
     3da:	8f 91       	pop	r24
     3dc:	3f 91       	pop	r19
     3de:	2f 91       	pop	r18
     3e0:	0f 90       	pop	r0
     3e2:	0f be       	out	0x3f, r0	; 63
     3e4:	0f 90       	pop	r0
     3e6:	1f 90       	pop	r1
     3e8:	18 95       	reti

000003ea <__vector_24>:

ISR(ADC_vect)
{
     3ea:	1f 92       	push	r1
     3ec:	0f 92       	push	r0
     3ee:	0f b6       	in	r0, 0x3f	; 63
     3f0:	0f 92       	push	r0
     3f2:	11 24       	eor	r1, r1
     3f4:	8f 93       	push	r24
     3f6:	9f 93       	push	r25
  adc_value = ADC;
     3f8:	80 91 78 00 	lds	r24, 0x0078
     3fc:	90 91 79 00 	lds	r25, 0x0079
     400:	90 93 e0 07 	sts	0x07E0, r25
     404:	80 93 df 07 	sts	0x07DF, r24
  converted = 1;
     408:	81 e0       	ldi	r24, 0x01	; 1
     40a:	80 93 da 07 	sts	0x07DA, r24
}
     40e:	9f 91       	pop	r25
     410:	8f 91       	pop	r24
     412:	0f 90       	pop	r0
     414:	0f be       	out	0x3f, r0	; 63
     416:	0f 90       	pop	r0
     418:	1f 90       	pop	r1
     41a:	18 95       	reti

0000041c <LCD_print>:

//A COM-ok egymas utan kapcsolnak be es ki. A koztes idoben 1/2 feszultsegen pihennek.
//Mindenik COM allapotnal bekapcsolnak a szamjegyhez tartozo szegmenscsoportok
//A ket felperiodus egymas ellentete
void LCD_print(uint8_t m1, uint8_t m2, uint8_t m3, uint8_t m4, uint8_t c1, uint8_t c2, uint8_t c3, uint8_t c4, uint8_t overload)
{	
     41c:	2f 92       	push	r2
     41e:	3f 92       	push	r3
     420:	4f 92       	push	r4
     422:	5f 92       	push	r5
     424:	6f 92       	push	r6
     426:	7f 92       	push	r7
     428:	8f 92       	push	r8
     42a:	9f 92       	push	r9
     42c:	af 92       	push	r10
     42e:	bf 92       	push	r11
     430:	cf 92       	push	r12
     432:	df 92       	push	r13
     434:	ef 92       	push	r14
     436:	ff 92       	push	r15
     438:	0f 93       	push	r16
     43a:	1f 93       	push	r17
     43c:	df 93       	push	r29
     43e:	cf 93       	push	r28
     440:	00 d0       	rcall	.+0      	; 0x442 <LCD_print+0x26>
     442:	0f 92       	push	r0
     444:	cd b7       	in	r28, 0x3d	; 61
     446:	de b7       	in	r29, 0x3e	; 62
     448:	16 2f       	mov	r17, r22
     44a:	f4 2e       	mov	r15, r20
     44c:	d2 2e       	mov	r13, r18
     44e:	c9 82       	std	Y+1, r12	; 0x01
     450:	aa 82       	std	Y+2, r10	; 0x02
     452:	8b 82       	std	Y+3, r8	; 0x03
	//pozitiv felperiodus
	COM3_1P2; COM0_GND; //COM0-hoz tartozo szegmensek: a Segments tomb 0. oszlopa
     454:	53 98       	cbi	0x0a, 3	; 10
     456:	5b 98       	cbi	0x0b, 3	; 11
     458:	50 9a       	sbi	0x0a, 0	; 10
     45a:	58 98       	cbi	0x0b, 0	; 11
	LoadSEGs[m1](); if (Segments[0][0]) {SEG1_ON} else {SEG1_OFF} if (Segments[1][0]) {SEG2_ON} else {SEG2_OFF} 
     45c:	28 2e       	mov	r2, r24
     45e:	33 24       	eor	r3, r3
     460:	f1 01       	movw	r30, r2
     462:	ee 0f       	add	r30, r30
     464:	ff 1f       	adc	r31, r31
     466:	ef 5e       	subi	r30, 0xEF	; 239
     468:	fe 4f       	sbci	r31, 0xFE	; 254
     46a:	01 90       	ld	r0, Z+
     46c:	f0 81       	ld	r31, Z
     46e:	e0 2d       	mov	r30, r0
     470:	09 95       	icall
     472:	80 91 2c 01 	lds	r24, 0x012C
     476:	88 23       	and	r24, r24
     478:	11 f0       	breq	.+4      	; 0x47e <LCD_print+0x62>
     47a:	14 9a       	sbi	0x02, 4	; 2
     47c:	01 c0       	rjmp	.+2      	; 0x480 <LCD_print+0x64>
     47e:	14 98       	cbi	0x02, 4	; 2
     480:	80 91 30 01 	lds	r24, 0x0130
     484:	88 23       	and	r24, r24
     486:	11 f0       	breq	.+4      	; 0x48c <LCD_print+0x70>
     488:	15 9a       	sbi	0x02, 5	; 2
     48a:	01 c0       	rjmp	.+2      	; 0x48e <LCD_print+0x72>
     48c:	15 98       	cbi	0x02, 5	; 2
	LoadSEGs[m2](); if (Segments[0][0]) {SEG3_ON} else {SEG3_OFF} if (Segments[1][0]) {SEG4_ON} else {SEG4_OFF} 
     48e:	41 2e       	mov	r4, r17
     490:	55 24       	eor	r5, r5
     492:	f2 01       	movw	r30, r4
     494:	ee 0f       	add	r30, r30
     496:	ff 1f       	adc	r31, r31
     498:	ef 5e       	subi	r30, 0xEF	; 239
     49a:	fe 4f       	sbci	r31, 0xFE	; 254
     49c:	01 90       	ld	r0, Z+
     49e:	f0 81       	ld	r31, Z
     4a0:	e0 2d       	mov	r30, r0
     4a2:	09 95       	icall
     4a4:	80 91 2c 01 	lds	r24, 0x012C
     4a8:	88 23       	and	r24, r24
     4aa:	11 f0       	breq	.+4      	; 0x4b0 <LCD_print+0x94>
     4ac:	16 9a       	sbi	0x02, 6	; 2
     4ae:	01 c0       	rjmp	.+2      	; 0x4b2 <LCD_print+0x96>
     4b0:	16 98       	cbi	0x02, 6	; 2
     4b2:	80 91 30 01 	lds	r24, 0x0130
     4b6:	88 23       	and	r24, r24
     4b8:	11 f0       	breq	.+4      	; 0x4be <LCD_print+0xa2>
     4ba:	17 9a       	sbi	0x02, 7	; 2
     4bc:	01 c0       	rjmp	.+2      	; 0x4c0 <LCD_print+0xa4>
     4be:	17 98       	cbi	0x02, 7	; 2
	LoadSEGs[m3](); if (Segments[0][0]) {SEG5_ON} else {SEG5_OFF} if (Segments[1][0]) {SEG6_ON} else {SEG6_OFF}
     4c0:	6f 2c       	mov	r6, r15
     4c2:	77 24       	eor	r7, r7
     4c4:	f3 01       	movw	r30, r6
     4c6:	ee 0f       	add	r30, r30
     4c8:	ff 1f       	adc	r31, r31
     4ca:	ef 5e       	subi	r30, 0xEF	; 239
     4cc:	fe 4f       	sbci	r31, 0xFE	; 254
     4ce:	01 90       	ld	r0, Z+
     4d0:	f0 81       	ld	r31, Z
     4d2:	e0 2d       	mov	r30, r0
     4d4:	09 95       	icall
     4d6:	80 91 2c 01 	lds	r24, 0x012C
     4da:	88 23       	and	r24, r24
     4dc:	11 f0       	breq	.+4      	; 0x4e2 <LCD_print+0xc6>
     4de:	47 9a       	sbi	0x08, 7	; 8
     4e0:	01 c0       	rjmp	.+2      	; 0x4e4 <LCD_print+0xc8>
     4e2:	47 98       	cbi	0x08, 7	; 8
     4e4:	80 91 30 01 	lds	r24, 0x0130
     4e8:	88 23       	and	r24, r24
     4ea:	11 f0       	breq	.+4      	; 0x4f0 <LCD_print+0xd4>
     4ec:	46 9a       	sbi	0x08, 6	; 8
     4ee:	01 c0       	rjmp	.+2      	; 0x4f2 <LCD_print+0xd6>
     4f0:	46 98       	cbi	0x08, 6	; 8
	LoadSEGs[m4](); if (Segments[0][0]) {SEG7_ON} else {SEG7_OFF} if (Segments[1][0]) {SEG8_ON} else {SEG8_OFF}
     4f2:	8d 2c       	mov	r8, r13
     4f4:	99 24       	eor	r9, r9
     4f6:	f4 01       	movw	r30, r8
     4f8:	ee 0f       	add	r30, r30
     4fa:	ff 1f       	adc	r31, r31
     4fc:	ef 5e       	subi	r30, 0xEF	; 239
     4fe:	fe 4f       	sbci	r31, 0xFE	; 254
     500:	01 90       	ld	r0, Z+
     502:	f0 81       	ld	r31, Z
     504:	e0 2d       	mov	r30, r0
     506:	09 95       	icall
     508:	80 91 2c 01 	lds	r24, 0x012C
     50c:	88 23       	and	r24, r24
     50e:	11 f0       	breq	.+4      	; 0x514 <LCD_print+0xf8>
     510:	45 9a       	sbi	0x08, 5	; 8
     512:	01 c0       	rjmp	.+2      	; 0x516 <LCD_print+0xfa>
     514:	45 98       	cbi	0x08, 5	; 8
     516:	80 91 30 01 	lds	r24, 0x0130
     51a:	88 23       	and	r24, r24
     51c:	11 f0       	breq	.+4      	; 0x522 <LCD_print+0x106>
     51e:	44 9a       	sbi	0x08, 4	; 8
     520:	01 c0       	rjmp	.+2      	; 0x524 <LCD_print+0x108>
     522:	44 98       	cbi	0x08, 4	; 8
	LoadSEGs[c1](); if (Segments[0][0]) {SEG26_ON} else {SEG26_OFF} if (Segments[1][0]) {SEG25_ON} else {SEG25_OFF} 
     524:	a0 2e       	mov	r10, r16
     526:	bb 24       	eor	r11, r11
     528:	f5 01       	movw	r30, r10
     52a:	ee 0f       	add	r30, r30
     52c:	ff 1f       	adc	r31, r31
     52e:	ef 5e       	subi	r30, 0xEF	; 239
     530:	fe 4f       	sbci	r31, 0xFE	; 254
     532:	01 90       	ld	r0, Z+
     534:	f0 81       	ld	r31, Z
     536:	e0 2d       	mov	r30, r0
     538:	09 95       	icall
     53a:	80 91 2c 01 	lds	r24, 0x012C
     53e:	88 23       	and	r24, r24
     540:	11 f0       	breq	.+4      	; 0x546 <LCD_print+0x12a>
     542:	5c 9a       	sbi	0x0b, 4	; 11
     544:	01 c0       	rjmp	.+2      	; 0x548 <LCD_print+0x12c>
     546:	5c 98       	cbi	0x0b, 4	; 11
     548:	80 91 30 01 	lds	r24, 0x0130
     54c:	88 23       	and	r24, r24
     54e:	11 f0       	breq	.+4      	; 0x554 <LCD_print+0x138>
     550:	5d 9a       	sbi	0x0b, 5	; 11
     552:	01 c0       	rjmp	.+2      	; 0x556 <LCD_print+0x13a>
     554:	5d 98       	cbi	0x0b, 5	; 11
	LoadSEGs[c2](); if (Segments[0][0]) {SEG24_ON} else {SEG24_OFF} if (Segments[1][0]) {SEG23_ON} else {SEG23_OFF} 
     556:	ce 2c       	mov	r12, r14
     558:	dd 24       	eor	r13, r13
     55a:	f6 01       	movw	r30, r12
     55c:	ee 0f       	add	r30, r30
     55e:	ff 1f       	adc	r31, r31
     560:	ef 5e       	subi	r30, 0xEF	; 239
     562:	fe 4f       	sbci	r31, 0xFE	; 254
     564:	01 90       	ld	r0, Z+
     566:	f0 81       	ld	r31, Z
     568:	e0 2d       	mov	r30, r0
     56a:	09 95       	icall
     56c:	80 91 2c 01 	lds	r24, 0x012C
     570:	88 23       	and	r24, r24
     572:	11 f0       	breq	.+4      	; 0x578 <LCD_print+0x15c>
     574:	5e 9a       	sbi	0x0b, 6	; 11
     576:	01 c0       	rjmp	.+2      	; 0x57a <LCD_print+0x15e>
     578:	5e 98       	cbi	0x0b, 6	; 11
     57a:	80 91 30 01 	lds	r24, 0x0130
     57e:	88 23       	and	r24, r24
     580:	11 f0       	breq	.+4      	; 0x586 <LCD_print+0x16a>
     582:	5f 9a       	sbi	0x0b, 7	; 11
     584:	01 c0       	rjmp	.+2      	; 0x588 <LCD_print+0x16c>
     586:	5f 98       	cbi	0x0b, 7	; 11
	LoadSEGs[c3](); if (Segments[0][0]) {SEG22_ON} else {SEG22_OFF} if (Segments[1][0]) {SEG21_ON} else {SEG21_OFF}
     588:	89 81       	ldd	r24, Y+1	; 0x01
     58a:	e8 2e       	mov	r14, r24
     58c:	ff 24       	eor	r15, r15
     58e:	f7 01       	movw	r30, r14
     590:	ee 0f       	add	r30, r30
     592:	ff 1f       	adc	r31, r31
     594:	ef 5e       	subi	r30, 0xEF	; 239
     596:	fe 4f       	sbci	r31, 0xFE	; 254
     598:	01 90       	ld	r0, Z+
     59a:	f0 81       	ld	r31, Z
     59c:	e0 2d       	mov	r30, r0
     59e:	09 95       	icall
     5a0:	80 91 2c 01 	lds	r24, 0x012C
     5a4:	88 23       	and	r24, r24
     5a6:	11 f0       	breq	.+4      	; 0x5ac <LCD_print+0x190>
     5a8:	40 9a       	sbi	0x08, 0	; 8
     5aa:	01 c0       	rjmp	.+2      	; 0x5ae <LCD_print+0x192>
     5ac:	40 98       	cbi	0x08, 0	; 8
     5ae:	80 91 30 01 	lds	r24, 0x0130
     5b2:	88 23       	and	r24, r24
     5b4:	11 f0       	breq	.+4      	; 0x5ba <LCD_print+0x19e>
     5b6:	41 9a       	sbi	0x08, 1	; 8
     5b8:	01 c0       	rjmp	.+2      	; 0x5bc <LCD_print+0x1a0>
     5ba:	41 98       	cbi	0x08, 1	; 8
	LoadSEGs[c4](); if (Segments[0][0]) {SEG20_ON} else {SEG20_OFF} if (Segments[1][0]) {SEG19_ON} else {SEG19_OFF}
     5bc:	9a 81       	ldd	r25, Y+2	; 0x02
     5be:	09 2f       	mov	r16, r25
     5c0:	10 e0       	ldi	r17, 0x00	; 0
     5c2:	f8 01       	movw	r30, r16
     5c4:	ee 0f       	add	r30, r30
     5c6:	ff 1f       	adc	r31, r31
     5c8:	ef 5e       	subi	r30, 0xEF	; 239
     5ca:	fe 4f       	sbci	r31, 0xFE	; 254
     5cc:	01 90       	ld	r0, Z+
     5ce:	f0 81       	ld	r31, Z
     5d0:	e0 2d       	mov	r30, r0
     5d2:	09 95       	icall
     5d4:	80 91 2c 01 	lds	r24, 0x012C
     5d8:	88 23       	and	r24, r24
     5da:	11 f0       	breq	.+4      	; 0x5e0 <LCD_print+0x1c4>
     5dc:	42 9a       	sbi	0x08, 2	; 8
     5de:	01 c0       	rjmp	.+2      	; 0x5e2 <LCD_print+0x1c6>
     5e0:	42 98       	cbi	0x08, 2	; 8
     5e2:	80 91 30 01 	lds	r24, 0x0130
     5e6:	88 23       	and	r24, r24
     5e8:	11 f0       	breq	.+4      	; 0x5ee <LCD_print+0x1d2>
     5ea:	43 9a       	sbi	0x08, 3	; 8
     5ec:	01 c0       	rjmp	.+2      	; 0x5f0 <LCD_print+0x1d4>
     5ee:	43 98       	cbi	0x08, 3	; 8
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     5f0:	80 e4       	ldi	r24, 0x40	; 64
     5f2:	9f e1       	ldi	r25, 0x1F	; 31
     5f4:	01 97       	sbiw	r24, 0x01	; 1
     5f6:	f1 f7       	brne	.-4      	; 0x5f4 <LCD_print+0x1d8>
	_delay_ms(delay);
	
	COM0_1P2; COM1_GND; 
     5f8:	50 98       	cbi	0x0a, 0	; 10
     5fa:	58 98       	cbi	0x0b, 0	; 11
     5fc:	51 9a       	sbi	0x0a, 1	; 10
     5fe:	59 98       	cbi	0x0b, 1	; 11
	LoadSEGs[m1](); if (Segments[0][1]) {SEG1_ON} else {SEG1_OFF} if (Segments[1][1]) {SEG2_ON} else {SEG2_OFF} 
     600:	f1 01       	movw	r30, r2
     602:	ee 0f       	add	r30, r30
     604:	ff 1f       	adc	r31, r31
     606:	ef 5e       	subi	r30, 0xEF	; 239
     608:	fe 4f       	sbci	r31, 0xFE	; 254
     60a:	01 90       	ld	r0, Z+
     60c:	f0 81       	ld	r31, Z
     60e:	e0 2d       	mov	r30, r0
     610:	09 95       	icall
     612:	80 91 2d 01 	lds	r24, 0x012D
     616:	88 23       	and	r24, r24
     618:	11 f0       	breq	.+4      	; 0x61e <LCD_print+0x202>
     61a:	14 9a       	sbi	0x02, 4	; 2
     61c:	01 c0       	rjmp	.+2      	; 0x620 <LCD_print+0x204>
     61e:	14 98       	cbi	0x02, 4	; 2
     620:	80 91 31 01 	lds	r24, 0x0131
     624:	88 23       	and	r24, r24
     626:	11 f0       	breq	.+4      	; 0x62c <LCD_print+0x210>
     628:	15 9a       	sbi	0x02, 5	; 2
     62a:	01 c0       	rjmp	.+2      	; 0x62e <LCD_print+0x212>
     62c:	15 98       	cbi	0x02, 5	; 2
	LoadSEGs[m2](); if (Segments[0][1]) {SEG3_ON} else {SEG3_OFF} if (Segments[1][1]) {SEG4_ON} else {SEG4_OFF} 
     62e:	f2 01       	movw	r30, r4
     630:	ee 0f       	add	r30, r30
     632:	ff 1f       	adc	r31, r31
     634:	ef 5e       	subi	r30, 0xEF	; 239
     636:	fe 4f       	sbci	r31, 0xFE	; 254
     638:	01 90       	ld	r0, Z+
     63a:	f0 81       	ld	r31, Z
     63c:	e0 2d       	mov	r30, r0
     63e:	09 95       	icall
     640:	80 91 2d 01 	lds	r24, 0x012D
     644:	88 23       	and	r24, r24
     646:	11 f0       	breq	.+4      	; 0x64c <LCD_print+0x230>
     648:	16 9a       	sbi	0x02, 6	; 2
     64a:	01 c0       	rjmp	.+2      	; 0x64e <LCD_print+0x232>
     64c:	16 98       	cbi	0x02, 6	; 2
     64e:	80 91 31 01 	lds	r24, 0x0131
     652:	88 23       	and	r24, r24
     654:	11 f0       	breq	.+4      	; 0x65a <LCD_print+0x23e>
     656:	17 9a       	sbi	0x02, 7	; 2
     658:	01 c0       	rjmp	.+2      	; 0x65c <LCD_print+0x240>
     65a:	17 98       	cbi	0x02, 7	; 2
	LoadSEGs[m3](); if (Segments[0][1]) {SEG5_ON} else {SEG5_OFF} if (Segments[1][1]) {SEG6_ON} else {SEG6_OFF} 
     65c:	f3 01       	movw	r30, r6
     65e:	ee 0f       	add	r30, r30
     660:	ff 1f       	adc	r31, r31
     662:	ef 5e       	subi	r30, 0xEF	; 239
     664:	fe 4f       	sbci	r31, 0xFE	; 254
     666:	01 90       	ld	r0, Z+
     668:	f0 81       	ld	r31, Z
     66a:	e0 2d       	mov	r30, r0
     66c:	09 95       	icall
     66e:	80 91 2d 01 	lds	r24, 0x012D
     672:	88 23       	and	r24, r24
     674:	11 f0       	breq	.+4      	; 0x67a <LCD_print+0x25e>
     676:	47 9a       	sbi	0x08, 7	; 8
     678:	01 c0       	rjmp	.+2      	; 0x67c <LCD_print+0x260>
     67a:	47 98       	cbi	0x08, 7	; 8
     67c:	80 91 31 01 	lds	r24, 0x0131
     680:	88 23       	and	r24, r24
     682:	11 f0       	breq	.+4      	; 0x688 <LCD_print+0x26c>
     684:	46 9a       	sbi	0x08, 6	; 8
     686:	01 c0       	rjmp	.+2      	; 0x68a <LCD_print+0x26e>
     688:	46 98       	cbi	0x08, 6	; 8
	LoadSEGs[m4](); if (Segments[0][1]) {SEG7_ON} else {SEG7_OFF} if (Segments[1][1]) {SEG8_ON} else {SEG8_OFF} 
     68a:	f4 01       	movw	r30, r8
     68c:	ee 0f       	add	r30, r30
     68e:	ff 1f       	adc	r31, r31
     690:	ef 5e       	subi	r30, 0xEF	; 239
     692:	fe 4f       	sbci	r31, 0xFE	; 254
     694:	01 90       	ld	r0, Z+
     696:	f0 81       	ld	r31, Z
     698:	e0 2d       	mov	r30, r0
     69a:	09 95       	icall
     69c:	80 91 2d 01 	lds	r24, 0x012D
     6a0:	88 23       	and	r24, r24
     6a2:	11 f0       	breq	.+4      	; 0x6a8 <LCD_print+0x28c>
     6a4:	45 9a       	sbi	0x08, 5	; 8
     6a6:	01 c0       	rjmp	.+2      	; 0x6aa <LCD_print+0x28e>
     6a8:	45 98       	cbi	0x08, 5	; 8
     6aa:	80 91 31 01 	lds	r24, 0x0131
     6ae:	88 23       	and	r24, r24
     6b0:	11 f0       	breq	.+4      	; 0x6b6 <LCD_print+0x29a>
     6b2:	44 9a       	sbi	0x08, 4	; 8
     6b4:	01 c0       	rjmp	.+2      	; 0x6b8 <LCD_print+0x29c>
     6b6:	44 98       	cbi	0x08, 4	; 8
	LoadSEGs[c1](); if (Segments[0][1]) {SEG26_ON} else {SEG26_OFF} if (Segments[1][1]) {SEG25_ON} else {SEG25_OFF} 
     6b8:	f5 01       	movw	r30, r10
     6ba:	ee 0f       	add	r30, r30
     6bc:	ff 1f       	adc	r31, r31
     6be:	ef 5e       	subi	r30, 0xEF	; 239
     6c0:	fe 4f       	sbci	r31, 0xFE	; 254
     6c2:	01 90       	ld	r0, Z+
     6c4:	f0 81       	ld	r31, Z
     6c6:	e0 2d       	mov	r30, r0
     6c8:	09 95       	icall
     6ca:	80 91 2d 01 	lds	r24, 0x012D
     6ce:	88 23       	and	r24, r24
     6d0:	11 f0       	breq	.+4      	; 0x6d6 <LCD_print+0x2ba>
     6d2:	5c 9a       	sbi	0x0b, 4	; 11
     6d4:	01 c0       	rjmp	.+2      	; 0x6d8 <LCD_print+0x2bc>
     6d6:	5c 98       	cbi	0x0b, 4	; 11
     6d8:	80 91 31 01 	lds	r24, 0x0131
     6dc:	88 23       	and	r24, r24
     6de:	11 f0       	breq	.+4      	; 0x6e4 <LCD_print+0x2c8>
     6e0:	5d 9a       	sbi	0x0b, 5	; 11
     6e2:	01 c0       	rjmp	.+2      	; 0x6e6 <LCD_print+0x2ca>
     6e4:	5d 98       	cbi	0x0b, 5	; 11
	LoadSEGs[c2](); if (Segments[0][1]) {SEG24_ON} else {SEG24_OFF} if (Segments[1][1]) {SEG23_ON} else {SEG23_OFF} 
     6e6:	f6 01       	movw	r30, r12
     6e8:	ee 0f       	add	r30, r30
     6ea:	ff 1f       	adc	r31, r31
     6ec:	ef 5e       	subi	r30, 0xEF	; 239
     6ee:	fe 4f       	sbci	r31, 0xFE	; 254
     6f0:	01 90       	ld	r0, Z+
     6f2:	f0 81       	ld	r31, Z
     6f4:	e0 2d       	mov	r30, r0
     6f6:	09 95       	icall
     6f8:	80 91 2d 01 	lds	r24, 0x012D
     6fc:	88 23       	and	r24, r24
     6fe:	11 f0       	breq	.+4      	; 0x704 <LCD_print+0x2e8>
     700:	5e 9a       	sbi	0x0b, 6	; 11
     702:	01 c0       	rjmp	.+2      	; 0x706 <LCD_print+0x2ea>
     704:	5e 98       	cbi	0x0b, 6	; 11
     706:	80 91 31 01 	lds	r24, 0x0131
     70a:	88 23       	and	r24, r24
     70c:	11 f0       	breq	.+4      	; 0x712 <LCD_print+0x2f6>
     70e:	5f 9a       	sbi	0x0b, 7	; 11
     710:	01 c0       	rjmp	.+2      	; 0x714 <LCD_print+0x2f8>
     712:	5f 98       	cbi	0x0b, 7	; 11
	LoadSEGs[c3](); if (Segments[0][1]) {SEG22_ON} else {SEG22_OFF} if (Segments[1][1]) {SEG21_ON} else {SEG21_OFF}
     714:	f7 01       	movw	r30, r14
     716:	ee 0f       	add	r30, r30
     718:	ff 1f       	adc	r31, r31
     71a:	ef 5e       	subi	r30, 0xEF	; 239
     71c:	fe 4f       	sbci	r31, 0xFE	; 254
     71e:	01 90       	ld	r0, Z+
     720:	f0 81       	ld	r31, Z
     722:	e0 2d       	mov	r30, r0
     724:	09 95       	icall
     726:	80 91 2d 01 	lds	r24, 0x012D
     72a:	88 23       	and	r24, r24
     72c:	11 f0       	breq	.+4      	; 0x732 <LCD_print+0x316>
     72e:	40 9a       	sbi	0x08, 0	; 8
     730:	01 c0       	rjmp	.+2      	; 0x734 <LCD_print+0x318>
     732:	40 98       	cbi	0x08, 0	; 8
     734:	80 91 31 01 	lds	r24, 0x0131
     738:	88 23       	and	r24, r24
     73a:	11 f0       	breq	.+4      	; 0x740 <LCD_print+0x324>
     73c:	41 9a       	sbi	0x08, 1	; 8
     73e:	01 c0       	rjmp	.+2      	; 0x742 <LCD_print+0x326>
     740:	41 98       	cbi	0x08, 1	; 8
	LoadSEGs[c4](); if (Segments[0][1]) {SEG20_ON} else {SEG20_OFF} if (Segments[1][1]) {SEG19_ON} else {SEG19_OFF}
     742:	f8 01       	movw	r30, r16
     744:	ee 0f       	add	r30, r30
     746:	ff 1f       	adc	r31, r31
     748:	ef 5e       	subi	r30, 0xEF	; 239
     74a:	fe 4f       	sbci	r31, 0xFE	; 254
     74c:	01 90       	ld	r0, Z+
     74e:	f0 81       	ld	r31, Z
     750:	e0 2d       	mov	r30, r0
     752:	09 95       	icall
     754:	80 91 2d 01 	lds	r24, 0x012D
     758:	88 23       	and	r24, r24
     75a:	11 f0       	breq	.+4      	; 0x760 <LCD_print+0x344>
     75c:	42 9a       	sbi	0x08, 2	; 8
     75e:	01 c0       	rjmp	.+2      	; 0x762 <LCD_print+0x346>
     760:	42 98       	cbi	0x08, 2	; 8
     762:	80 91 31 01 	lds	r24, 0x0131
     766:	88 23       	and	r24, r24
     768:	11 f0       	breq	.+4      	; 0x76e <LCD_print+0x352>
     76a:	43 9a       	sbi	0x08, 3	; 8
     76c:	01 c0       	rjmp	.+2      	; 0x770 <LCD_print+0x354>
     76e:	43 98       	cbi	0x08, 3	; 8
     770:	80 e4       	ldi	r24, 0x40	; 64
     772:	9f e1       	ldi	r25, 0x1F	; 31
     774:	01 97       	sbiw	r24, 0x01	; 1
     776:	f1 f7       	brne	.-4      	; 0x774 <LCD_print+0x358>
	_delay_ms(delay);
	
	COM1_1P2; COM2_GND; 
     778:	51 98       	cbi	0x0a, 1	; 10
     77a:	59 98       	cbi	0x0b, 1	; 11
     77c:	52 9a       	sbi	0x0a, 2	; 10
     77e:	5a 98       	cbi	0x0b, 2	; 11
	LoadSEGs[m1](); if (Segments[0][2]) {SEG1_ON} else {SEG1_OFF} if (Segments[1][2]) {SEG2_ON} else {SEG2_OFF} 
     780:	f1 01       	movw	r30, r2
     782:	ee 0f       	add	r30, r30
     784:	ff 1f       	adc	r31, r31
     786:	ef 5e       	subi	r30, 0xEF	; 239
     788:	fe 4f       	sbci	r31, 0xFE	; 254
     78a:	01 90       	ld	r0, Z+
     78c:	f0 81       	ld	r31, Z
     78e:	e0 2d       	mov	r30, r0
     790:	09 95       	icall
     792:	80 91 2e 01 	lds	r24, 0x012E
     796:	88 23       	and	r24, r24
     798:	11 f0       	breq	.+4      	; 0x79e <LCD_print+0x382>
     79a:	14 9a       	sbi	0x02, 4	; 2
     79c:	01 c0       	rjmp	.+2      	; 0x7a0 <LCD_print+0x384>
     79e:	14 98       	cbi	0x02, 4	; 2
     7a0:	80 91 32 01 	lds	r24, 0x0132
     7a4:	88 23       	and	r24, r24
     7a6:	11 f0       	breq	.+4      	; 0x7ac <LCD_print+0x390>
     7a8:	15 9a       	sbi	0x02, 5	; 2
     7aa:	01 c0       	rjmp	.+2      	; 0x7ae <LCD_print+0x392>
     7ac:	15 98       	cbi	0x02, 5	; 2
	LoadSEGs[m2](); if (Segments[0][2]) {SEG3_ON} else {SEG3_OFF} if (Segments[1][2]) {SEG4_ON} else {SEG4_OFF}  
     7ae:	f2 01       	movw	r30, r4
     7b0:	ee 0f       	add	r30, r30
     7b2:	ff 1f       	adc	r31, r31
     7b4:	ef 5e       	subi	r30, 0xEF	; 239
     7b6:	fe 4f       	sbci	r31, 0xFE	; 254
     7b8:	01 90       	ld	r0, Z+
     7ba:	f0 81       	ld	r31, Z
     7bc:	e0 2d       	mov	r30, r0
     7be:	09 95       	icall
     7c0:	80 91 2e 01 	lds	r24, 0x012E
     7c4:	88 23       	and	r24, r24
     7c6:	11 f0       	breq	.+4      	; 0x7cc <LCD_print+0x3b0>
     7c8:	16 9a       	sbi	0x02, 6	; 2
     7ca:	01 c0       	rjmp	.+2      	; 0x7ce <LCD_print+0x3b2>
     7cc:	16 98       	cbi	0x02, 6	; 2
     7ce:	80 91 32 01 	lds	r24, 0x0132
     7d2:	88 23       	and	r24, r24
     7d4:	11 f0       	breq	.+4      	; 0x7da <LCD_print+0x3be>
     7d6:	17 9a       	sbi	0x02, 7	; 2
     7d8:	01 c0       	rjmp	.+2      	; 0x7dc <LCD_print+0x3c0>
     7da:	17 98       	cbi	0x02, 7	; 2
	LoadSEGs[m3](); if (Segments[0][2]) {SEG5_ON} else {SEG5_OFF} if (Segments[1][2]) {SEG6_ON} else {SEG6_OFF} 
     7dc:	f3 01       	movw	r30, r6
     7de:	ee 0f       	add	r30, r30
     7e0:	ff 1f       	adc	r31, r31
     7e2:	ef 5e       	subi	r30, 0xEF	; 239
     7e4:	fe 4f       	sbci	r31, 0xFE	; 254
     7e6:	01 90       	ld	r0, Z+
     7e8:	f0 81       	ld	r31, Z
     7ea:	e0 2d       	mov	r30, r0
     7ec:	09 95       	icall
     7ee:	80 91 2e 01 	lds	r24, 0x012E
     7f2:	88 23       	and	r24, r24
     7f4:	11 f0       	breq	.+4      	; 0x7fa <LCD_print+0x3de>
     7f6:	47 9a       	sbi	0x08, 7	; 8
     7f8:	01 c0       	rjmp	.+2      	; 0x7fc <LCD_print+0x3e0>
     7fa:	47 98       	cbi	0x08, 7	; 8
     7fc:	80 91 32 01 	lds	r24, 0x0132
     800:	88 23       	and	r24, r24
     802:	11 f0       	breq	.+4      	; 0x808 <LCD_print+0x3ec>
     804:	46 9a       	sbi	0x08, 6	; 8
     806:	01 c0       	rjmp	.+2      	; 0x80a <LCD_print+0x3ee>
     808:	46 98       	cbi	0x08, 6	; 8
	LoadSEGs[m4](); if (Segments[0][2]) {SEG7_ON} else {SEG7_OFF} if (Segments[1][2]) {SEG8_ON} else {SEG8_OFF} 
     80a:	f4 01       	movw	r30, r8
     80c:	ee 0f       	add	r30, r30
     80e:	ff 1f       	adc	r31, r31
     810:	ef 5e       	subi	r30, 0xEF	; 239
     812:	fe 4f       	sbci	r31, 0xFE	; 254
     814:	01 90       	ld	r0, Z+
     816:	f0 81       	ld	r31, Z
     818:	e0 2d       	mov	r30, r0
     81a:	09 95       	icall
     81c:	80 91 2e 01 	lds	r24, 0x012E
     820:	88 23       	and	r24, r24
     822:	11 f0       	breq	.+4      	; 0x828 <LCD_print+0x40c>
     824:	45 9a       	sbi	0x08, 5	; 8
     826:	01 c0       	rjmp	.+2      	; 0x82a <LCD_print+0x40e>
     828:	45 98       	cbi	0x08, 5	; 8
     82a:	80 91 32 01 	lds	r24, 0x0132
     82e:	88 23       	and	r24, r24
     830:	11 f0       	breq	.+4      	; 0x836 <LCD_print+0x41a>
     832:	44 9a       	sbi	0x08, 4	; 8
     834:	01 c0       	rjmp	.+2      	; 0x838 <LCD_print+0x41c>
     836:	44 98       	cbi	0x08, 4	; 8
	LoadSEGs[c1](); if (Segments[0][2]) {SEG26_ON} else {SEG26_OFF} if (Segments[1][2]) {SEG25_ON} else {SEG25_OFF} 
     838:	f5 01       	movw	r30, r10
     83a:	ee 0f       	add	r30, r30
     83c:	ff 1f       	adc	r31, r31
     83e:	ef 5e       	subi	r30, 0xEF	; 239
     840:	fe 4f       	sbci	r31, 0xFE	; 254
     842:	01 90       	ld	r0, Z+
     844:	f0 81       	ld	r31, Z
     846:	e0 2d       	mov	r30, r0
     848:	09 95       	icall
     84a:	80 91 2e 01 	lds	r24, 0x012E
     84e:	88 23       	and	r24, r24
     850:	11 f0       	breq	.+4      	; 0x856 <LCD_print+0x43a>
     852:	5c 9a       	sbi	0x0b, 4	; 11
     854:	01 c0       	rjmp	.+2      	; 0x858 <LCD_print+0x43c>
     856:	5c 98       	cbi	0x0b, 4	; 11
     858:	80 91 32 01 	lds	r24, 0x0132
     85c:	88 23       	and	r24, r24
     85e:	11 f0       	breq	.+4      	; 0x864 <LCD_print+0x448>
     860:	5d 9a       	sbi	0x0b, 5	; 11
     862:	01 c0       	rjmp	.+2      	; 0x866 <LCD_print+0x44a>
     864:	5d 98       	cbi	0x0b, 5	; 11
	LoadSEGs[c2](); if (Segments[0][2]) {SEG24_ON} else {SEG24_OFF} if (Segments[1][2]) {SEG23_ON} else {SEG23_OFF} 
     866:	f6 01       	movw	r30, r12
     868:	ee 0f       	add	r30, r30
     86a:	ff 1f       	adc	r31, r31
     86c:	ef 5e       	subi	r30, 0xEF	; 239
     86e:	fe 4f       	sbci	r31, 0xFE	; 254
     870:	01 90       	ld	r0, Z+
     872:	f0 81       	ld	r31, Z
     874:	e0 2d       	mov	r30, r0
     876:	09 95       	icall
     878:	80 91 2e 01 	lds	r24, 0x012E
     87c:	88 23       	and	r24, r24
     87e:	11 f0       	breq	.+4      	; 0x884 <LCD_print+0x468>
     880:	5e 9a       	sbi	0x0b, 6	; 11
     882:	01 c0       	rjmp	.+2      	; 0x886 <LCD_print+0x46a>
     884:	5e 98       	cbi	0x0b, 6	; 11
     886:	80 91 32 01 	lds	r24, 0x0132
     88a:	88 23       	and	r24, r24
     88c:	11 f0       	breq	.+4      	; 0x892 <LCD_print+0x476>
     88e:	5f 9a       	sbi	0x0b, 7	; 11
     890:	01 c0       	rjmp	.+2      	; 0x894 <LCD_print+0x478>
     892:	5f 98       	cbi	0x0b, 7	; 11
	LoadSEGs[c3](); if (Segments[0][2]) {SEG22_ON} else {SEG22_OFF} if (Segments[1][2]) {SEG21_ON} else {SEG21_OFF}
     894:	f7 01       	movw	r30, r14
     896:	ee 0f       	add	r30, r30
     898:	ff 1f       	adc	r31, r31
     89a:	ef 5e       	subi	r30, 0xEF	; 239
     89c:	fe 4f       	sbci	r31, 0xFE	; 254
     89e:	01 90       	ld	r0, Z+
     8a0:	f0 81       	ld	r31, Z
     8a2:	e0 2d       	mov	r30, r0
     8a4:	09 95       	icall
     8a6:	80 91 2e 01 	lds	r24, 0x012E
     8aa:	88 23       	and	r24, r24
     8ac:	11 f0       	breq	.+4      	; 0x8b2 <LCD_print+0x496>
     8ae:	40 9a       	sbi	0x08, 0	; 8
     8b0:	01 c0       	rjmp	.+2      	; 0x8b4 <LCD_print+0x498>
     8b2:	40 98       	cbi	0x08, 0	; 8
     8b4:	80 91 32 01 	lds	r24, 0x0132
     8b8:	88 23       	and	r24, r24
     8ba:	11 f0       	breq	.+4      	; 0x8c0 <LCD_print+0x4a4>
     8bc:	41 9a       	sbi	0x08, 1	; 8
     8be:	01 c0       	rjmp	.+2      	; 0x8c2 <LCD_print+0x4a6>
     8c0:	41 98       	cbi	0x08, 1	; 8
	LoadSEGs[c4](); if (Segments[0][2]) {SEG20_ON} else {SEG20_OFF} if (Segments[1][2]) {SEG19_ON} else {SEG19_OFF}
     8c2:	f8 01       	movw	r30, r16
     8c4:	ee 0f       	add	r30, r30
     8c6:	ff 1f       	adc	r31, r31
     8c8:	ef 5e       	subi	r30, 0xEF	; 239
     8ca:	fe 4f       	sbci	r31, 0xFE	; 254
     8cc:	01 90       	ld	r0, Z+
     8ce:	f0 81       	ld	r31, Z
     8d0:	e0 2d       	mov	r30, r0
     8d2:	09 95       	icall
     8d4:	80 91 2e 01 	lds	r24, 0x012E
     8d8:	88 23       	and	r24, r24
     8da:	11 f0       	breq	.+4      	; 0x8e0 <LCD_print+0x4c4>
     8dc:	42 9a       	sbi	0x08, 2	; 8
     8de:	01 c0       	rjmp	.+2      	; 0x8e2 <LCD_print+0x4c6>
     8e0:	42 98       	cbi	0x08, 2	; 8
     8e2:	80 91 32 01 	lds	r24, 0x0132
     8e6:	88 23       	and	r24, r24
     8e8:	11 f0       	breq	.+4      	; 0x8ee <LCD_print+0x4d2>
     8ea:	43 9a       	sbi	0x08, 3	; 8
     8ec:	01 c0       	rjmp	.+2      	; 0x8f0 <LCD_print+0x4d4>
     8ee:	43 98       	cbi	0x08, 3	; 8
     8f0:	80 e4       	ldi	r24, 0x40	; 64
     8f2:	9f e1       	ldi	r25, 0x1F	; 31
     8f4:	01 97       	sbiw	r24, 0x01	; 1
     8f6:	f1 f7       	brne	.-4      	; 0x8f4 <LCD_print+0x4d8>
	_delay_ms(delay);
	
	COM2_1P2; COM3_GND; 
     8f8:	52 98       	cbi	0x0a, 2	; 10
     8fa:	5a 98       	cbi	0x0b, 2	; 11
     8fc:	53 9a       	sbi	0x0a, 3	; 10
     8fe:	5b 98       	cbi	0x0b, 3	; 11
	LoadSEGs[m1](); if (Segments[0][3]) {SEG1_ON} else {SEG1_OFF} if (Segments[1][3]) {SEG2_ON} else {SEG2_OFF} 
     900:	f1 01       	movw	r30, r2
     902:	ee 0f       	add	r30, r30
     904:	ff 1f       	adc	r31, r31
     906:	ef 5e       	subi	r30, 0xEF	; 239
     908:	fe 4f       	sbci	r31, 0xFE	; 254
     90a:	01 90       	ld	r0, Z+
     90c:	f0 81       	ld	r31, Z
     90e:	e0 2d       	mov	r30, r0
     910:	09 95       	icall
     912:	80 91 2f 01 	lds	r24, 0x012F
     916:	88 23       	and	r24, r24
     918:	11 f0       	breq	.+4      	; 0x91e <__stack+0x1f>
     91a:	14 9a       	sbi	0x02, 4	; 2
     91c:	01 c0       	rjmp	.+2      	; 0x920 <__stack+0x21>
     91e:	14 98       	cbi	0x02, 4	; 2
     920:	80 91 33 01 	lds	r24, 0x0133
     924:	88 23       	and	r24, r24
     926:	11 f0       	breq	.+4      	; 0x92c <__stack+0x2d>
     928:	15 9a       	sbi	0x02, 5	; 2
     92a:	01 c0       	rjmp	.+2      	; 0x92e <__stack+0x2f>
     92c:	15 98       	cbi	0x02, 5	; 2
	LoadSEGs[m2](); if (Segments[0][3]) {SEG3_ON} else {SEG3_OFF} if (Segments[1][3]) {SEG4_ON} else {SEG4_OFF} 
     92e:	f2 01       	movw	r30, r4
     930:	ee 0f       	add	r30, r30
     932:	ff 1f       	adc	r31, r31
     934:	ef 5e       	subi	r30, 0xEF	; 239
     936:	fe 4f       	sbci	r31, 0xFE	; 254
     938:	01 90       	ld	r0, Z+
     93a:	f0 81       	ld	r31, Z
     93c:	e0 2d       	mov	r30, r0
     93e:	09 95       	icall
     940:	80 91 2f 01 	lds	r24, 0x012F
     944:	88 23       	and	r24, r24
     946:	11 f0       	breq	.+4      	; 0x94c <__stack+0x4d>
     948:	16 9a       	sbi	0x02, 6	; 2
     94a:	01 c0       	rjmp	.+2      	; 0x94e <__stack+0x4f>
     94c:	16 98       	cbi	0x02, 6	; 2
     94e:	80 91 33 01 	lds	r24, 0x0133
     952:	88 23       	and	r24, r24
     954:	11 f0       	breq	.+4      	; 0x95a <__stack+0x5b>
     956:	17 9a       	sbi	0x02, 7	; 2
     958:	01 c0       	rjmp	.+2      	; 0x95c <__stack+0x5d>
     95a:	17 98       	cbi	0x02, 7	; 2
	LoadSEGs[m3](); if (Segments[0][3]) {SEG5_ON} else {SEG5_OFF} if (Segments[1][3]) {SEG6_ON} else {SEG6_OFF} 
     95c:	f3 01       	movw	r30, r6
     95e:	ee 0f       	add	r30, r30
     960:	ff 1f       	adc	r31, r31
     962:	ef 5e       	subi	r30, 0xEF	; 239
     964:	fe 4f       	sbci	r31, 0xFE	; 254
     966:	01 90       	ld	r0, Z+
     968:	f0 81       	ld	r31, Z
     96a:	e0 2d       	mov	r30, r0
     96c:	09 95       	icall
     96e:	80 91 2f 01 	lds	r24, 0x012F
     972:	88 23       	and	r24, r24
     974:	11 f0       	breq	.+4      	; 0x97a <__stack+0x7b>
     976:	47 9a       	sbi	0x08, 7	; 8
     978:	01 c0       	rjmp	.+2      	; 0x97c <__stack+0x7d>
     97a:	47 98       	cbi	0x08, 7	; 8
     97c:	80 91 33 01 	lds	r24, 0x0133
     980:	88 23       	and	r24, r24
     982:	11 f0       	breq	.+4      	; 0x988 <__stack+0x89>
     984:	46 9a       	sbi	0x08, 6	; 8
     986:	01 c0       	rjmp	.+2      	; 0x98a <__stack+0x8b>
     988:	46 98       	cbi	0x08, 6	; 8
	LoadSEGs[m4](); if (Segments[0][3]) {SEG7_ON} else {SEG7_OFF} if (Segments[1][3]) {SEG8_ON} else {SEG8_OFF} 
     98a:	f4 01       	movw	r30, r8
     98c:	ee 0f       	add	r30, r30
     98e:	ff 1f       	adc	r31, r31
     990:	ef 5e       	subi	r30, 0xEF	; 239
     992:	fe 4f       	sbci	r31, 0xFE	; 254
     994:	01 90       	ld	r0, Z+
     996:	f0 81       	ld	r31, Z
     998:	e0 2d       	mov	r30, r0
     99a:	09 95       	icall
     99c:	80 91 2f 01 	lds	r24, 0x012F
     9a0:	88 23       	and	r24, r24
     9a2:	11 f0       	breq	.+4      	; 0x9a8 <__stack+0xa9>
     9a4:	45 9a       	sbi	0x08, 5	; 8
     9a6:	01 c0       	rjmp	.+2      	; 0x9aa <__stack+0xab>
     9a8:	45 98       	cbi	0x08, 5	; 8
     9aa:	80 91 33 01 	lds	r24, 0x0133
     9ae:	88 23       	and	r24, r24
     9b0:	11 f0       	breq	.+4      	; 0x9b6 <__stack+0xb7>
     9b2:	44 9a       	sbi	0x08, 4	; 8
     9b4:	01 c0       	rjmp	.+2      	; 0x9b8 <__stack+0xb9>
     9b6:	44 98       	cbi	0x08, 4	; 8
	LoadSEGs[c1](); if (Segments[0][3]) {SEG26_ON} else {SEG26_OFF} if (Segments[1][3]) {SEG25_ON} else {SEG25_OFF} 
     9b8:	f5 01       	movw	r30, r10
     9ba:	ee 0f       	add	r30, r30
     9bc:	ff 1f       	adc	r31, r31
     9be:	ef 5e       	subi	r30, 0xEF	; 239
     9c0:	fe 4f       	sbci	r31, 0xFE	; 254
     9c2:	01 90       	ld	r0, Z+
     9c4:	f0 81       	ld	r31, Z
     9c6:	e0 2d       	mov	r30, r0
     9c8:	09 95       	icall
     9ca:	80 91 2f 01 	lds	r24, 0x012F
     9ce:	88 23       	and	r24, r24
     9d0:	11 f0       	breq	.+4      	; 0x9d6 <__stack+0xd7>
     9d2:	5c 9a       	sbi	0x0b, 4	; 11
     9d4:	01 c0       	rjmp	.+2      	; 0x9d8 <__stack+0xd9>
     9d6:	5c 98       	cbi	0x0b, 4	; 11
     9d8:	80 91 33 01 	lds	r24, 0x0133
     9dc:	88 23       	and	r24, r24
     9de:	11 f0       	breq	.+4      	; 0x9e4 <__stack+0xe5>
     9e0:	5d 9a       	sbi	0x0b, 5	; 11
     9e2:	01 c0       	rjmp	.+2      	; 0x9e6 <__stack+0xe7>
     9e4:	5d 98       	cbi	0x0b, 5	; 11
	LoadSEGs[c2](); if (Segments[0][3]) {SEG24_ON} else {SEG24_OFF} if (Segments[1][3]) {SEG23_ON} else {SEG23_OFF} 
     9e6:	f6 01       	movw	r30, r12
     9e8:	ee 0f       	add	r30, r30
     9ea:	ff 1f       	adc	r31, r31
     9ec:	ef 5e       	subi	r30, 0xEF	; 239
     9ee:	fe 4f       	sbci	r31, 0xFE	; 254
     9f0:	01 90       	ld	r0, Z+
     9f2:	f0 81       	ld	r31, Z
     9f4:	e0 2d       	mov	r30, r0
     9f6:	09 95       	icall
     9f8:	80 91 2f 01 	lds	r24, 0x012F
     9fc:	88 23       	and	r24, r24
     9fe:	11 f0       	breq	.+4      	; 0xa04 <__stack+0x105>
     a00:	5e 9a       	sbi	0x0b, 6	; 11
     a02:	01 c0       	rjmp	.+2      	; 0xa06 <__stack+0x107>
     a04:	5e 98       	cbi	0x0b, 6	; 11
     a06:	80 91 33 01 	lds	r24, 0x0133
     a0a:	88 23       	and	r24, r24
     a0c:	11 f0       	breq	.+4      	; 0xa12 <__stack+0x113>
     a0e:	5f 9a       	sbi	0x0b, 7	; 11
     a10:	01 c0       	rjmp	.+2      	; 0xa14 <__stack+0x115>
     a12:	5f 98       	cbi	0x0b, 7	; 11
	LoadSEGs[c3](); if (Segments[0][3]) {SEG22_ON} else {SEG22_OFF} if (Segments[1][3]) {SEG21_ON} else {SEG21_OFF}
     a14:	f7 01       	movw	r30, r14
     a16:	ee 0f       	add	r30, r30
     a18:	ff 1f       	adc	r31, r31
     a1a:	ef 5e       	subi	r30, 0xEF	; 239
     a1c:	fe 4f       	sbci	r31, 0xFE	; 254
     a1e:	01 90       	ld	r0, Z+
     a20:	f0 81       	ld	r31, Z
     a22:	e0 2d       	mov	r30, r0
     a24:	09 95       	icall
     a26:	80 91 2f 01 	lds	r24, 0x012F
     a2a:	88 23       	and	r24, r24
     a2c:	11 f0       	breq	.+4      	; 0xa32 <__stack+0x133>
     a2e:	40 9a       	sbi	0x08, 0	; 8
     a30:	01 c0       	rjmp	.+2      	; 0xa34 <__stack+0x135>
     a32:	40 98       	cbi	0x08, 0	; 8
     a34:	80 91 33 01 	lds	r24, 0x0133
     a38:	88 23       	and	r24, r24
     a3a:	11 f0       	breq	.+4      	; 0xa40 <__stack+0x141>
     a3c:	41 9a       	sbi	0x08, 1	; 8
     a3e:	01 c0       	rjmp	.+2      	; 0xa42 <__stack+0x143>
     a40:	41 98       	cbi	0x08, 1	; 8
	LoadSEGs[c4](); if (Segments[0][3]) {SEG20_ON} else {SEG20_OFF} if (Segments[1][3]) {SEG19_ON} else {SEG19_OFF}
     a42:	f8 01       	movw	r30, r16
     a44:	ee 0f       	add	r30, r30
     a46:	ff 1f       	adc	r31, r31
     a48:	ef 5e       	subi	r30, 0xEF	; 239
     a4a:	fe 4f       	sbci	r31, 0xFE	; 254
     a4c:	01 90       	ld	r0, Z+
     a4e:	f0 81       	ld	r31, Z
     a50:	e0 2d       	mov	r30, r0
     a52:	09 95       	icall
     a54:	80 91 2f 01 	lds	r24, 0x012F
     a58:	88 23       	and	r24, r24
     a5a:	11 f0       	breq	.+4      	; 0xa60 <__stack+0x161>
     a5c:	42 9a       	sbi	0x08, 2	; 8
     a5e:	01 c0       	rjmp	.+2      	; 0xa62 <__stack+0x163>
     a60:	42 98       	cbi	0x08, 2	; 8
     a62:	80 91 33 01 	lds	r24, 0x0133
     a66:	88 23       	and	r24, r24
     a68:	11 f0       	breq	.+4      	; 0xa6e <__stack+0x16f>
     a6a:	43 9a       	sbi	0x08, 3	; 8
     a6c:	01 c0       	rjmp	.+2      	; 0xa70 <__stack+0x171>
     a6e:	43 98       	cbi	0x08, 3	; 8
	if (overload) {OVERLOAD(); if (Segments[1][3]) {SEG8_ON} else {SEG8_OFF}}
     a70:	ab 81       	ldd	r26, Y+3	; 0x03
     a72:	aa 23       	and	r26, r26
     a74:	49 f0       	breq	.+18     	; 0xa88 <__stack+0x189>
     a76:	0e 94 2a 01 	call	0x254	; 0x254 <OVERLOAD>
     a7a:	80 91 33 01 	lds	r24, 0x0133
     a7e:	88 23       	and	r24, r24
     a80:	11 f0       	breq	.+4      	; 0xa86 <__stack+0x187>
     a82:	44 9a       	sbi	0x08, 4	; 8
     a84:	01 c0       	rjmp	.+2      	; 0xa88 <__stack+0x189>
     a86:	44 98       	cbi	0x08, 4	; 8
	decimal(); if (Segments[1][3]) {SEG4_ON; SEG23_ON} else {SEG4_OFF; SEG23_OFF}
     a88:	0e 94 3c 01 	call	0x278	; 0x278 <decimal>
     a8c:	80 91 33 01 	lds	r24, 0x0133
     a90:	88 23       	and	r24, r24
     a92:	19 f0       	breq	.+6      	; 0xa9a <__stack+0x19b>
     a94:	17 9a       	sbi	0x02, 7	; 2
     a96:	5f 9a       	sbi	0x0b, 7	; 11
     a98:	02 c0       	rjmp	.+4      	; 0xa9e <__stack+0x19f>
     a9a:	17 98       	cbi	0x02, 7	; 2
     a9c:	5f 98       	cbi	0x0b, 7	; 11
     a9e:	80 e4       	ldi	r24, 0x40	; 64
     aa0:	9f e1       	ldi	r25, 0x1F	; 31
     aa2:	01 97       	sbiw	r24, 0x01	; 1
     aa4:	f1 f7       	brne	.-4      	; 0xaa2 <__stack+0x1a3>
	_delay_ms(delay); 
	
	//negativ felperiodus
	COM3_1P2; COM0_VCC; 
     aa6:	53 98       	cbi	0x0a, 3	; 10
     aa8:	5b 98       	cbi	0x0b, 3	; 11
     aaa:	50 9a       	sbi	0x0a, 0	; 10
     aac:	58 9a       	sbi	0x0b, 0	; 11
	LoadSEGs[m1](); if (Segments[0][0]) {SEG1_OFF} else {SEG1_ON} if (Segments[1][0]) {SEG2_OFF} else {SEG2_ON}
     aae:	f1 01       	movw	r30, r2
     ab0:	ee 0f       	add	r30, r30
     ab2:	ff 1f       	adc	r31, r31
     ab4:	ef 5e       	subi	r30, 0xEF	; 239
     ab6:	fe 4f       	sbci	r31, 0xFE	; 254
     ab8:	01 90       	ld	r0, Z+
     aba:	f0 81       	ld	r31, Z
     abc:	e0 2d       	mov	r30, r0
     abe:	09 95       	icall
     ac0:	80 91 2c 01 	lds	r24, 0x012C
     ac4:	88 23       	and	r24, r24
     ac6:	11 f0       	breq	.+4      	; 0xacc <__stack+0x1cd>
     ac8:	14 98       	cbi	0x02, 4	; 2
     aca:	01 c0       	rjmp	.+2      	; 0xace <__stack+0x1cf>
     acc:	14 9a       	sbi	0x02, 4	; 2
     ace:	80 91 30 01 	lds	r24, 0x0130
     ad2:	88 23       	and	r24, r24
     ad4:	11 f0       	breq	.+4      	; 0xada <__stack+0x1db>
     ad6:	15 98       	cbi	0x02, 5	; 2
     ad8:	01 c0       	rjmp	.+2      	; 0xadc <__stack+0x1dd>
     ada:	15 9a       	sbi	0x02, 5	; 2
	LoadSEGs[m2](); if (Segments[0][0]) {SEG3_OFF} else {SEG3_ON} if (Segments[1][0]) {SEG4_OFF} else {SEG4_ON} 
     adc:	f2 01       	movw	r30, r4
     ade:	ee 0f       	add	r30, r30
     ae0:	ff 1f       	adc	r31, r31
     ae2:	ef 5e       	subi	r30, 0xEF	; 239
     ae4:	fe 4f       	sbci	r31, 0xFE	; 254
     ae6:	01 90       	ld	r0, Z+
     ae8:	f0 81       	ld	r31, Z
     aea:	e0 2d       	mov	r30, r0
     aec:	09 95       	icall
     aee:	80 91 2c 01 	lds	r24, 0x012C
     af2:	88 23       	and	r24, r24
     af4:	11 f0       	breq	.+4      	; 0xafa <__stack+0x1fb>
     af6:	16 98       	cbi	0x02, 6	; 2
     af8:	01 c0       	rjmp	.+2      	; 0xafc <__stack+0x1fd>
     afa:	16 9a       	sbi	0x02, 6	; 2
     afc:	80 91 30 01 	lds	r24, 0x0130
     b00:	88 23       	and	r24, r24
     b02:	11 f0       	breq	.+4      	; 0xb08 <__stack+0x209>
     b04:	17 98       	cbi	0x02, 7	; 2
     b06:	01 c0       	rjmp	.+2      	; 0xb0a <__stack+0x20b>
     b08:	17 9a       	sbi	0x02, 7	; 2
	LoadSEGs[m3](); if (Segments[0][0]) {SEG5_OFF} else {SEG5_ON} if (Segments[1][0]) {SEG6_OFF} else {SEG6_ON} 
     b0a:	f3 01       	movw	r30, r6
     b0c:	ee 0f       	add	r30, r30
     b0e:	ff 1f       	adc	r31, r31
     b10:	ef 5e       	subi	r30, 0xEF	; 239
     b12:	fe 4f       	sbci	r31, 0xFE	; 254
     b14:	01 90       	ld	r0, Z+
     b16:	f0 81       	ld	r31, Z
     b18:	e0 2d       	mov	r30, r0
     b1a:	09 95       	icall
     b1c:	80 91 2c 01 	lds	r24, 0x012C
     b20:	88 23       	and	r24, r24
     b22:	11 f0       	breq	.+4      	; 0xb28 <__stack+0x229>
     b24:	47 98       	cbi	0x08, 7	; 8
     b26:	01 c0       	rjmp	.+2      	; 0xb2a <__stack+0x22b>
     b28:	47 9a       	sbi	0x08, 7	; 8
     b2a:	80 91 30 01 	lds	r24, 0x0130
     b2e:	88 23       	and	r24, r24
     b30:	11 f0       	breq	.+4      	; 0xb36 <__stack+0x237>
     b32:	46 98       	cbi	0x08, 6	; 8
     b34:	01 c0       	rjmp	.+2      	; 0xb38 <__stack+0x239>
     b36:	46 9a       	sbi	0x08, 6	; 8
	LoadSEGs[m4](); if (Segments[0][0]) {SEG7_OFF} else {SEG7_ON} if (Segments[1][0]) {SEG8_OFF} else {SEG8_ON} 
     b38:	f4 01       	movw	r30, r8
     b3a:	ee 0f       	add	r30, r30
     b3c:	ff 1f       	adc	r31, r31
     b3e:	ef 5e       	subi	r30, 0xEF	; 239
     b40:	fe 4f       	sbci	r31, 0xFE	; 254
     b42:	01 90       	ld	r0, Z+
     b44:	f0 81       	ld	r31, Z
     b46:	e0 2d       	mov	r30, r0
     b48:	09 95       	icall
     b4a:	80 91 2c 01 	lds	r24, 0x012C
     b4e:	88 23       	and	r24, r24
     b50:	11 f0       	breq	.+4      	; 0xb56 <__stack+0x257>
     b52:	45 98       	cbi	0x08, 5	; 8
     b54:	01 c0       	rjmp	.+2      	; 0xb58 <__stack+0x259>
     b56:	45 9a       	sbi	0x08, 5	; 8
     b58:	80 91 30 01 	lds	r24, 0x0130
     b5c:	88 23       	and	r24, r24
     b5e:	11 f0       	breq	.+4      	; 0xb64 <__stack+0x265>
     b60:	44 98       	cbi	0x08, 4	; 8
     b62:	01 c0       	rjmp	.+2      	; 0xb66 <__stack+0x267>
     b64:	44 9a       	sbi	0x08, 4	; 8
	LoadSEGs[c1](); if (Segments[0][0]) {SEG26_OFF} else {SEG26_ON} if (Segments[1][0]) {SEG25_OFF} else {SEG25_ON} 
     b66:	f5 01       	movw	r30, r10
     b68:	ee 0f       	add	r30, r30
     b6a:	ff 1f       	adc	r31, r31
     b6c:	ef 5e       	subi	r30, 0xEF	; 239
     b6e:	fe 4f       	sbci	r31, 0xFE	; 254
     b70:	01 90       	ld	r0, Z+
     b72:	f0 81       	ld	r31, Z
     b74:	e0 2d       	mov	r30, r0
     b76:	09 95       	icall
     b78:	80 91 2c 01 	lds	r24, 0x012C
     b7c:	88 23       	and	r24, r24
     b7e:	11 f0       	breq	.+4      	; 0xb84 <__stack+0x285>
     b80:	5c 98       	cbi	0x0b, 4	; 11
     b82:	01 c0       	rjmp	.+2      	; 0xb86 <__stack+0x287>
     b84:	5c 9a       	sbi	0x0b, 4	; 11
     b86:	80 91 30 01 	lds	r24, 0x0130
     b8a:	88 23       	and	r24, r24
     b8c:	11 f0       	breq	.+4      	; 0xb92 <__stack+0x293>
     b8e:	5d 98       	cbi	0x0b, 5	; 11
     b90:	01 c0       	rjmp	.+2      	; 0xb94 <__stack+0x295>
     b92:	5d 9a       	sbi	0x0b, 5	; 11
	LoadSEGs[c2](); if (Segments[0][0]) {SEG24_OFF} else {SEG24_ON} if (Segments[1][0]) {SEG23_OFF} else {SEG23_ON} 
     b94:	f6 01       	movw	r30, r12
     b96:	ee 0f       	add	r30, r30
     b98:	ff 1f       	adc	r31, r31
     b9a:	ef 5e       	subi	r30, 0xEF	; 239
     b9c:	fe 4f       	sbci	r31, 0xFE	; 254
     b9e:	01 90       	ld	r0, Z+
     ba0:	f0 81       	ld	r31, Z
     ba2:	e0 2d       	mov	r30, r0
     ba4:	09 95       	icall
     ba6:	80 91 2c 01 	lds	r24, 0x012C
     baa:	88 23       	and	r24, r24
     bac:	11 f0       	breq	.+4      	; 0xbb2 <__stack+0x2b3>
     bae:	5e 98       	cbi	0x0b, 6	; 11
     bb0:	01 c0       	rjmp	.+2      	; 0xbb4 <__stack+0x2b5>
     bb2:	5e 9a       	sbi	0x0b, 6	; 11
     bb4:	80 91 30 01 	lds	r24, 0x0130
     bb8:	88 23       	and	r24, r24
     bba:	11 f0       	breq	.+4      	; 0xbc0 <__stack+0x2c1>
     bbc:	5f 98       	cbi	0x0b, 7	; 11
     bbe:	01 c0       	rjmp	.+2      	; 0xbc2 <__stack+0x2c3>
     bc0:	5f 9a       	sbi	0x0b, 7	; 11
	LoadSEGs[c3](); if (Segments[0][0]) {SEG22_OFF} else {SEG22_ON} if (Segments[1][0]) {SEG21_OFF} else {SEG21_ON}
     bc2:	f7 01       	movw	r30, r14
     bc4:	ee 0f       	add	r30, r30
     bc6:	ff 1f       	adc	r31, r31
     bc8:	ef 5e       	subi	r30, 0xEF	; 239
     bca:	fe 4f       	sbci	r31, 0xFE	; 254
     bcc:	01 90       	ld	r0, Z+
     bce:	f0 81       	ld	r31, Z
     bd0:	e0 2d       	mov	r30, r0
     bd2:	09 95       	icall
     bd4:	80 91 2c 01 	lds	r24, 0x012C
     bd8:	88 23       	and	r24, r24
     bda:	11 f0       	breq	.+4      	; 0xbe0 <__stack+0x2e1>
     bdc:	40 98       	cbi	0x08, 0	; 8
     bde:	01 c0       	rjmp	.+2      	; 0xbe2 <__stack+0x2e3>
     be0:	40 9a       	sbi	0x08, 0	; 8
     be2:	80 91 30 01 	lds	r24, 0x0130
     be6:	88 23       	and	r24, r24
     be8:	11 f0       	breq	.+4      	; 0xbee <__stack+0x2ef>
     bea:	41 98       	cbi	0x08, 1	; 8
     bec:	01 c0       	rjmp	.+2      	; 0xbf0 <__stack+0x2f1>
     bee:	41 9a       	sbi	0x08, 1	; 8
	LoadSEGs[c4](); if (Segments[0][0]) {SEG20_OFF} else {SEG20_ON} if (Segments[1][0]) {SEG19_OFF} else {SEG19_ON}
     bf0:	f8 01       	movw	r30, r16
     bf2:	ee 0f       	add	r30, r30
     bf4:	ff 1f       	adc	r31, r31
     bf6:	ef 5e       	subi	r30, 0xEF	; 239
     bf8:	fe 4f       	sbci	r31, 0xFE	; 254
     bfa:	01 90       	ld	r0, Z+
     bfc:	f0 81       	ld	r31, Z
     bfe:	e0 2d       	mov	r30, r0
     c00:	09 95       	icall
     c02:	80 91 2c 01 	lds	r24, 0x012C
     c06:	88 23       	and	r24, r24
     c08:	11 f0       	breq	.+4      	; 0xc0e <__stack+0x30f>
     c0a:	42 98       	cbi	0x08, 2	; 8
     c0c:	01 c0       	rjmp	.+2      	; 0xc10 <__stack+0x311>
     c0e:	42 9a       	sbi	0x08, 2	; 8
     c10:	80 91 30 01 	lds	r24, 0x0130
     c14:	88 23       	and	r24, r24
     c16:	11 f0       	breq	.+4      	; 0xc1c <__stack+0x31d>
     c18:	43 98       	cbi	0x08, 3	; 8
     c1a:	01 c0       	rjmp	.+2      	; 0xc1e <__stack+0x31f>
     c1c:	43 9a       	sbi	0x08, 3	; 8
     c1e:	80 e4       	ldi	r24, 0x40	; 64
     c20:	9f e1       	ldi	r25, 0x1F	; 31
     c22:	01 97       	sbiw	r24, 0x01	; 1
     c24:	f1 f7       	brne	.-4      	; 0xc22 <__stack+0x323>
	_delay_ms(delay);
	
	COM0_1P2; COM1_VCC; 
     c26:	50 98       	cbi	0x0a, 0	; 10
     c28:	58 98       	cbi	0x0b, 0	; 11
     c2a:	51 9a       	sbi	0x0a, 1	; 10
     c2c:	59 9a       	sbi	0x0b, 1	; 11
	LoadSEGs[m1](); if (Segments[0][1]) {SEG1_OFF} else {SEG1_ON} if (Segments[1][1]) {SEG2_OFF} else {SEG2_ON} 
     c2e:	f1 01       	movw	r30, r2
     c30:	ee 0f       	add	r30, r30
     c32:	ff 1f       	adc	r31, r31
     c34:	ef 5e       	subi	r30, 0xEF	; 239
     c36:	fe 4f       	sbci	r31, 0xFE	; 254
     c38:	01 90       	ld	r0, Z+
     c3a:	f0 81       	ld	r31, Z
     c3c:	e0 2d       	mov	r30, r0
     c3e:	09 95       	icall
     c40:	80 91 2d 01 	lds	r24, 0x012D
     c44:	88 23       	and	r24, r24
     c46:	11 f0       	breq	.+4      	; 0xc4c <__stack+0x34d>
     c48:	14 98       	cbi	0x02, 4	; 2
     c4a:	01 c0       	rjmp	.+2      	; 0xc4e <__stack+0x34f>
     c4c:	14 9a       	sbi	0x02, 4	; 2
     c4e:	80 91 31 01 	lds	r24, 0x0131
     c52:	88 23       	and	r24, r24
     c54:	11 f0       	breq	.+4      	; 0xc5a <__stack+0x35b>
     c56:	15 98       	cbi	0x02, 5	; 2
     c58:	01 c0       	rjmp	.+2      	; 0xc5c <__stack+0x35d>
     c5a:	15 9a       	sbi	0x02, 5	; 2
	LoadSEGs[m2](); if (Segments[0][1]) {SEG3_OFF} else {SEG3_ON} if (Segments[1][1]) {SEG4_OFF} else {SEG4_ON}  
     c5c:	f2 01       	movw	r30, r4
     c5e:	ee 0f       	add	r30, r30
     c60:	ff 1f       	adc	r31, r31
     c62:	ef 5e       	subi	r30, 0xEF	; 239
     c64:	fe 4f       	sbci	r31, 0xFE	; 254
     c66:	01 90       	ld	r0, Z+
     c68:	f0 81       	ld	r31, Z
     c6a:	e0 2d       	mov	r30, r0
     c6c:	09 95       	icall
     c6e:	80 91 2d 01 	lds	r24, 0x012D
     c72:	88 23       	and	r24, r24
     c74:	11 f0       	breq	.+4      	; 0xc7a <__stack+0x37b>
     c76:	16 98       	cbi	0x02, 6	; 2
     c78:	01 c0       	rjmp	.+2      	; 0xc7c <__stack+0x37d>
     c7a:	16 9a       	sbi	0x02, 6	; 2
     c7c:	80 91 31 01 	lds	r24, 0x0131
     c80:	88 23       	and	r24, r24
     c82:	11 f0       	breq	.+4      	; 0xc88 <__stack+0x389>
     c84:	17 98       	cbi	0x02, 7	; 2
     c86:	01 c0       	rjmp	.+2      	; 0xc8a <__stack+0x38b>
     c88:	17 9a       	sbi	0x02, 7	; 2
	LoadSEGs[m3](); if (Segments[0][1]) {SEG5_OFF} else {SEG5_ON} if (Segments[1][1]) {SEG6_OFF} else {SEG6_ON}  
     c8a:	f3 01       	movw	r30, r6
     c8c:	ee 0f       	add	r30, r30
     c8e:	ff 1f       	adc	r31, r31
     c90:	ef 5e       	subi	r30, 0xEF	; 239
     c92:	fe 4f       	sbci	r31, 0xFE	; 254
     c94:	01 90       	ld	r0, Z+
     c96:	f0 81       	ld	r31, Z
     c98:	e0 2d       	mov	r30, r0
     c9a:	09 95       	icall
     c9c:	80 91 2d 01 	lds	r24, 0x012D
     ca0:	88 23       	and	r24, r24
     ca2:	11 f0       	breq	.+4      	; 0xca8 <__stack+0x3a9>
     ca4:	47 98       	cbi	0x08, 7	; 8
     ca6:	01 c0       	rjmp	.+2      	; 0xcaa <__stack+0x3ab>
     ca8:	47 9a       	sbi	0x08, 7	; 8
     caa:	80 91 31 01 	lds	r24, 0x0131
     cae:	88 23       	and	r24, r24
     cb0:	11 f0       	breq	.+4      	; 0xcb6 <__stack+0x3b7>
     cb2:	46 98       	cbi	0x08, 6	; 8
     cb4:	01 c0       	rjmp	.+2      	; 0xcb8 <__stack+0x3b9>
     cb6:	46 9a       	sbi	0x08, 6	; 8
	LoadSEGs[m4](); if (Segments[0][1]) {SEG7_OFF} else {SEG7_ON} if (Segments[1][1]) {SEG8_OFF} else {SEG8_ON}  
     cb8:	f4 01       	movw	r30, r8
     cba:	ee 0f       	add	r30, r30
     cbc:	ff 1f       	adc	r31, r31
     cbe:	ef 5e       	subi	r30, 0xEF	; 239
     cc0:	fe 4f       	sbci	r31, 0xFE	; 254
     cc2:	01 90       	ld	r0, Z+
     cc4:	f0 81       	ld	r31, Z
     cc6:	e0 2d       	mov	r30, r0
     cc8:	09 95       	icall
     cca:	80 91 2d 01 	lds	r24, 0x012D
     cce:	88 23       	and	r24, r24
     cd0:	11 f0       	breq	.+4      	; 0xcd6 <__stack+0x3d7>
     cd2:	45 98       	cbi	0x08, 5	; 8
     cd4:	01 c0       	rjmp	.+2      	; 0xcd8 <__stack+0x3d9>
     cd6:	45 9a       	sbi	0x08, 5	; 8
     cd8:	80 91 31 01 	lds	r24, 0x0131
     cdc:	88 23       	and	r24, r24
     cde:	11 f0       	breq	.+4      	; 0xce4 <__stack+0x3e5>
     ce0:	44 98       	cbi	0x08, 4	; 8
     ce2:	01 c0       	rjmp	.+2      	; 0xce6 <__stack+0x3e7>
     ce4:	44 9a       	sbi	0x08, 4	; 8
	LoadSEGs[c1](); if (Segments[0][1]) {SEG26_OFF} else {SEG26_ON} if (Segments[1][1]) {SEG25_OFF} else {SEG25_ON} 
     ce6:	f5 01       	movw	r30, r10
     ce8:	ee 0f       	add	r30, r30
     cea:	ff 1f       	adc	r31, r31
     cec:	ef 5e       	subi	r30, 0xEF	; 239
     cee:	fe 4f       	sbci	r31, 0xFE	; 254
     cf0:	01 90       	ld	r0, Z+
     cf2:	f0 81       	ld	r31, Z
     cf4:	e0 2d       	mov	r30, r0
     cf6:	09 95       	icall
     cf8:	80 91 2d 01 	lds	r24, 0x012D
     cfc:	88 23       	and	r24, r24
     cfe:	11 f0       	breq	.+4      	; 0xd04 <__stack+0x405>
     d00:	5c 98       	cbi	0x0b, 4	; 11
     d02:	01 c0       	rjmp	.+2      	; 0xd06 <__stack+0x407>
     d04:	5c 9a       	sbi	0x0b, 4	; 11
     d06:	80 91 31 01 	lds	r24, 0x0131
     d0a:	88 23       	and	r24, r24
     d0c:	11 f0       	breq	.+4      	; 0xd12 <__stack+0x413>
     d0e:	5d 98       	cbi	0x0b, 5	; 11
     d10:	01 c0       	rjmp	.+2      	; 0xd14 <__stack+0x415>
     d12:	5d 9a       	sbi	0x0b, 5	; 11
	LoadSEGs[c2](); if (Segments[0][1]) {SEG24_OFF} else {SEG24_ON} if (Segments[1][1]) {SEG23_OFF} else {SEG23_ON} 
     d14:	f6 01       	movw	r30, r12
     d16:	ee 0f       	add	r30, r30
     d18:	ff 1f       	adc	r31, r31
     d1a:	ef 5e       	subi	r30, 0xEF	; 239
     d1c:	fe 4f       	sbci	r31, 0xFE	; 254
     d1e:	01 90       	ld	r0, Z+
     d20:	f0 81       	ld	r31, Z
     d22:	e0 2d       	mov	r30, r0
     d24:	09 95       	icall
     d26:	80 91 2d 01 	lds	r24, 0x012D
     d2a:	88 23       	and	r24, r24
     d2c:	11 f0       	breq	.+4      	; 0xd32 <__stack+0x433>
     d2e:	5e 98       	cbi	0x0b, 6	; 11
     d30:	01 c0       	rjmp	.+2      	; 0xd34 <__stack+0x435>
     d32:	5e 9a       	sbi	0x0b, 6	; 11
     d34:	80 91 31 01 	lds	r24, 0x0131
     d38:	88 23       	and	r24, r24
     d3a:	11 f0       	breq	.+4      	; 0xd40 <__stack+0x441>
     d3c:	5f 98       	cbi	0x0b, 7	; 11
     d3e:	01 c0       	rjmp	.+2      	; 0xd42 <__stack+0x443>
     d40:	5f 9a       	sbi	0x0b, 7	; 11
	LoadSEGs[c3](); if (Segments[0][1]) {SEG22_OFF} else {SEG22_ON} if (Segments[1][1]) {SEG21_OFF} else {SEG21_ON}
     d42:	f7 01       	movw	r30, r14
     d44:	ee 0f       	add	r30, r30
     d46:	ff 1f       	adc	r31, r31
     d48:	ef 5e       	subi	r30, 0xEF	; 239
     d4a:	fe 4f       	sbci	r31, 0xFE	; 254
     d4c:	01 90       	ld	r0, Z+
     d4e:	f0 81       	ld	r31, Z
     d50:	e0 2d       	mov	r30, r0
     d52:	09 95       	icall
     d54:	80 91 2d 01 	lds	r24, 0x012D
     d58:	88 23       	and	r24, r24
     d5a:	11 f0       	breq	.+4      	; 0xd60 <__stack+0x461>
     d5c:	40 98       	cbi	0x08, 0	; 8
     d5e:	01 c0       	rjmp	.+2      	; 0xd62 <__stack+0x463>
     d60:	40 9a       	sbi	0x08, 0	; 8
     d62:	80 91 31 01 	lds	r24, 0x0131
     d66:	88 23       	and	r24, r24
     d68:	11 f0       	breq	.+4      	; 0xd6e <__stack+0x46f>
     d6a:	41 98       	cbi	0x08, 1	; 8
     d6c:	01 c0       	rjmp	.+2      	; 0xd70 <__stack+0x471>
     d6e:	41 9a       	sbi	0x08, 1	; 8
	LoadSEGs[c4](); if (Segments[0][1]) {SEG20_OFF} else {SEG20_ON} if (Segments[1][1]) {SEG19_OFF} else {SEG19_ON}
     d70:	f8 01       	movw	r30, r16
     d72:	ee 0f       	add	r30, r30
     d74:	ff 1f       	adc	r31, r31
     d76:	ef 5e       	subi	r30, 0xEF	; 239
     d78:	fe 4f       	sbci	r31, 0xFE	; 254
     d7a:	01 90       	ld	r0, Z+
     d7c:	f0 81       	ld	r31, Z
     d7e:	e0 2d       	mov	r30, r0
     d80:	09 95       	icall
     d82:	80 91 2d 01 	lds	r24, 0x012D
     d86:	88 23       	and	r24, r24
     d88:	11 f0       	breq	.+4      	; 0xd8e <__stack+0x48f>
     d8a:	42 98       	cbi	0x08, 2	; 8
     d8c:	01 c0       	rjmp	.+2      	; 0xd90 <__stack+0x491>
     d8e:	42 9a       	sbi	0x08, 2	; 8
     d90:	80 91 31 01 	lds	r24, 0x0131
     d94:	88 23       	and	r24, r24
     d96:	11 f0       	breq	.+4      	; 0xd9c <__stack+0x49d>
     d98:	43 98       	cbi	0x08, 3	; 8
     d9a:	01 c0       	rjmp	.+2      	; 0xd9e <__stack+0x49f>
     d9c:	43 9a       	sbi	0x08, 3	; 8
     d9e:	80 e4       	ldi	r24, 0x40	; 64
     da0:	9f e1       	ldi	r25, 0x1F	; 31
     da2:	01 97       	sbiw	r24, 0x01	; 1
     da4:	f1 f7       	brne	.-4      	; 0xda2 <__stack+0x4a3>
	_delay_ms(delay);
	
	COM1_1P2; COM2_VCC; 
     da6:	51 98       	cbi	0x0a, 1	; 10
     da8:	59 98       	cbi	0x0b, 1	; 11
     daa:	52 9a       	sbi	0x0a, 2	; 10
     dac:	5a 9a       	sbi	0x0b, 2	; 11
	LoadSEGs[m1](); if (Segments[0][2]) {SEG1_OFF} else {SEG1_ON} if (Segments[1][2]) {SEG2_OFF} else {SEG2_ON} 
     dae:	f1 01       	movw	r30, r2
     db0:	ee 0f       	add	r30, r30
     db2:	ff 1f       	adc	r31, r31
     db4:	ef 5e       	subi	r30, 0xEF	; 239
     db6:	fe 4f       	sbci	r31, 0xFE	; 254
     db8:	01 90       	ld	r0, Z+
     dba:	f0 81       	ld	r31, Z
     dbc:	e0 2d       	mov	r30, r0
     dbe:	09 95       	icall
     dc0:	80 91 2e 01 	lds	r24, 0x012E
     dc4:	88 23       	and	r24, r24
     dc6:	11 f0       	breq	.+4      	; 0xdcc <__stack+0x4cd>
     dc8:	14 98       	cbi	0x02, 4	; 2
     dca:	01 c0       	rjmp	.+2      	; 0xdce <__stack+0x4cf>
     dcc:	14 9a       	sbi	0x02, 4	; 2
     dce:	80 91 32 01 	lds	r24, 0x0132
     dd2:	88 23       	and	r24, r24
     dd4:	11 f0       	breq	.+4      	; 0xdda <__stack+0x4db>
     dd6:	15 98       	cbi	0x02, 5	; 2
     dd8:	01 c0       	rjmp	.+2      	; 0xddc <__stack+0x4dd>
     dda:	15 9a       	sbi	0x02, 5	; 2
	LoadSEGs[m2](); if (Segments[0][2]) {SEG3_OFF} else {SEG3_ON} if (Segments[1][2]) {SEG4_OFF} else {SEG4_ON}  
     ddc:	f2 01       	movw	r30, r4
     dde:	ee 0f       	add	r30, r30
     de0:	ff 1f       	adc	r31, r31
     de2:	ef 5e       	subi	r30, 0xEF	; 239
     de4:	fe 4f       	sbci	r31, 0xFE	; 254
     de6:	01 90       	ld	r0, Z+
     de8:	f0 81       	ld	r31, Z
     dea:	e0 2d       	mov	r30, r0
     dec:	09 95       	icall
     dee:	80 91 2e 01 	lds	r24, 0x012E
     df2:	88 23       	and	r24, r24
     df4:	11 f0       	breq	.+4      	; 0xdfa <__stack+0x4fb>
     df6:	16 98       	cbi	0x02, 6	; 2
     df8:	01 c0       	rjmp	.+2      	; 0xdfc <__stack+0x4fd>
     dfa:	16 9a       	sbi	0x02, 6	; 2
     dfc:	80 91 32 01 	lds	r24, 0x0132
     e00:	88 23       	and	r24, r24
     e02:	11 f0       	breq	.+4      	; 0xe08 <__stack+0x509>
     e04:	17 98       	cbi	0x02, 7	; 2
     e06:	01 c0       	rjmp	.+2      	; 0xe0a <__stack+0x50b>
     e08:	17 9a       	sbi	0x02, 7	; 2
	LoadSEGs[m3](); if (Segments[0][2]) {SEG5_OFF} else {SEG5_ON} if (Segments[1][2]) {SEG6_OFF} else {SEG6_ON} 
     e0a:	f3 01       	movw	r30, r6
     e0c:	ee 0f       	add	r30, r30
     e0e:	ff 1f       	adc	r31, r31
     e10:	ef 5e       	subi	r30, 0xEF	; 239
     e12:	fe 4f       	sbci	r31, 0xFE	; 254
     e14:	01 90       	ld	r0, Z+
     e16:	f0 81       	ld	r31, Z
     e18:	e0 2d       	mov	r30, r0
     e1a:	09 95       	icall
     e1c:	80 91 2e 01 	lds	r24, 0x012E
     e20:	88 23       	and	r24, r24
     e22:	11 f0       	breq	.+4      	; 0xe28 <__stack+0x529>
     e24:	47 98       	cbi	0x08, 7	; 8
     e26:	01 c0       	rjmp	.+2      	; 0xe2a <__stack+0x52b>
     e28:	47 9a       	sbi	0x08, 7	; 8
     e2a:	80 91 32 01 	lds	r24, 0x0132
     e2e:	88 23       	and	r24, r24
     e30:	11 f0       	breq	.+4      	; 0xe36 <__stack+0x537>
     e32:	46 98       	cbi	0x08, 6	; 8
     e34:	01 c0       	rjmp	.+2      	; 0xe38 <__stack+0x539>
     e36:	46 9a       	sbi	0x08, 6	; 8
	LoadSEGs[m4](); if (Segments[0][2]) {SEG7_OFF} else {SEG7_ON} if (Segments[1][2]) {SEG8_OFF} else {SEG8_ON} 
     e38:	f4 01       	movw	r30, r8
     e3a:	ee 0f       	add	r30, r30
     e3c:	ff 1f       	adc	r31, r31
     e3e:	ef 5e       	subi	r30, 0xEF	; 239
     e40:	fe 4f       	sbci	r31, 0xFE	; 254
     e42:	01 90       	ld	r0, Z+
     e44:	f0 81       	ld	r31, Z
     e46:	e0 2d       	mov	r30, r0
     e48:	09 95       	icall
     e4a:	80 91 2e 01 	lds	r24, 0x012E
     e4e:	88 23       	and	r24, r24
     e50:	11 f0       	breq	.+4      	; 0xe56 <__stack+0x557>
     e52:	45 98       	cbi	0x08, 5	; 8
     e54:	01 c0       	rjmp	.+2      	; 0xe58 <__stack+0x559>
     e56:	45 9a       	sbi	0x08, 5	; 8
     e58:	80 91 32 01 	lds	r24, 0x0132
     e5c:	88 23       	and	r24, r24
     e5e:	11 f0       	breq	.+4      	; 0xe64 <__stack+0x565>
     e60:	44 98       	cbi	0x08, 4	; 8
     e62:	01 c0       	rjmp	.+2      	; 0xe66 <__stack+0x567>
     e64:	44 9a       	sbi	0x08, 4	; 8
	LoadSEGs[c1](); if (Segments[0][2]) {SEG26_OFF} else {SEG26_ON} if (Segments[1][2]) {SEG25_OFF} else {SEG25_ON} 
     e66:	f5 01       	movw	r30, r10
     e68:	ee 0f       	add	r30, r30
     e6a:	ff 1f       	adc	r31, r31
     e6c:	ef 5e       	subi	r30, 0xEF	; 239
     e6e:	fe 4f       	sbci	r31, 0xFE	; 254
     e70:	01 90       	ld	r0, Z+
     e72:	f0 81       	ld	r31, Z
     e74:	e0 2d       	mov	r30, r0
     e76:	09 95       	icall
     e78:	80 91 2e 01 	lds	r24, 0x012E
     e7c:	88 23       	and	r24, r24
     e7e:	11 f0       	breq	.+4      	; 0xe84 <__stack+0x585>
     e80:	5c 98       	cbi	0x0b, 4	; 11
     e82:	01 c0       	rjmp	.+2      	; 0xe86 <__stack+0x587>
     e84:	5c 9a       	sbi	0x0b, 4	; 11
     e86:	80 91 32 01 	lds	r24, 0x0132
     e8a:	88 23       	and	r24, r24
     e8c:	11 f0       	breq	.+4      	; 0xe92 <__stack+0x593>
     e8e:	5d 98       	cbi	0x0b, 5	; 11
     e90:	01 c0       	rjmp	.+2      	; 0xe94 <__stack+0x595>
     e92:	5d 9a       	sbi	0x0b, 5	; 11
	LoadSEGs[c2](); if (Segments[0][2]) {SEG24_OFF} else {SEG24_ON} if (Segments[1][2]) {SEG23_OFF} else {SEG23_ON} 
     e94:	f6 01       	movw	r30, r12
     e96:	ee 0f       	add	r30, r30
     e98:	ff 1f       	adc	r31, r31
     e9a:	ef 5e       	subi	r30, 0xEF	; 239
     e9c:	fe 4f       	sbci	r31, 0xFE	; 254
     e9e:	01 90       	ld	r0, Z+
     ea0:	f0 81       	ld	r31, Z
     ea2:	e0 2d       	mov	r30, r0
     ea4:	09 95       	icall
     ea6:	80 91 2e 01 	lds	r24, 0x012E
     eaa:	88 23       	and	r24, r24
     eac:	11 f0       	breq	.+4      	; 0xeb2 <__stack+0x5b3>
     eae:	5e 98       	cbi	0x0b, 6	; 11
     eb0:	01 c0       	rjmp	.+2      	; 0xeb4 <__stack+0x5b5>
     eb2:	5e 9a       	sbi	0x0b, 6	; 11
     eb4:	80 91 32 01 	lds	r24, 0x0132
     eb8:	88 23       	and	r24, r24
     eba:	11 f0       	breq	.+4      	; 0xec0 <__stack+0x5c1>
     ebc:	5f 98       	cbi	0x0b, 7	; 11
     ebe:	01 c0       	rjmp	.+2      	; 0xec2 <__stack+0x5c3>
     ec0:	5f 9a       	sbi	0x0b, 7	; 11
	LoadSEGs[c3](); if (Segments[0][2]) {SEG22_OFF} else {SEG22_ON} if (Segments[1][2]) {SEG21_OFF} else {SEG21_ON}
     ec2:	f7 01       	movw	r30, r14
     ec4:	ee 0f       	add	r30, r30
     ec6:	ff 1f       	adc	r31, r31
     ec8:	ef 5e       	subi	r30, 0xEF	; 239
     eca:	fe 4f       	sbci	r31, 0xFE	; 254
     ecc:	01 90       	ld	r0, Z+
     ece:	f0 81       	ld	r31, Z
     ed0:	e0 2d       	mov	r30, r0
     ed2:	09 95       	icall
     ed4:	80 91 2e 01 	lds	r24, 0x012E
     ed8:	88 23       	and	r24, r24
     eda:	11 f0       	breq	.+4      	; 0xee0 <__stack+0x5e1>
     edc:	40 98       	cbi	0x08, 0	; 8
     ede:	01 c0       	rjmp	.+2      	; 0xee2 <__stack+0x5e3>
     ee0:	40 9a       	sbi	0x08, 0	; 8
     ee2:	80 91 32 01 	lds	r24, 0x0132
     ee6:	88 23       	and	r24, r24
     ee8:	11 f0       	breq	.+4      	; 0xeee <__stack+0x5ef>
     eea:	41 98       	cbi	0x08, 1	; 8
     eec:	01 c0       	rjmp	.+2      	; 0xef0 <__stack+0x5f1>
     eee:	41 9a       	sbi	0x08, 1	; 8
	LoadSEGs[c4](); if (Segments[0][2]) {SEG20_OFF} else {SEG20_ON} if (Segments[1][2]) {SEG19_OFF} else {SEG19_ON}
     ef0:	f8 01       	movw	r30, r16
     ef2:	ee 0f       	add	r30, r30
     ef4:	ff 1f       	adc	r31, r31
     ef6:	ef 5e       	subi	r30, 0xEF	; 239
     ef8:	fe 4f       	sbci	r31, 0xFE	; 254
     efa:	01 90       	ld	r0, Z+
     efc:	f0 81       	ld	r31, Z
     efe:	e0 2d       	mov	r30, r0
     f00:	09 95       	icall
     f02:	80 91 2e 01 	lds	r24, 0x012E
     f06:	88 23       	and	r24, r24
     f08:	11 f0       	breq	.+4      	; 0xf0e <__stack+0x60f>
     f0a:	42 98       	cbi	0x08, 2	; 8
     f0c:	01 c0       	rjmp	.+2      	; 0xf10 <__stack+0x611>
     f0e:	42 9a       	sbi	0x08, 2	; 8
     f10:	80 91 32 01 	lds	r24, 0x0132
     f14:	88 23       	and	r24, r24
     f16:	11 f0       	breq	.+4      	; 0xf1c <__stack+0x61d>
     f18:	43 98       	cbi	0x08, 3	; 8
     f1a:	01 c0       	rjmp	.+2      	; 0xf1e <__stack+0x61f>
     f1c:	43 9a       	sbi	0x08, 3	; 8
     f1e:	80 e4       	ldi	r24, 0x40	; 64
     f20:	9f e1       	ldi	r25, 0x1F	; 31
     f22:	01 97       	sbiw	r24, 0x01	; 1
     f24:	f1 f7       	brne	.-4      	; 0xf22 <__stack+0x623>
	_delay_ms(delay);
	
	COM2_1P2; COM3_VCC; 
     f26:	52 98       	cbi	0x0a, 2	; 10
     f28:	5a 98       	cbi	0x0b, 2	; 11
     f2a:	53 9a       	sbi	0x0a, 3	; 10
     f2c:	5b 9a       	sbi	0x0b, 3	; 11
	LoadSEGs[m1](); if (Segments[0][3]) {SEG1_OFF} else {SEG1_ON} if (Segments[1][3]) {SEG2_OFF} else {SEG2_ON} 
     f2e:	22 0c       	add	r2, r2
     f30:	33 1c       	adc	r3, r3
     f32:	81 e1       	ldi	r24, 0x11	; 17
     f34:	91 e0       	ldi	r25, 0x01	; 1
     f36:	28 0e       	add	r2, r24
     f38:	39 1e       	adc	r3, r25
     f3a:	d1 01       	movw	r26, r2
     f3c:	ed 91       	ld	r30, X+
     f3e:	fc 91       	ld	r31, X
     f40:	09 95       	icall
     f42:	80 91 2f 01 	lds	r24, 0x012F
     f46:	88 23       	and	r24, r24
     f48:	11 f0       	breq	.+4      	; 0xf4e <__stack+0x64f>
     f4a:	14 98       	cbi	0x02, 4	; 2
     f4c:	01 c0       	rjmp	.+2      	; 0xf50 <__stack+0x651>
     f4e:	14 9a       	sbi	0x02, 4	; 2
     f50:	80 91 33 01 	lds	r24, 0x0133
     f54:	88 23       	and	r24, r24
     f56:	11 f0       	breq	.+4      	; 0xf5c <__stack+0x65d>
     f58:	15 98       	cbi	0x02, 5	; 2
     f5a:	01 c0       	rjmp	.+2      	; 0xf5e <__stack+0x65f>
     f5c:	15 9a       	sbi	0x02, 5	; 2
	LoadSEGs[m2](); if (Segments[0][3]) {SEG3_OFF} else {SEG3_ON} if (Segments[1][3]) {SEG4_OFF} else {SEG4_ON}   
     f5e:	44 0c       	add	r4, r4
     f60:	55 1c       	adc	r5, r5
     f62:	81 e1       	ldi	r24, 0x11	; 17
     f64:	91 e0       	ldi	r25, 0x01	; 1
     f66:	48 0e       	add	r4, r24
     f68:	59 1e       	adc	r5, r25
     f6a:	d2 01       	movw	r26, r4
     f6c:	ed 91       	ld	r30, X+
     f6e:	fc 91       	ld	r31, X
     f70:	09 95       	icall
     f72:	80 91 2f 01 	lds	r24, 0x012F
     f76:	88 23       	and	r24, r24
     f78:	11 f0       	breq	.+4      	; 0xf7e <__stack+0x67f>
     f7a:	16 98       	cbi	0x02, 6	; 2
     f7c:	01 c0       	rjmp	.+2      	; 0xf80 <__stack+0x681>
     f7e:	16 9a       	sbi	0x02, 6	; 2
     f80:	80 91 33 01 	lds	r24, 0x0133
     f84:	88 23       	and	r24, r24
     f86:	11 f0       	breq	.+4      	; 0xf8c <__stack+0x68d>
     f88:	17 98       	cbi	0x02, 7	; 2
     f8a:	01 c0       	rjmp	.+2      	; 0xf8e <__stack+0x68f>
     f8c:	17 9a       	sbi	0x02, 7	; 2
	LoadSEGs[m3](); if (Segments[0][3]) {SEG5_OFF} else {SEG5_ON} if (Segments[1][3]) {SEG6_OFF} else {SEG6_ON} 
     f8e:	66 0c       	add	r6, r6
     f90:	77 1c       	adc	r7, r7
     f92:	81 e1       	ldi	r24, 0x11	; 17
     f94:	91 e0       	ldi	r25, 0x01	; 1
     f96:	68 0e       	add	r6, r24
     f98:	79 1e       	adc	r7, r25
     f9a:	d3 01       	movw	r26, r6
     f9c:	ed 91       	ld	r30, X+
     f9e:	fc 91       	ld	r31, X
     fa0:	09 95       	icall
     fa2:	80 91 2f 01 	lds	r24, 0x012F
     fa6:	88 23       	and	r24, r24
     fa8:	11 f0       	breq	.+4      	; 0xfae <__stack+0x6af>
     faa:	47 98       	cbi	0x08, 7	; 8
     fac:	01 c0       	rjmp	.+2      	; 0xfb0 <__stack+0x6b1>
     fae:	47 9a       	sbi	0x08, 7	; 8
     fb0:	80 91 33 01 	lds	r24, 0x0133
     fb4:	88 23       	and	r24, r24
     fb6:	11 f0       	breq	.+4      	; 0xfbc <__stack+0x6bd>
     fb8:	46 98       	cbi	0x08, 6	; 8
     fba:	01 c0       	rjmp	.+2      	; 0xfbe <__stack+0x6bf>
     fbc:	46 9a       	sbi	0x08, 6	; 8
	LoadSEGs[m4](); if (Segments[0][3]) {SEG7_OFF} else {SEG7_ON} if (Segments[1][3]) {SEG8_OFF} else {SEG8_ON} 
     fbe:	88 0c       	add	r8, r8
     fc0:	99 1c       	adc	r9, r9
     fc2:	81 e1       	ldi	r24, 0x11	; 17
     fc4:	91 e0       	ldi	r25, 0x01	; 1
     fc6:	88 0e       	add	r8, r24
     fc8:	99 1e       	adc	r9, r25
     fca:	d4 01       	movw	r26, r8
     fcc:	ed 91       	ld	r30, X+
     fce:	fc 91       	ld	r31, X
     fd0:	09 95       	icall
     fd2:	80 91 2f 01 	lds	r24, 0x012F
     fd6:	88 23       	and	r24, r24
     fd8:	11 f0       	breq	.+4      	; 0xfde <__stack+0x6df>
     fda:	45 98       	cbi	0x08, 5	; 8
     fdc:	01 c0       	rjmp	.+2      	; 0xfe0 <__stack+0x6e1>
     fde:	45 9a       	sbi	0x08, 5	; 8
     fe0:	80 91 33 01 	lds	r24, 0x0133
     fe4:	88 23       	and	r24, r24
     fe6:	11 f0       	breq	.+4      	; 0xfec <__stack+0x6ed>
     fe8:	44 98       	cbi	0x08, 4	; 8
     fea:	01 c0       	rjmp	.+2      	; 0xfee <__stack+0x6ef>
     fec:	44 9a       	sbi	0x08, 4	; 8
	LoadSEGs[c1](); if (Segments[0][3]) {SEG26_OFF} else {SEG26_ON} if (Segments[1][3]) {SEG25_OFF} else {SEG25_ON} 
     fee:	aa 0c       	add	r10, r10
     ff0:	bb 1c       	adc	r11, r11
     ff2:	81 e1       	ldi	r24, 0x11	; 17
     ff4:	91 e0       	ldi	r25, 0x01	; 1
     ff6:	a8 0e       	add	r10, r24
     ff8:	b9 1e       	adc	r11, r25
     ffa:	d5 01       	movw	r26, r10
     ffc:	ed 91       	ld	r30, X+
     ffe:	fc 91       	ld	r31, X
    1000:	09 95       	icall
    1002:	80 91 2f 01 	lds	r24, 0x012F
    1006:	88 23       	and	r24, r24
    1008:	11 f0       	breq	.+4      	; 0x100e <__stack+0x70f>
    100a:	5c 98       	cbi	0x0b, 4	; 11
    100c:	01 c0       	rjmp	.+2      	; 0x1010 <__stack+0x711>
    100e:	5c 9a       	sbi	0x0b, 4	; 11
    1010:	80 91 33 01 	lds	r24, 0x0133
    1014:	88 23       	and	r24, r24
    1016:	11 f0       	breq	.+4      	; 0x101c <__stack+0x71d>
    1018:	5d 98       	cbi	0x0b, 5	; 11
    101a:	01 c0       	rjmp	.+2      	; 0x101e <__stack+0x71f>
    101c:	5d 9a       	sbi	0x0b, 5	; 11
	LoadSEGs[c2](); if (Segments[0][3]) {SEG24_OFF} else {SEG24_ON} if (Segments[1][3]) {SEG23_OFF} else {SEG23_ON} 
    101e:	cc 0c       	add	r12, r12
    1020:	dd 1c       	adc	r13, r13
    1022:	81 e1       	ldi	r24, 0x11	; 17
    1024:	91 e0       	ldi	r25, 0x01	; 1
    1026:	c8 0e       	add	r12, r24
    1028:	d9 1e       	adc	r13, r25
    102a:	d6 01       	movw	r26, r12
    102c:	ed 91       	ld	r30, X+
    102e:	fc 91       	ld	r31, X
    1030:	09 95       	icall
    1032:	80 91 2f 01 	lds	r24, 0x012F
    1036:	88 23       	and	r24, r24
    1038:	11 f0       	breq	.+4      	; 0x103e <__stack+0x73f>
    103a:	5e 98       	cbi	0x0b, 6	; 11
    103c:	01 c0       	rjmp	.+2      	; 0x1040 <__stack+0x741>
    103e:	5e 9a       	sbi	0x0b, 6	; 11
    1040:	80 91 33 01 	lds	r24, 0x0133
    1044:	88 23       	and	r24, r24
    1046:	11 f0       	breq	.+4      	; 0x104c <__stack+0x74d>
    1048:	5f 98       	cbi	0x0b, 7	; 11
    104a:	01 c0       	rjmp	.+2      	; 0x104e <__stack+0x74f>
    104c:	5f 9a       	sbi	0x0b, 7	; 11
	LoadSEGs[c3](); if (Segments[0][3]) {SEG22_OFF} else {SEG22_ON} if (Segments[1][3]) {SEG21_OFF} else {SEG21_ON}
    104e:	ee 0c       	add	r14, r14
    1050:	ff 1c       	adc	r15, r15
    1052:	81 e1       	ldi	r24, 0x11	; 17
    1054:	91 e0       	ldi	r25, 0x01	; 1
    1056:	e8 0e       	add	r14, r24
    1058:	f9 1e       	adc	r15, r25
    105a:	d7 01       	movw	r26, r14
    105c:	ed 91       	ld	r30, X+
    105e:	fc 91       	ld	r31, X
    1060:	09 95       	icall
    1062:	80 91 2f 01 	lds	r24, 0x012F
    1066:	88 23       	and	r24, r24
    1068:	11 f0       	breq	.+4      	; 0x106e <__stack+0x76f>
    106a:	40 98       	cbi	0x08, 0	; 8
    106c:	01 c0       	rjmp	.+2      	; 0x1070 <__stack+0x771>
    106e:	40 9a       	sbi	0x08, 0	; 8
    1070:	80 91 33 01 	lds	r24, 0x0133
    1074:	88 23       	and	r24, r24
    1076:	11 f0       	breq	.+4      	; 0x107c <__stack+0x77d>
    1078:	41 98       	cbi	0x08, 1	; 8
    107a:	01 c0       	rjmp	.+2      	; 0x107e <__stack+0x77f>
    107c:	41 9a       	sbi	0x08, 1	; 8
	LoadSEGs[c4](); if (Segments[0][3]) {SEG20_OFF} else {SEG20_ON} if (Segments[1][3]) {SEG19_OFF} else {SEG19_ON}
    107e:	00 0f       	add	r16, r16
    1080:	11 1f       	adc	r17, r17
    1082:	0f 5e       	subi	r16, 0xEF	; 239
    1084:	1e 4f       	sbci	r17, 0xFE	; 254
    1086:	d8 01       	movw	r26, r16
    1088:	ed 91       	ld	r30, X+
    108a:	fc 91       	ld	r31, X
    108c:	09 95       	icall
    108e:	80 91 2f 01 	lds	r24, 0x012F
    1092:	88 23       	and	r24, r24
    1094:	11 f0       	breq	.+4      	; 0x109a <__stack+0x79b>
    1096:	42 98       	cbi	0x08, 2	; 8
    1098:	01 c0       	rjmp	.+2      	; 0x109c <__stack+0x79d>
    109a:	42 9a       	sbi	0x08, 2	; 8
    109c:	80 91 33 01 	lds	r24, 0x0133
    10a0:	88 23       	and	r24, r24
    10a2:	11 f0       	breq	.+4      	; 0x10a8 <__stack+0x7a9>
    10a4:	43 98       	cbi	0x08, 3	; 8
    10a6:	01 c0       	rjmp	.+2      	; 0x10aa <__stack+0x7ab>
    10a8:	43 9a       	sbi	0x08, 3	; 8
	if (overload) {OVERLOAD(); if (Segments[1][3]) {SEG8_OFF} else {SEG8_ON}}
    10aa:	bb 81       	ldd	r27, Y+3	; 0x03
    10ac:	bb 23       	and	r27, r27
    10ae:	49 f0       	breq	.+18     	; 0x10c2 <__stack+0x7c3>
    10b0:	0e 94 2a 01 	call	0x254	; 0x254 <OVERLOAD>
    10b4:	80 91 33 01 	lds	r24, 0x0133
    10b8:	88 23       	and	r24, r24
    10ba:	11 f0       	breq	.+4      	; 0x10c0 <__stack+0x7c1>
    10bc:	44 98       	cbi	0x08, 4	; 8
    10be:	01 c0       	rjmp	.+2      	; 0x10c2 <__stack+0x7c3>
    10c0:	44 9a       	sbi	0x08, 4	; 8
	decimal(); if (Segments[1][3]) {SEG4_OFF; SEG23_OFF} else {SEG4_ON; SEG23_ON}
    10c2:	0e 94 3c 01 	call	0x278	; 0x278 <decimal>
    10c6:	80 91 33 01 	lds	r24, 0x0133
    10ca:	88 23       	and	r24, r24
    10cc:	19 f0       	breq	.+6      	; 0x10d4 <__stack+0x7d5>
    10ce:	17 98       	cbi	0x02, 7	; 2
    10d0:	5f 98       	cbi	0x0b, 7	; 11
    10d2:	02 c0       	rjmp	.+4      	; 0x10d8 <__stack+0x7d9>
    10d4:	17 9a       	sbi	0x02, 7	; 2
    10d6:	5f 9a       	sbi	0x0b, 7	; 11
    10d8:	80 e4       	ldi	r24, 0x40	; 64
    10da:	9f e1       	ldi	r25, 0x1F	; 31
    10dc:	01 97       	sbiw	r24, 0x01	; 1
    10de:	f1 f7       	brne	.-4      	; 0x10dc <__stack+0x7dd>
	_delay_ms(delay);
}
    10e0:	0f 90       	pop	r0
    10e2:	0f 90       	pop	r0
    10e4:	0f 90       	pop	r0
    10e6:	cf 91       	pop	r28
    10e8:	df 91       	pop	r29
    10ea:	1f 91       	pop	r17
    10ec:	0f 91       	pop	r16
    10ee:	ff 90       	pop	r15
    10f0:	ef 90       	pop	r14
    10f2:	df 90       	pop	r13
    10f4:	cf 90       	pop	r12
    10f6:	bf 90       	pop	r11
    10f8:	af 90       	pop	r10
    10fa:	9f 90       	pop	r9
    10fc:	8f 90       	pop	r8
    10fe:	7f 90       	pop	r7
    1100:	6f 90       	pop	r6
    1102:	5f 90       	pop	r5
    1104:	4f 90       	pop	r4
    1106:	3f 90       	pop	r3
    1108:	2f 90       	pop	r2
    110a:	08 95       	ret

0000110c <main>:
		xSemaphoreGive(binaris);
	}
}

int main(void)
{
    110c:	ef 92       	push	r14
    110e:	ff 92       	push	r15
    1110:	0f 93       	push	r16
	initPORTs();
    1112:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <initPORTs>
	initADC();
    1116:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <initADC>
	vSemaphoreCreateBinary(binaris);
    111a:	81 e0       	ldi	r24, 0x01	; 1
    111c:	60 e0       	ldi	r22, 0x00	; 0
    111e:	43 e0       	ldi	r20, 0x03	; 3
    1120:	0e 94 01 1b 	call	0x3602	; 0x3602 <xQueueGenericCreate>
    1124:	90 93 e2 07 	sts	0x07E2, r25
    1128:	80 93 e1 07 	sts	0x07E1, r24
    112c:	00 97       	sbiw	r24, 0x00	; 0
    112e:	39 f0       	breq	.+14     	; 0x113e <main+0x32>
    1130:	60 e0       	ldi	r22, 0x00	; 0
    1132:	70 e0       	ldi	r23, 0x00	; 0
    1134:	40 e0       	ldi	r20, 0x00	; 0
    1136:	50 e0       	ldi	r21, 0x00	; 0
    1138:	20 e0       	ldi	r18, 0x00	; 0
    113a:	0e 94 35 19 	call	0x326a	; 0x326a <xQueueGenericSend>
	RELAY_ON; 
    113e:	28 9a       	sbi	0x05, 0	; 5
    1140:	88 ee       	ldi	r24, 0xE8	; 232
    1142:	93 e0       	ldi	r25, 0x03	; 3
    1144:	20 e9       	ldi	r18, 0x90	; 144
    1146:	31 e0       	ldi	r19, 0x01	; 1
    1148:	f9 01       	movw	r30, r18
    114a:	31 97       	sbiw	r30, 0x01	; 1
    114c:	f1 f7       	brne	.-4      	; 0x114a <main+0x3e>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    114e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1150:	d9 f7       	brne	.-10     	; 0x1148 <main+0x3c>
	_delay_ms(100); //A rele bekapcsolasa utani varakozas az elso meres elott
	xTaskCreate(ADC_conversion,(signed char*)"ADC",80,NULL,1,NULL);
    1152:	89 e2       	ldi	r24, 0x29	; 41
    1154:	9a e0       	ldi	r25, 0x0A	; 10
    1156:	60 e0       	ldi	r22, 0x00	; 0
    1158:	71 e0       	ldi	r23, 0x01	; 1
    115a:	40 e5       	ldi	r20, 0x50	; 80
    115c:	50 e0       	ldi	r21, 0x00	; 0
    115e:	20 e0       	ldi	r18, 0x00	; 0
    1160:	30 e0       	ldi	r19, 0x00	; 0
    1162:	01 e0       	ldi	r16, 0x01	; 1
    1164:	ee 24       	eor	r14, r14
    1166:	ff 24       	eor	r15, r15
    1168:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <xTaskCreate>
	xTaskCreate(LCD_Update,(signed char*)"LCD",80,NULL,1,NULL);
    116c:	87 e5       	ldi	r24, 0x57	; 87
    116e:	99 e0       	ldi	r25, 0x09	; 9
    1170:	64 e0       	ldi	r22, 0x04	; 4
    1172:	71 e0       	ldi	r23, 0x01	; 1
    1174:	40 e5       	ldi	r20, 0x50	; 80
    1176:	50 e0       	ldi	r21, 0x00	; 0
    1178:	20 e0       	ldi	r18, 0x00	; 0
    117a:	30 e0       	ldi	r19, 0x00	; 0
    117c:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <xTaskCreate>
	xTaskCreate(Cehck_buttons,(signed char*)"Button",80,NULL,1,NULL);
    1180:	82 ed       	ldi	r24, 0xD2	; 210
    1182:	98 e0       	ldi	r25, 0x08	; 8
    1184:	68 e0       	ldi	r22, 0x08	; 8
    1186:	71 e0       	ldi	r23, 0x01	; 1
    1188:	40 e5       	ldi	r20, 0x50	; 80
    118a:	50 e0       	ldi	r21, 0x00	; 0
    118c:	20 e0       	ldi	r18, 0x00	; 0
    118e:	30 e0       	ldi	r19, 0x00	; 0
    1190:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <xTaskCreate>
	vTaskStartScheduler();
    1194:	0e 94 6d 15 	call	0x2ada	; 0x2ada <vTaskStartScheduler>
	return 0;

}
    1198:	80 e0       	ldi	r24, 0x00	; 0
    119a:	90 e0       	ldi	r25, 0x00	; 0
    119c:	0f 91       	pop	r16
    119e:	ff 90       	pop	r15
    11a0:	ef 90       	pop	r14
    11a2:	08 95       	ret

000011a4 <Cehck_buttons>:
		LCD_print(meas1,meas2,meas3,meas4, set1,set2,set3,set4, overload);
		xSemaphoreGive(binaris);
	}
}
void Cehck_buttons()
{
    11a4:	1f 93       	push	r17
    11a6:	cf 93       	push	r28
    11a8:	df 93       	push	r29
	while(1)
	{
		xSemaphoreTake(binaris, (portTickType) 1 );
		if(meas_value > set_value) {overload=1; RELAY_OFF;}
    11aa:	11 e0       	ldi	r17, 0x01	; 1
    11ac:	c0 e9       	ldi	r28, 0x90	; 144
    11ae:	d1 e0       	ldi	r29, 0x01	; 1
}
void Cehck_buttons()
{
	while(1)
	{
		xSemaphoreTake(binaris, (portTickType) 1 );
    11b0:	80 91 e1 07 	lds	r24, 0x07E1
    11b4:	90 91 e2 07 	lds	r25, 0x07E2
    11b8:	61 e0       	ldi	r22, 0x01	; 1
    11ba:	70 e0       	ldi	r23, 0x00	; 0
    11bc:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <xQueueSemaphoreTake>
		if(meas_value > set_value) {overload=1; RELAY_OFF;}
    11c0:	40 91 40 01 	lds	r20, 0x0140
    11c4:	50 91 41 01 	lds	r21, 0x0141
    11c8:	20 91 0f 01 	lds	r18, 0x010F
    11cc:	30 91 10 01 	lds	r19, 0x0110
    11d0:	24 17       	cp	r18, r20
    11d2:	35 07       	cpc	r19, r21
    11d4:	18 f4       	brcc	.+6      	; 0x11dc <Cehck_buttons+0x38>
    11d6:	10 93 55 01 	sts	0x0155, r17
    11da:	28 98       	cbi	0x05, 0	; 5

void LCD_print(uint8_t m1, uint8_t m2, uint8_t m3, uint8_t m4, uint8_t c1, uint8_t c2, uint8_t c3, uint8_t c4, uint8_t overload); //m - measured, c - configured

uint8_t UP_pressed()
{
	if (!(PINA & (1<<UP))) //ha le van nyomva
    11dc:	02 99       	sbic	0x00, 2	; 0
    11de:	16 c0       	rjmp	.+44     	; 0x120c <Cehck_buttons+0x68>
	while(1)
	{
		xSemaphoreTake(binaris, (portTickType) 1 );
		if(meas_value > set_value) {overload=1; RELAY_OFF;}
		
		if (UP_pressed() && !button_action)
    11e0:	80 91 54 01 	lds	r24, 0x0154
    11e4:	88 23       	and	r24, r24
    11e6:	91 f4       	brne	.+36     	; 0x120c <Cehck_buttons+0x68>
		{
			button_action=1; 
    11e8:	10 93 54 01 	sts	0x0154, r17
			if (set_value<1600) {set_value++;}
    11ec:	86 e0       	ldi	r24, 0x06	; 6
    11ee:	20 34       	cpi	r18, 0x40	; 64
    11f0:	38 07       	cpc	r19, r24
    11f2:	30 f4       	brcc	.+12     	; 0x1200 <Cehck_buttons+0x5c>
    11f4:	2f 5f       	subi	r18, 0xFF	; 255
    11f6:	3f 4f       	sbci	r19, 0xFF	; 255
    11f8:	30 93 10 01 	sts	0x0110, r19
    11fc:	20 93 0f 01 	sts	0x010F, r18
	return 0;
}

void start_timer0()
{
	TCCR0B |= (1<< CS02); //CLK/256, start
    1200:	85 b5       	in	r24, 0x25	; 37
    1202:	84 60       	ori	r24, 0x04	; 4
    1204:	85 bd       	out	0x25, r24	; 37
	TIMSK0= (1<<TOIE0);  //enable overflow interrupt
    1206:	10 93 6e 00 	sts	0x006E, r17
	sei(); //set the I-bit in SREG
    120a:	78 94       	sei
	return 0; 
}

uint8_t DOWN_pressed()
{
	if (!(PINA & (1<<DOWN))) //ha le van nyomva
    120c:	01 99       	sbic	0x00, 1	; 0
    120e:	17 c0       	rjmp	.+46     	; 0x123e <Cehck_buttons+0x9a>
			button_action=1; 
			if (set_value<1600) {set_value++;}
			start_timer0();  
		}
				
		if (DOWN_pressed() && !button_action)
    1210:	80 91 54 01 	lds	r24, 0x0154
    1214:	88 23       	and	r24, r24
    1216:	99 f4       	brne	.+38     	; 0x123e <Cehck_buttons+0x9a>
		{
			button_action=1;
    1218:	10 93 54 01 	sts	0x0154, r17
			if (set_value>0) {set_value--;}
    121c:	80 91 0f 01 	lds	r24, 0x010F
    1220:	90 91 10 01 	lds	r25, 0x0110
    1224:	00 97       	sbiw	r24, 0x00	; 0
    1226:	29 f0       	breq	.+10     	; 0x1232 <Cehck_buttons+0x8e>
    1228:	01 97       	sbiw	r24, 0x01	; 1
    122a:	90 93 10 01 	sts	0x0110, r25
    122e:	80 93 0f 01 	sts	0x010F, r24
	return 0;
}

void start_timer0()
{
	TCCR0B |= (1<< CS02); //CLK/256, start
    1232:	85 b5       	in	r24, 0x25	; 37
    1234:	84 60       	ori	r24, 0x04	; 4
    1236:	85 bd       	out	0x25, r24	; 37
	TIMSK0= (1<<TOIE0);  //enable overflow interrupt
    1238:	10 93 6e 00 	sts	0x006E, r17
	sei(); //set the I-bit in SREG
    123c:	78 94       	sei
	return 0;
}

uint8_t RESET_pressed()
{
	if (!(PINA & (1<<RESET))) //ha le van nyomva
    123e:	03 99       	sbic	0x00, 3	; 0
    1240:	17 c0       	rjmp	.+46     	; 0x1270 <Cehck_buttons+0xcc>
			button_action=1;
			if (set_value>0) {set_value--;}
			start_timer0();  
		}
		
		if (RESET_pressed() && !button_action && meas_value < set_value)
    1242:	80 91 54 01 	lds	r24, 0x0154
    1246:	88 23       	and	r24, r24
    1248:	99 f4       	brne	.+38     	; 0x1270 <Cehck_buttons+0xcc>
    124a:	80 91 0f 01 	lds	r24, 0x010F
    124e:	90 91 10 01 	lds	r25, 0x0110
    1252:	48 17       	cp	r20, r24
    1254:	59 07       	cpc	r21, r25
    1256:	60 f4       	brcc	.+24     	; 0x1270 <Cehck_buttons+0xcc>
		{
			button_action=1;
    1258:	10 93 54 01 	sts	0x0154, r17
			overload=0;
    125c:	10 92 55 01 	sts	0x0155, r1
			RELAY_ON;
    1260:	28 9a       	sbi	0x05, 0	; 5
    1262:	88 ee       	ldi	r24, 0xE8	; 232
    1264:	93 e0       	ldi	r25, 0x03	; 3
    1266:	fe 01       	movw	r30, r28
    1268:	31 97       	sbiw	r30, 0x01	; 1
    126a:	f1 f7       	brne	.-4      	; 0x1268 <Cehck_buttons+0xc4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    126c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    126e:	d9 f7       	brne	.-10     	; 0x1266 <Cehck_buttons+0xc2>
	return 0; 
}

uint8_t DOWN_pressed()
{
	if (!(PINA & (1<<DOWN))) //ha le van nyomva
    1270:	01 9b       	sbis	0x00, 1	; 0
    1272:	0a c0       	rjmp	.+20     	; 0x1288 <Cehck_buttons+0xe4>
    1274:	15 c0       	rjmp	.+42     	; 0x12a0 <Cehck_buttons+0xfc>
			_delay_ms(100); //A rele bekapcsolasa utani varakozas az elso meres elott
		}
		
		if (!DOWN_pressed() && !UP_pressed() && button_action)
		{
			button_action=0;
    1276:	10 92 54 01 	sts	0x0154, r1
			overflows=0;
    127a:	10 92 3d 01 	sts	0x013D, r1
    127e:	10 92 3c 01 	sts	0x013C, r1
	sei(); //set the I-bit in SREG
}

void stop_timer0()
{
	TCCR0B &= ~(1<< CS02); //nincs orajel => az idozito megall
    1282:	85 b5       	in	r24, 0x25	; 37
    1284:	8b 7f       	andi	r24, 0xFB	; 251
    1286:	85 bd       	out	0x25, r24	; 37
			button_action=0;
			overflows=0;
			stop_timer0();
		}	
		
		xSemaphoreGive(binaris);
    1288:	80 91 e1 07 	lds	r24, 0x07E1
    128c:	90 91 e2 07 	lds	r25, 0x07E2
    1290:	60 e0       	ldi	r22, 0x00	; 0
    1292:	70 e0       	ldi	r23, 0x00	; 0
    1294:	40 e0       	ldi	r20, 0x00	; 0
    1296:	50 e0       	ldi	r21, 0x00	; 0
    1298:	20 e0       	ldi	r18, 0x00	; 0
    129a:	0e 94 35 19 	call	0x326a	; 0x326a <xQueueGenericSend>
    129e:	88 cf       	rjmp	.-240    	; 0x11b0 <Cehck_buttons+0xc>

void LCD_print(uint8_t m1, uint8_t m2, uint8_t m3, uint8_t m4, uint8_t c1, uint8_t c2, uint8_t c3, uint8_t c4, uint8_t overload); //m - measured, c - configured

uint8_t UP_pressed()
{
	if (!(PINA & (1<<UP))) //ha le van nyomva
    12a0:	02 9b       	sbis	0x00, 2	; 0
    12a2:	f2 cf       	rjmp	.-28     	; 0x1288 <Cehck_buttons+0xe4>
			overload=0;
			RELAY_ON;
			_delay_ms(100); //A rele bekapcsolasa utani varakozas az elso meres elott
		}
		
		if (!DOWN_pressed() && !UP_pressed() && button_action)
    12a4:	80 91 54 01 	lds	r24, 0x0154
    12a8:	88 23       	and	r24, r24
    12aa:	29 f7       	brne	.-54     	; 0x1276 <Cehck_buttons+0xd2>
    12ac:	ed cf       	rjmp	.-38     	; 0x1288 <Cehck_buttons+0xe4>

000012ae <LCD_Update>:
		xSemaphoreGive(binaris);
	}
}

void LCD_Update()
{
    12ae:	8f 92       	push	r8
    12b0:	af 92       	push	r10
    12b2:	cf 92       	push	r12
    12b4:	ef 92       	push	r14
    12b6:	0f 93       	push	r16
    12b8:	1f 93       	push	r17
    12ba:	cf 93       	push	r28
    12bc:	df 93       	push	r29
	while(1)
	{
		xSemaphoreTake(binaris, (portTickType) 1 );
		if(meas_value > set_value) {overload=1; RELAY_OFF;}
    12be:	11 e0       	ldi	r17, 0x01	; 1

void LCD_Update()
{
	while(1)
	{
		xSemaphoreTake(binaris, (portTickType) 1 );
    12c0:	80 91 e1 07 	lds	r24, 0x07E1
    12c4:	90 91 e2 07 	lds	r25, 0x07E2
    12c8:	61 e0       	ldi	r22, 0x01	; 1
    12ca:	70 e0       	ldi	r23, 0x00	; 0
    12cc:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <xQueueSemaphoreTake>
		if(meas_value > set_value) {overload=1; RELAY_OFF;}
    12d0:	c0 91 40 01 	lds	r28, 0x0140
    12d4:	d0 91 41 01 	lds	r29, 0x0141
    12d8:	e0 91 0f 01 	lds	r30, 0x010F
    12dc:	f0 91 10 01 	lds	r31, 0x0110
    12e0:	ec 17       	cp	r30, r28
    12e2:	fd 07       	cpc	r31, r29
    12e4:	18 f4       	brcc	.+6      	; 0x12ec <LCD_Update+0x3e>
    12e6:	10 93 55 01 	sts	0x0155, r17
    12ea:	28 98       	cbi	0x05, 0	; 5
		
		//a beallitott ertek szamjegyekre bontasa
		set4 = (set_value / 1) % 10;
    12ec:	cf 01       	movw	r24, r30
    12ee:	6a e0       	ldi	r22, 0x0A	; 10
    12f0:	70 e0       	ldi	r23, 0x00	; 0
    12f2:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    12f6:	a8 2e       	mov	r10, r24
    12f8:	80 93 eb 07 	sts	0x07EB, r24
    12fc:	90 93 ec 07 	sts	0x07EC, r25
		set3 = (set_value / 10) % 10;
    1300:	cf 01       	movw	r24, r30
    1302:	6a e0       	ldi	r22, 0x0A	; 10
    1304:	70 e0       	ldi	r23, 0x00	; 0
    1306:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    130a:	cb 01       	movw	r24, r22
    130c:	6a e0       	ldi	r22, 0x0A	; 10
    130e:	70 e0       	ldi	r23, 0x00	; 0
    1310:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    1314:	c8 2e       	mov	r12, r24
    1316:	80 93 e3 07 	sts	0x07E3, r24
    131a:	90 93 e4 07 	sts	0x07E4, r25
		set2 = (set_value / 100) % 10;
    131e:	cf 01       	movw	r24, r30
    1320:	64 e6       	ldi	r22, 0x64	; 100
    1322:	70 e0       	ldi	r23, 0x00	; 0
    1324:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    1328:	cb 01       	movw	r24, r22
    132a:	6a e0       	ldi	r22, 0x0A	; 10
    132c:	70 e0       	ldi	r23, 0x00	; 0
    132e:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    1332:	e8 2e       	mov	r14, r24
    1334:	80 93 d8 07 	sts	0x07D8, r24
    1338:	90 93 d9 07 	sts	0x07D9, r25
		set1 = (set_value / 1000) % 10;
    133c:	cf 01       	movw	r24, r30
    133e:	68 ee       	ldi	r22, 0xE8	; 232
    1340:	73 e0       	ldi	r23, 0x03	; 3
    1342:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    1346:	cb 01       	movw	r24, r22
    1348:	6a e0       	ldi	r22, 0x0A	; 10
    134a:	70 e0       	ldi	r23, 0x00	; 0
    134c:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    1350:	08 2f       	mov	r16, r24
    1352:	80 93 e9 07 	sts	0x07E9, r24
    1356:	90 93 ea 07 	sts	0x07EA, r25
		
		//szamtani kozepertek
		if(display<16){meas_avg+=meas_value;}
    135a:	20 91 3e 01 	lds	r18, 0x013E
    135e:	30 91 3f 01 	lds	r19, 0x013F
    1362:	20 31       	cpi	r18, 0x10	; 16
    1364:	31 05       	cpc	r19, r1
    1366:	08 f0       	brcs	.+2      	; 0x136a <LCD_Update+0xbc>
    1368:	56 c0       	rjmp	.+172    	; 0x1416 <LCD_Update+0x168>
    136a:	80 91 42 01 	lds	r24, 0x0142
    136e:	90 91 43 01 	lds	r25, 0x0143
    1372:	8c 0f       	add	r24, r28
    1374:	9d 1f       	adc	r25, r29
    1376:	90 93 43 01 	sts	0x0143, r25
    137a:	80 93 42 01 	sts	0x0142, r24
		if (display==15)
    137e:	2f 30       	cpi	r18, 0x0F	; 15
    1380:	31 05       	cpc	r19, r1
    1382:	09 f0       	breq	.+2      	; 0x1386 <LCD_Update+0xd8>
    1384:	48 c0       	rjmp	.+144    	; 0x1416 <LCD_Update+0x168>
		{	
			meas_avg=meas_avg>>4; //=osztva 16-tal
    1386:	9c 01       	movw	r18, r24
    1388:	44 e0       	ldi	r20, 0x04	; 4
    138a:	36 95       	lsr	r19
    138c:	27 95       	ror	r18
    138e:	4a 95       	dec	r20
    1390:	e1 f7       	brne	.-8      	; 0x138a <LCD_Update+0xdc>
    1392:	30 93 43 01 	sts	0x0143, r19
    1396:	20 93 42 01 	sts	0x0142, r18
			if(meas_avg > set_value) {overload=1; RELAY_OFF;}
    139a:	e2 17       	cp	r30, r18
    139c:	f3 07       	cpc	r31, r19
    139e:	18 f4       	brcc	.+6      	; 0x13a6 <LCD_Update+0xf8>
    13a0:	10 93 55 01 	sts	0x0155, r17
    13a4:	28 98       	cbi	0x05, 0	; 5
			//szamjegyekre bontas
			meas4 = (meas_avg / 1) % 10;
    13a6:	c9 01       	movw	r24, r18
    13a8:	6a e0       	ldi	r22, 0x0A	; 10
    13aa:	70 e0       	ldi	r23, 0x00	; 0
    13ac:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    13b0:	90 93 e6 07 	sts	0x07E6, r25
    13b4:	80 93 e5 07 	sts	0x07E5, r24
			meas3 = (meas_avg / 10) % 10;
    13b8:	c9 01       	movw	r24, r18
    13ba:	6a e0       	ldi	r22, 0x0A	; 10
    13bc:	70 e0       	ldi	r23, 0x00	; 0
    13be:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    13c2:	cb 01       	movw	r24, r22
    13c4:	6a e0       	ldi	r22, 0x0A	; 10
    13c6:	70 e0       	ldi	r23, 0x00	; 0
    13c8:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    13cc:	90 93 dc 07 	sts	0x07DC, r25
    13d0:	80 93 db 07 	sts	0x07DB, r24
			meas2 = (meas_avg / 100) % 10;
    13d4:	c9 01       	movw	r24, r18
    13d6:	64 e6       	ldi	r22, 0x64	; 100
    13d8:	70 e0       	ldi	r23, 0x00	; 0
    13da:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    13de:	cb 01       	movw	r24, r22
    13e0:	6a e0       	ldi	r22, 0x0A	; 10
    13e2:	70 e0       	ldi	r23, 0x00	; 0
    13e4:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    13e8:	90 93 de 07 	sts	0x07DE, r25
    13ec:	80 93 dd 07 	sts	0x07DD, r24
			meas1 = (meas_avg / 1000) % 10;
    13f0:	c9 01       	movw	r24, r18
    13f2:	68 ee       	ldi	r22, 0xE8	; 232
    13f4:	73 e0       	ldi	r23, 0x03	; 3
    13f6:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    13fa:	cb 01       	movw	r24, r22
    13fc:	6a e0       	ldi	r22, 0x0A	; 10
    13fe:	70 e0       	ldi	r23, 0x00	; 0
    1400:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
    1404:	90 93 e8 07 	sts	0x07E8, r25
    1408:	80 93 e7 07 	sts	0x07E7, r24
			display=0;
    140c:	10 92 3f 01 	sts	0x013F, r1
    1410:	10 92 3e 01 	sts	0x013E, r1
    1414:	06 c0       	rjmp	.+12     	; 0x1422 <LCD_Update+0x174>
		} else {display++;}
    1416:	2f 5f       	subi	r18, 0xFF	; 255
    1418:	3f 4f       	sbci	r19, 0xFF	; 255
    141a:	30 93 3f 01 	sts	0x013F, r19
    141e:	20 93 3e 01 	sts	0x013E, r18
		
		LCD_print(meas1,meas2,meas3,meas4, set1,set2,set3,set4, overload);
    1422:	80 91 e7 07 	lds	r24, 0x07E7
    1426:	60 91 dd 07 	lds	r22, 0x07DD
    142a:	40 91 db 07 	lds	r20, 0x07DB
    142e:	20 91 e5 07 	lds	r18, 0x07E5
    1432:	80 90 55 01 	lds	r8, 0x0155
    1436:	0e 94 0e 02 	call	0x41c	; 0x41c <LCD_print>
		xSemaphoreGive(binaris);
    143a:	80 91 e1 07 	lds	r24, 0x07E1
    143e:	90 91 e2 07 	lds	r25, 0x07E2
    1442:	60 e0       	ldi	r22, 0x00	; 0
    1444:	70 e0       	ldi	r23, 0x00	; 0
    1446:	40 e0       	ldi	r20, 0x00	; 0
    1448:	50 e0       	ldi	r21, 0x00	; 0
    144a:	20 e0       	ldi	r18, 0x00	; 0
    144c:	0e 94 35 19 	call	0x326a	; 0x326a <xQueueGenericSend>
    1450:	37 cf       	rjmp	.-402    	; 0x12c0 <LCD_Update+0x12>

00001452 <ADC_conversion>:
{
	ADMUX |= (1 << REFS1); //internal 2.56V
}

void ADC_conversion()
{
    1452:	df 92       	push	r13
    1454:	0f 93       	push	r16
    1456:	df 93       	push	r29
    1458:	cf 93       	push	r28
    145a:	00 d0       	rcall	.+0      	; 0x145c <ADC_conversion+0xa>
    145c:	00 d0       	rcall	.+0      	; 0x145e <ADC_conversion+0xc>
    145e:	cd b7       	in	r28, 0x3d	; 61
    1460:	de b7       	in	r29, 0x3e	; 62
			rms_voltage = sqrt(avg_voltage);	//negyzetes kozep
			rms_current = rms_voltage / Shunt;  //I=U/R
			rms_current = rms_current*CT_ratio; //mA -> A
			meas_value = rms_current*100;       //kijelzohoz valo igazitas (2 tizedes)
		}
		if(meas_value > set_value) {overload=1; RELAY_OFF;}
    1462:	dd 24       	eor	r13, r13
    1464:	d3 94       	inc	r13

void ADC_conversion()
{
	while(1)
	{
		xSemaphoreTake(binaris, (portTickType) 1 );
    1466:	80 91 e1 07 	lds	r24, 0x07E1
    146a:	90 91 e2 07 	lds	r25, 0x07E2
    146e:	61 e0       	ldi	r22, 0x01	; 1
    1470:	70 e0       	ldi	r23, 0x00	; 0
    1472:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <xQueueSemaphoreTake>
		if(i<N && converted) //N darab minta osszegzese
    1476:	00 91 56 01 	lds	r16, 0x0156
    147a:	06 39       	cpi	r16, 0x96	; 150
    147c:	08 f0       	brcs	.+2      	; 0x1480 <ADC_conversion+0x2e>
    147e:	52 c0       	rjmp	.+164    	; 0x1524 <ADC_conversion+0xd2>
    1480:	80 91 da 07 	lds	r24, 0x07DA
    1484:	88 23       	and	r24, r24
    1486:	09 f4       	brne	.+2      	; 0x148a <ADC_conversion+0x38>
    1488:	4d c0       	rjmp	.+154    	; 0x1524 <ADC_conversion+0xd2>
	converted = 1;
}

void adc_read()
{
	ADCSRA |= (1<<ADSC); //start ADC
    148a:	80 91 7a 00 	lds	r24, 0x007A
    148e:	80 64       	ori	r24, 0x40	; 64
    1490:	80 93 7a 00 	sts	0x007A, r24
	ADCSRA |= (1<<ADIE); //Enable ADC interrupt
    1494:	80 91 7a 00 	lds	r24, 0x007A
    1498:	88 60       	ori	r24, 0x08	; 8
    149a:	80 93 7a 00 	sts	0x007A, r24
	while(1)
	{
		xSemaphoreTake(binaris, (portTickType) 1 );
		if(i<N && converted) //N darab minta osszegzese
		{
			adc_read(); converted=0;			   //1 ADC minta
    149e:	10 92 da 07 	sts	0x07DA, r1
			adc_voltage = (adc_value * VCC)/1024; //minta feszultsegge alakitasa
    14a2:	60 91 df 07 	lds	r22, 0x07DF
    14a6:	70 91 e0 07 	lds	r23, 0x07E0
    14aa:	80 e0       	ldi	r24, 0x00	; 0
    14ac:	90 e0       	ldi	r25, 0x00	; 0
    14ae:	0e 94 1a 20 	call	0x4034	; 0x4034 <__floatunsisf>
    14b2:	23 e3       	ldi	r18, 0x33	; 51
    14b4:	33 e3       	ldi	r19, 0x33	; 51
    14b6:	43 e5       	ldi	r20, 0x53	; 83
    14b8:	50 e4       	ldi	r21, 0x40	; 64
    14ba:	0e 94 a8 20 	call	0x4150	; 0x4150 <__mulsf3>
    14be:	20 e0       	ldi	r18, 0x00	; 0
    14c0:	30 e0       	ldi	r19, 0x00	; 0
    14c2:	40 e8       	ldi	r20, 0x80	; 128
    14c4:	5a e3       	ldi	r21, 0x3A	; 58
    14c6:	0e 94 a8 20 	call	0x4150	; 0x4150 <__mulsf3>
    14ca:	9b 01       	movw	r18, r22
    14cc:	ac 01       	movw	r20, r24
    14ce:	60 93 50 01 	sts	0x0150, r22
    14d2:	70 93 51 01 	sts	0x0151, r23
    14d6:	80 93 52 01 	sts	0x0152, r24
    14da:	90 93 53 01 	sts	0x0153, r25
			avg_voltage += pow(adc_voltage,2);    //feszultsegek negyzetosszege
    14de:	80 91 44 01 	lds	r24, 0x0144
    14e2:	90 91 45 01 	lds	r25, 0x0145
    14e6:	a0 91 46 01 	lds	r26, 0x0146
    14ea:	b0 91 47 01 	lds	r27, 0x0147
    14ee:	89 83       	std	Y+1, r24	; 0x01
    14f0:	9a 83       	std	Y+2, r25	; 0x02
    14f2:	ab 83       	std	Y+3, r26	; 0x03
    14f4:	bc 83       	std	Y+4, r27	; 0x04
    14f6:	ca 01       	movw	r24, r20
    14f8:	b9 01       	movw	r22, r18
    14fa:	0e 94 a8 20 	call	0x4150	; 0x4150 <__mulsf3>
    14fe:	9b 01       	movw	r18, r22
    1500:	ac 01       	movw	r20, r24
    1502:	69 81       	ldd	r22, Y+1	; 0x01
    1504:	7a 81       	ldd	r23, Y+2	; 0x02
    1506:	8b 81       	ldd	r24, Y+3	; 0x03
    1508:	9c 81       	ldd	r25, Y+4	; 0x04
    150a:	0e 94 22 1f 	call	0x3e44	; 0x3e44 <__addsf3>
    150e:	60 93 44 01 	sts	0x0144, r22
    1512:	70 93 45 01 	sts	0x0145, r23
    1516:	80 93 46 01 	sts	0x0146, r24
    151a:	90 93 47 01 	sts	0x0147, r25
			i++;
    151e:	0f 5f       	subi	r16, 0xFF	; 255
    1520:	00 93 56 01 	sts	0x0156, r16
		} 
		if (i==N)
    1524:	80 91 56 01 	lds	r24, 0x0156
    1528:	86 39       	cpi	r24, 0x96	; 150
    152a:	09 f0       	breq	.+2      	; 0x152e <ADC_conversion+0xdc>
    152c:	44 c0       	rjmp	.+136    	; 0x15b6 <ADC_conversion+0x164>
		{
			i=0;
    152e:	10 92 56 01 	sts	0x0156, r1
			avg_voltage = avg_voltage/N;		//kozepertek
    1532:	60 91 44 01 	lds	r22, 0x0144
    1536:	70 91 45 01 	lds	r23, 0x0145
    153a:	80 91 46 01 	lds	r24, 0x0146
    153e:	90 91 47 01 	lds	r25, 0x0147
    1542:	20 e0       	ldi	r18, 0x00	; 0
    1544:	30 e0       	ldi	r19, 0x00	; 0
    1546:	46 e1       	ldi	r20, 0x16	; 22
    1548:	53 e4       	ldi	r21, 0x43	; 67
    154a:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <__divsf3>
    154e:	9b 01       	movw	r18, r22
    1550:	ac 01       	movw	r20, r24
    1552:	20 93 44 01 	sts	0x0144, r18
    1556:	30 93 45 01 	sts	0x0145, r19
    155a:	40 93 46 01 	sts	0x0146, r20
    155e:	50 93 47 01 	sts	0x0147, r21
			rms_voltage = sqrt(avg_voltage);	//negyzetes kozep
    1562:	0e 94 0f 21 	call	0x421e	; 0x421e <sqrt>
    1566:	60 93 48 01 	sts	0x0148, r22
    156a:	70 93 49 01 	sts	0x0149, r23
    156e:	80 93 4a 01 	sts	0x014A, r24
    1572:	90 93 4b 01 	sts	0x014B, r25
			rms_current = rms_voltage / Shunt;  //I=U/R
    1576:	20 e0       	ldi	r18, 0x00	; 0
    1578:	30 e0       	ldi	r19, 0x00	; 0
    157a:	4e e4       	ldi	r20, 0x4E	; 78
    157c:	53 e4       	ldi	r21, 0x43	; 67
    157e:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <__divsf3>
			rms_current = rms_current*CT_ratio; //mA -> A
    1582:	20 e0       	ldi	r18, 0x00	; 0
    1584:	30 e0       	ldi	r19, 0x00	; 0
    1586:	4a e7       	ldi	r20, 0x7A	; 122
    1588:	54 e4       	ldi	r21, 0x44	; 68
    158a:	0e 94 a8 20 	call	0x4150	; 0x4150 <__mulsf3>
    158e:	60 93 4c 01 	sts	0x014C, r22
    1592:	70 93 4d 01 	sts	0x014D, r23
    1596:	80 93 4e 01 	sts	0x014E, r24
    159a:	90 93 4f 01 	sts	0x014F, r25
			meas_value = rms_current*100;       //kijelzohoz valo igazitas (2 tizedes)
    159e:	20 e0       	ldi	r18, 0x00	; 0
    15a0:	30 e0       	ldi	r19, 0x00	; 0
    15a2:	48 ec       	ldi	r20, 0xC8	; 200
    15a4:	52 e4       	ldi	r21, 0x42	; 66
    15a6:	0e 94 a8 20 	call	0x4150	; 0x4150 <__mulsf3>
    15aa:	0e 94 ee 1f 	call	0x3fdc	; 0x3fdc <__fixunssfsi>
    15ae:	70 93 41 01 	sts	0x0141, r23
    15b2:	60 93 40 01 	sts	0x0140, r22
		}
		if(meas_value > set_value) {overload=1; RELAY_OFF;}
    15b6:	20 91 40 01 	lds	r18, 0x0140
    15ba:	30 91 41 01 	lds	r19, 0x0141
    15be:	80 91 0f 01 	lds	r24, 0x010F
    15c2:	90 91 10 01 	lds	r25, 0x0110
    15c6:	82 17       	cp	r24, r18
    15c8:	93 07       	cpc	r25, r19
    15ca:	18 f4       	brcc	.+6      	; 0x15d2 <ADC_conversion+0x180>
    15cc:	d0 92 55 01 	sts	0x0155, r13
    15d0:	28 98       	cbi	0x05, 0	; 5
		xSemaphoreGive(binaris);
    15d2:	80 91 e1 07 	lds	r24, 0x07E1
    15d6:	90 91 e2 07 	lds	r25, 0x07E2
    15da:	60 e0       	ldi	r22, 0x00	; 0
    15dc:	70 e0       	ldi	r23, 0x00	; 0
    15de:	40 e0       	ldi	r20, 0x00	; 0
    15e0:	50 e0       	ldi	r21, 0x00	; 0
    15e2:	20 e0       	ldi	r18, 0x00	; 0
    15e4:	0e 94 35 19 	call	0x326a	; 0x326a <xQueueGenericSend>
    15e8:	3e cf       	rjmp	.-388    	; 0x1466 <ADC_conversion+0x14>

000015ea <uxTaskPriorityGet>:
    UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
    {
        TCB_t const * pxTCB;
        UBaseType_t uxReturn;

        taskENTER_CRITICAL();
    15ea:	0f b6       	in	r0, 0x3f	; 63
    15ec:	f8 94       	cli
    15ee:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the priority of the task
             * that called uxTaskPriorityGet() that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
    15f0:	00 97       	sbiw	r24, 0x00	; 0
    15f2:	11 f0       	breq	.+4      	; 0x15f8 <uxTaskPriorityGet+0xe>
    15f4:	fc 01       	movw	r30, r24
    15f6:	04 c0       	rjmp	.+8      	; 0x1600 <uxTaskPriorityGet+0x16>
    15f8:	e0 91 57 01 	lds	r30, 0x0157
    15fc:	f0 91 58 01 	lds	r31, 0x0158
            uxReturn = pxTCB->uxPriority;
        }
        taskEXIT_CRITICAL();
    1600:	0f 90       	pop	r0
    1602:	0f be       	out	0x3f, r0	; 63

        return uxReturn;
    }
    1604:	86 89       	ldd	r24, Z+22	; 0x16
    1606:	08 95       	ret

00001608 <uxTaskPriorityGetFromISR>:

        uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
    1608:	00 97       	sbiw	r24, 0x00	; 0
    160a:	11 f0       	breq	.+4      	; 0x1610 <uxTaskPriorityGetFromISR+0x8>
    160c:	fc 01       	movw	r30, r24
    160e:	04 c0       	rjmp	.+8      	; 0x1618 <uxTaskPriorityGetFromISR+0x10>
    1610:	e0 91 57 01 	lds	r30, 0x0157
    1614:	f0 91 58 01 	lds	r31, 0x0158
            uxReturn = pxTCB->uxPriority;
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

        return uxReturn;
    }
    1618:	86 89       	ldd	r24, Z+22	; 0x16
    161a:	08 95       	ret

0000161c <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    161c:	80 91 59 01 	lds	r24, 0x0159
    1620:	8f 5f       	subi	r24, 0xFF	; 255
    1622:	80 93 59 01 	sts	0x0159, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    1626:	08 95       	ret

00001628 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    1628:	0f b6       	in	r0, 0x3f	; 63
    162a:	f8 94       	cli
    162c:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    162e:	20 91 5c 01 	lds	r18, 0x015C
    1632:	30 91 5d 01 	lds	r19, 0x015D
    }
    portTICK_TYPE_EXIT_CRITICAL();
    1636:	0f 90       	pop	r0
    1638:	0f be       	out	0x3f, r0	; 63

    return xTicks;
}
    163a:	c9 01       	movw	r24, r18
    163c:	08 95       	ret

0000163e <xTaskGetTickCountFromISR>:
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    {
        xReturn = xTickCount;
    163e:	20 91 5c 01 	lds	r18, 0x015C
    1642:	30 91 5d 01 	lds	r19, 0x015D
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    1646:	c9 01       	movw	r24, r18
    1648:	08 95       	ret

0000164a <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    164a:	80 91 63 01 	lds	r24, 0x0163
}
    164e:	08 95       	ret

00001650 <pcTaskGetName>:
{
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1650:	00 97       	sbiw	r24, 0x00	; 0
    1652:	21 f4       	brne	.+8      	; 0x165c <pcTaskGetName+0xc>
    1654:	80 91 57 01 	lds	r24, 0x0157
    1658:	90 91 58 01 	lds	r25, 0x0158
    165c:	9c 01       	movw	r18, r24
    165e:	27 5e       	subi	r18, 0xE7	; 231
    1660:	3f 4f       	sbci	r19, 0xFF	; 255
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
}
    1662:	c9 01       	movw	r24, r18
    1664:	08 95       	ret

00001666 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1666:	80 91 59 01 	lds	r24, 0x0159
    166a:	88 23       	and	r24, r24
    166c:	21 f0       	breq	.+8      	; 0x1676 <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    166e:	81 e0       	ldi	r24, 0x01	; 1
    1670:	80 93 5b 01 	sts	0x015B, r24
    1674:	08 95       	ret
    }
    else
    {
        xYieldPending = pdFALSE;
    1676:	10 92 5b 01 	sts	0x015B, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    167a:	20 91 5a 01 	lds	r18, 0x015A
    167e:	99 e0       	ldi	r25, 0x09	; 9
    1680:	01 c0       	rjmp	.+2      	; 0x1684 <vTaskSwitchContext+0x1e>
    1682:	21 50       	subi	r18, 0x01	; 1
    1684:	29 9f       	mul	r18, r25
    1686:	d0 01       	movw	r26, r0
    1688:	11 24       	eor	r1, r1
    168a:	a7 59       	subi	r26, 0x97	; 151
    168c:	be 4f       	sbci	r27, 0xFE	; 254
    168e:	8c 91       	ld	r24, X
    1690:	88 23       	and	r24, r24
    1692:	b9 f3       	breq	.-18     	; 0x1682 <vTaskSwitchContext+0x1c>
    1694:	11 96       	adiw	r26, 0x01	; 1
    1696:	ed 91       	ld	r30, X+
    1698:	fc 91       	ld	r31, X
    169a:	12 97       	sbiw	r26, 0x02	; 2
    169c:	02 80       	ldd	r0, Z+2	; 0x02
    169e:	f3 81       	ldd	r31, Z+3	; 0x03
    16a0:	e0 2d       	mov	r30, r0
    16a2:	12 96       	adiw	r26, 0x02	; 2
    16a4:	fc 93       	st	X, r31
    16a6:	ee 93       	st	-X, r30
    16a8:	11 97       	sbiw	r26, 0x01	; 1
    16aa:	cd 01       	movw	r24, r26
    16ac:	03 96       	adiw	r24, 0x03	; 3
    16ae:	e8 17       	cp	r30, r24
    16b0:	f9 07       	cpc	r31, r25
    16b2:	31 f4       	brne	.+12     	; 0x16c0 <vTaskSwitchContext+0x5a>
    16b4:	82 81       	ldd	r24, Z+2	; 0x02
    16b6:	93 81       	ldd	r25, Z+3	; 0x03
    16b8:	12 96       	adiw	r26, 0x02	; 2
    16ba:	9c 93       	st	X, r25
    16bc:	8e 93       	st	-X, r24
    16be:	11 97       	sbiw	r26, 0x01	; 1
    16c0:	11 96       	adiw	r26, 0x01	; 1
    16c2:	ed 91       	ld	r30, X+
    16c4:	fc 91       	ld	r31, X
    16c6:	12 97       	sbiw	r26, 0x02	; 2
    16c8:	86 81       	ldd	r24, Z+6	; 0x06
    16ca:	97 81       	ldd	r25, Z+7	; 0x07
    16cc:	90 93 58 01 	sts	0x0158, r25
    16d0:	80 93 57 01 	sts	0x0157, r24
    16d4:	20 93 5a 01 	sts	0x015A, r18
    16d8:	08 95       	ret

000016da <vTaskSetTimeOutState>:
    }
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    16da:	fc 01       	movw	r30, r24
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    16dc:	0f b6       	in	r0, 0x3f	; 63
    16de:	f8 94       	cli
    16e0:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    16e2:	80 91 60 01 	lds	r24, 0x0160
    16e6:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    16e8:	80 91 5c 01 	lds	r24, 0x015C
    16ec:	90 91 5d 01 	lds	r25, 0x015D
    16f0:	92 83       	std	Z+2, r25	; 0x02
    16f2:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    16f4:	0f 90       	pop	r0
    16f6:	0f be       	out	0x3f, r0	; 63
}
    16f8:	08 95       	ret

000016fa <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    16fa:	fc 01       	movw	r30, r24
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    16fc:	80 91 60 01 	lds	r24, 0x0160
    1700:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    1702:	80 91 5c 01 	lds	r24, 0x015C
    1706:	90 91 5d 01 	lds	r25, 0x015D
    170a:	92 83       	std	Z+2, r25	; 0x02
    170c:	81 83       	std	Z+1, r24	; 0x01
}
    170e:	08 95       	ret

00001710 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    1710:	dc 01       	movw	r26, r24
    1712:	fb 01       	movw	r30, r22
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    1714:	0f b6       	in	r0, 0x3f	; 63
    1716:	f8 94       	cli
    1718:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    171a:	60 91 5c 01 	lds	r22, 0x015C
    171e:	70 91 5d 01 	lds	r23, 0x015D
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1722:	11 96       	adiw	r26, 0x01	; 1
    1724:	4d 91       	ld	r20, X+
    1726:	5c 91       	ld	r21, X
    1728:	12 97       	sbiw	r26, 0x02	; 2
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
    172a:	20 81       	ld	r18, Z
    172c:	31 81       	ldd	r19, Z+1	; 0x01
    172e:	8f ef       	ldi	r24, 0xFF	; 255
    1730:	2f 3f       	cpi	r18, 0xFF	; 255
    1732:	38 07       	cpc	r19, r24
    1734:	e9 f0       	breq	.+58     	; 0x1770 <xTaskCheckForTimeOut+0x60>
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1736:	90 91 60 01 	lds	r25, 0x0160
    173a:	8c 91       	ld	r24, X
    173c:	98 17       	cp	r25, r24
    173e:	19 f0       	breq	.+6      	; 0x1746 <xTaskCheckForTimeOut+0x36>
    1740:	64 17       	cp	r22, r20
    1742:	75 07       	cpc	r23, r21
    1744:	b8 f4       	brcc	.+46     	; 0x1774 <xTaskCheckForTimeOut+0x64>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1746:	cb 01       	movw	r24, r22
    1748:	84 1b       	sub	r24, r20
    174a:	95 0b       	sbc	r25, r21
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    174c:	82 17       	cp	r24, r18
    174e:	93 07       	cpc	r25, r19
    1750:	88 f4       	brcc	.+34     	; 0x1774 <xTaskCheckForTimeOut+0x64>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    1752:	28 1b       	sub	r18, r24
    1754:	39 0b       	sbc	r19, r25
    1756:	31 83       	std	Z+1, r19	; 0x01
    1758:	20 83       	st	Z, r18
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    175a:	80 91 60 01 	lds	r24, 0x0160
    175e:	8c 93       	st	X, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    1760:	80 91 5c 01 	lds	r24, 0x015C
    1764:	90 91 5d 01 	lds	r25, 0x015D
    1768:	12 96       	adiw	r26, 0x02	; 2
    176a:	9c 93       	st	X, r25
    176c:	8e 93       	st	-X, r24
    176e:	11 97       	sbiw	r26, 0x01	; 1
    1770:	80 e0       	ldi	r24, 0x00	; 0
    1772:	03 c0       	rjmp	.+6      	; 0x177a <xTaskCheckForTimeOut+0x6a>
            vTaskInternalSetTimeOutState( pxTimeOut );
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    1774:	11 82       	std	Z+1, r1	; 0x01
    1776:	10 82       	st	Z, r1
    1778:	81 e0       	ldi	r24, 0x01	; 1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
    177a:	0f 90       	pop	r0
    177c:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    177e:	08 95       	ret

00001780 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
    1780:	81 e0       	ldi	r24, 0x01	; 1
    1782:	80 93 5b 01 	sts	0x015B, r24
}
    1786:	08 95       	ret

00001788 <xTaskGetCurrentTaskHandle>:
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    1788:	20 91 57 01 	lds	r18, 0x0157
    178c:	30 91 58 01 	lds	r19, 0x0158

        return xReturn;
    }
    1790:	c9 01       	movw	r24, r18
    1792:	08 95       	ret

00001794 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1794:	e0 91 57 01 	lds	r30, 0x0157
    1798:	f0 91 58 01 	lds	r31, 0x0158
    179c:	84 85       	ldd	r24, Z+12	; 0x0c
    179e:	95 85       	ldd	r25, Z+13	; 0x0d

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    17a0:	a0 91 57 01 	lds	r26, 0x0157
    17a4:	b0 91 58 01 	lds	r27, 0x0158
    17a8:	e0 91 57 01 	lds	r30, 0x0157
    17ac:	f0 91 58 01 	lds	r31, 0x0158
    17b0:	46 89       	ldd	r20, Z+22	; 0x16
    17b2:	24 e0       	ldi	r18, 0x04	; 4
    17b4:	30 e0       	ldi	r19, 0x00	; 0
    17b6:	24 1b       	sub	r18, r20
    17b8:	31 09       	sbc	r19, r1
    17ba:	1d 96       	adiw	r26, 0x0d	; 13
    17bc:	3c 93       	st	X, r19
    17be:	2e 93       	st	-X, r18
    17c0:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
}
    17c2:	08 95       	ret

000017c4 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    17c4:	80 91 57 01 	lds	r24, 0x0157
    17c8:	90 91 58 01 	lds	r25, 0x0158
    17cc:	89 2b       	or	r24, r25
    17ce:	39 f0       	breq	.+14     	; 0x17de <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    17d0:	e0 91 57 01 	lds	r30, 0x0157
    17d4:	f0 91 58 01 	lds	r31, 0x0158
    17d8:	82 a1       	ldd	r24, Z+34	; 0x22
    17da:	8f 5f       	subi	r24, 0xFF	; 255
    17dc:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    17de:	20 91 57 01 	lds	r18, 0x0157
    17e2:	30 91 58 01 	lds	r19, 0x0158
    }
    17e6:	c9 01       	movw	r24, r18
    17e8:	08 95       	ret

000017ea <xTaskGenericNotifyStateClear>:

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    17ea:	00 97       	sbiw	r24, 0x00	; 0
    17ec:	21 f4       	brne	.+8      	; 0x17f6 <xTaskGenericNotifyStateClear+0xc>
    17ee:	80 91 57 01 	lds	r24, 0x0157
    17f2:	90 91 58 01 	lds	r25, 0x0158

        taskENTER_CRITICAL();
    17f6:	0f b6       	in	r0, 0x3f	; 63
    17f8:	f8 94       	cli
    17fa:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    17fc:	fc 01       	movw	r30, r24
    17fe:	e6 0f       	add	r30, r22
    1800:	f1 1d       	adc	r31, r1
    1802:	87 a1       	ldd	r24, Z+39	; 0x27
    1804:	82 30       	cpi	r24, 0x02	; 2
    1806:	11 f0       	breq	.+4      	; 0x180c <xTaskGenericNotifyStateClear+0x22>
    1808:	80 e0       	ldi	r24, 0x00	; 0
    180a:	02 c0       	rjmp	.+4      	; 0x1810 <xTaskGenericNotifyStateClear+0x26>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    180c:	17 a2       	std	Z+39, r1	; 0x27
    180e:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                xReturn = pdFAIL;
            }
        }
        taskEXIT_CRITICAL();
    1810:	0f 90       	pop	r0
    1812:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    1814:	08 95       	ret

00001816 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    1816:	ef 92       	push	r14
    1818:	ff 92       	push	r15
    181a:	0f 93       	push	r16
    181c:	1f 93       	push	r17
    181e:	79 01       	movw	r14, r18
    1820:	8a 01       	movw	r16, r20
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    1822:	00 97       	sbiw	r24, 0x00	; 0
    1824:	21 f4       	brne	.+8      	; 0x182e <ulTaskGenericNotifyValueClear+0x18>
    1826:	80 91 57 01 	lds	r24, 0x0157
    182a:	90 91 58 01 	lds	r25, 0x0158

        taskENTER_CRITICAL();
    182e:	0f b6       	in	r0, 0x3f	; 63
    1830:	f8 94       	cli
    1832:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    1834:	e6 2f       	mov	r30, r22
    1836:	f0 e0       	ldi	r31, 0x00	; 0
    1838:	ee 0f       	add	r30, r30
    183a:	ff 1f       	adc	r31, r31
    183c:	ee 0f       	add	r30, r30
    183e:	ff 1f       	adc	r31, r31
    1840:	e8 0f       	add	r30, r24
    1842:	f9 1f       	adc	r31, r25
    1844:	23 a1       	ldd	r18, Z+35	; 0x23
    1846:	34 a1       	ldd	r19, Z+36	; 0x24
    1848:	45 a1       	ldd	r20, Z+37	; 0x25
    184a:	56 a1       	ldd	r21, Z+38	; 0x26
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    184c:	83 a1       	ldd	r24, Z+35	; 0x23
    184e:	94 a1       	ldd	r25, Z+36	; 0x24
    1850:	a5 a1       	ldd	r26, Z+37	; 0x25
    1852:	b6 a1       	ldd	r27, Z+38	; 0x26
    1854:	e0 94       	com	r14
    1856:	f0 94       	com	r15
    1858:	00 95       	com	r16
    185a:	10 95       	com	r17
    185c:	8e 21       	and	r24, r14
    185e:	9f 21       	and	r25, r15
    1860:	a0 23       	and	r26, r16
    1862:	b1 23       	and	r27, r17
    1864:	83 a3       	std	Z+35, r24	; 0x23
    1866:	94 a3       	std	Z+36, r25	; 0x24
    1868:	a5 a3       	std	Z+37, r26	; 0x25
    186a:	b6 a3       	std	Z+38, r27	; 0x26
        }
        taskEXIT_CRITICAL();
    186c:	0f 90       	pop	r0
    186e:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    1870:	b9 01       	movw	r22, r18
    1872:	ca 01       	movw	r24, r20
    1874:	1f 91       	pop	r17
    1876:	0f 91       	pop	r16
    1878:	ff 90       	pop	r15
    187a:	ef 90       	pop	r14
    187c:	08 95       	ret

0000187e <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    187e:	ef 92       	push	r14
    1880:	ff 92       	push	r15
    1882:	0f 93       	push	r16
    1884:	1f 93       	push	r17
    1886:	cf 93       	push	r28
    1888:	df 93       	push	r29
    188a:	ec 01       	movw	r28, r24
    188c:	e6 2f       	mov	r30, r22
    188e:	7a 01       	movw	r14, r20

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1890:	f0 e0       	ldi	r31, 0x00	; 0
    1892:	dc 01       	movw	r26, r24
    1894:	ae 0f       	add	r26, r30
    1896:	bf 1f       	adc	r27, r31
    1898:	97 96       	adiw	r26, 0x27	; 39
    189a:	2c 91       	ld	r18, X
    189c:	97 97       	sbiw	r26, 0x27	; 39
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    189e:	82 e0       	ldi	r24, 0x02	; 2
    18a0:	97 96       	adiw	r26, 0x27	; 39
    18a2:	8c 93       	st	X, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    18a4:	ee 0f       	add	r30, r30
    18a6:	ff 1f       	adc	r31, r31
    18a8:	ee 0f       	add	r30, r30
    18aa:	ff 1f       	adc	r31, r31
    18ac:	ec 0f       	add	r30, r28
    18ae:	fd 1f       	adc	r31, r29
    18b0:	83 a1       	ldd	r24, Z+35	; 0x23
    18b2:	94 a1       	ldd	r25, Z+36	; 0x24
    18b4:	a5 a1       	ldd	r26, Z+37	; 0x25
    18b6:	b6 a1       	ldd	r27, Z+38	; 0x26
    18b8:	01 96       	adiw	r24, 0x01	; 1
    18ba:	a1 1d       	adc	r26, r1
    18bc:	b1 1d       	adc	r27, r1
    18be:	83 a3       	std	Z+35, r24	; 0x23
    18c0:	94 a3       	std	Z+36, r25	; 0x24
    18c2:	a5 a3       	std	Z+37, r26	; 0x25
    18c4:	b6 a3       	std	Z+38, r27	; 0x26

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    18c6:	21 30       	cpi	r18, 0x01	; 1
    18c8:	89 f5       	brne	.+98     	; 0x192c <vTaskGenericNotifyGiveFromISR+0xae>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    18ca:	80 91 59 01 	lds	r24, 0x0159
    18ce:	88 23       	and	r24, r24
    18d0:	a9 f4       	brne	.+42     	; 0x18fc <vTaskGenericNotifyGiveFromISR+0x7e>
                {
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    18d2:	8e 01       	movw	r16, r28
    18d4:	0e 5f       	subi	r16, 0xFE	; 254
    18d6:	1f 4f       	sbci	r17, 0xFF	; 255
    18d8:	c8 01       	movw	r24, r16
    18da:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    18de:	9e 89       	ldd	r25, Y+22	; 0x16
    18e0:	80 91 5a 01 	lds	r24, 0x015A
    18e4:	89 17       	cp	r24, r25
    18e6:	10 f4       	brcc	.+4      	; 0x18ec <vTaskGenericNotifyGiveFromISR+0x6e>
    18e8:	90 93 5a 01 	sts	0x015A, r25
    18ec:	89 e0       	ldi	r24, 0x09	; 9
    18ee:	98 9f       	mul	r25, r24
    18f0:	c0 01       	movw	r24, r0
    18f2:	11 24       	eor	r1, r1
    18f4:	87 59       	subi	r24, 0x97	; 151
    18f6:	9e 4f       	sbci	r25, 0xFE	; 254
    18f8:	b8 01       	movw	r22, r16
    18fa:	05 c0       	rjmp	.+10     	; 0x1906 <vTaskGenericNotifyGiveFromISR+0x88>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    18fc:	be 01       	movw	r22, r28
    18fe:	64 5f       	subi	r22, 0xF4	; 244
    1900:	7f 4f       	sbci	r23, 0xFF	; 255
    1902:	83 ea       	ldi	r24, 0xA3	; 163
    1904:	91 e0       	ldi	r25, 0x01	; 1
    1906:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    190a:	e0 91 57 01 	lds	r30, 0x0157
    190e:	f0 91 58 01 	lds	r31, 0x0158
    1912:	9e 89       	ldd	r25, Y+22	; 0x16
    1914:	86 89       	ldd	r24, Z+22	; 0x16
    1916:	89 17       	cp	r24, r25
    1918:	48 f4       	brcc	.+18     	; 0x192c <vTaskGenericNotifyGiveFromISR+0xae>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    191a:	e1 14       	cp	r14, r1
    191c:	f1 04       	cpc	r15, r1
    191e:	19 f0       	breq	.+6      	; 0x1926 <vTaskGenericNotifyGiveFromISR+0xa8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    1920:	81 e0       	ldi	r24, 0x01	; 1
    1922:	f7 01       	movw	r30, r14
    1924:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    1926:	81 e0       	ldi	r24, 0x01	; 1
    1928:	80 93 5b 01 	sts	0x015B, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    192c:	df 91       	pop	r29
    192e:	cf 91       	pop	r28
    1930:	1f 91       	pop	r17
    1932:	0f 91       	pop	r16
    1934:	ff 90       	pop	r15
    1936:	ef 90       	pop	r14
    1938:	08 95       	ret

0000193a <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    193a:	cf 92       	push	r12
    193c:	df 92       	push	r13
    193e:	ef 92       	push	r14
    1940:	ff 92       	push	r15
    1942:	0f 93       	push	r16
    1944:	1f 93       	push	r17
    1946:	cf 93       	push	r28
    1948:	df 93       	push	r29
    194a:	ec 01       	movw	r28, r24

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( pulPreviousNotificationValue != NULL )
    194c:	e1 14       	cp	r14, r1
    194e:	f1 04       	cpc	r15, r1
    1950:	89 f0       	breq	.+34     	; 0x1974 <xTaskGenericNotifyFromISR+0x3a>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    1952:	e6 2f       	mov	r30, r22
    1954:	f0 e0       	ldi	r31, 0x00	; 0
    1956:	ee 0f       	add	r30, r30
    1958:	ff 1f       	adc	r31, r31
    195a:	ee 0f       	add	r30, r30
    195c:	ff 1f       	adc	r31, r31
    195e:	e8 0f       	add	r30, r24
    1960:	f9 1f       	adc	r31, r25
    1962:	83 a1       	ldd	r24, Z+35	; 0x23
    1964:	94 a1       	ldd	r25, Z+36	; 0x24
    1966:	a5 a1       	ldd	r26, Z+37	; 0x25
    1968:	b6 a1       	ldd	r27, Z+38	; 0x26
    196a:	f7 01       	movw	r30, r14
    196c:	80 83       	st	Z, r24
    196e:	91 83       	std	Z+1, r25	; 0x01
    1970:	a2 83       	std	Z+2, r26	; 0x02
    1972:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1974:	a6 2f       	mov	r26, r22
    1976:	b0 e0       	ldi	r27, 0x00	; 0
    1978:	fe 01       	movw	r30, r28
    197a:	ea 0f       	add	r30, r26
    197c:	fb 1f       	adc	r31, r27
    197e:	67 a1       	ldd	r22, Z+39	; 0x27
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1980:	82 e0       	ldi	r24, 0x02	; 2
    1982:	87 a3       	std	Z+39, r24	; 0x27

            switch( eAction )
    1984:	02 30       	cpi	r16, 0x02	; 2
    1986:	d1 f0       	breq	.+52     	; 0x19bc <xTaskGenericNotifyFromISR+0x82>
    1988:	03 30       	cpi	r16, 0x03	; 3
    198a:	18 f4       	brcc	.+6      	; 0x1992 <xTaskGenericNotifyFromISR+0x58>
    198c:	01 30       	cpi	r16, 0x01	; 1
    198e:	c9 f5       	brne	.+114    	; 0x1a02 <xTaskGenericNotifyFromISR+0xc8>
    1990:	05 c0       	rjmp	.+10     	; 0x199c <xTaskGenericNotifyFromISR+0x62>
    1992:	03 30       	cpi	r16, 0x03	; 3
    1994:	51 f1       	breq	.+84     	; 0x19ea <xTaskGenericNotifyFromISR+0xb0>
    1996:	04 30       	cpi	r16, 0x04	; 4
    1998:	a1 f5       	brne	.+104    	; 0x1a02 <xTaskGenericNotifyFromISR+0xc8>
    199a:	23 c0       	rjmp	.+70     	; 0x19e2 <xTaskGenericNotifyFromISR+0xa8>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    199c:	fd 01       	movw	r30, r26
    199e:	ee 0f       	add	r30, r30
    19a0:	ff 1f       	adc	r31, r31
    19a2:	ee 0f       	add	r30, r30
    19a4:	ff 1f       	adc	r31, r31
    19a6:	ec 0f       	add	r30, r28
    19a8:	fd 1f       	adc	r31, r29
    19aa:	83 a1       	ldd	r24, Z+35	; 0x23
    19ac:	94 a1       	ldd	r25, Z+36	; 0x24
    19ae:	a5 a1       	ldd	r26, Z+37	; 0x25
    19b0:	b6 a1       	ldd	r27, Z+38	; 0x26
    19b2:	82 2b       	or	r24, r18
    19b4:	93 2b       	or	r25, r19
    19b6:	a4 2b       	or	r26, r20
    19b8:	b5 2b       	or	r27, r21
    19ba:	0e c0       	rjmp	.+28     	; 0x19d8 <xTaskGenericNotifyFromISR+0x9e>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    19bc:	fd 01       	movw	r30, r26
    19be:	ee 0f       	add	r30, r30
    19c0:	ff 1f       	adc	r31, r31
    19c2:	ee 0f       	add	r30, r30
    19c4:	ff 1f       	adc	r31, r31
    19c6:	ec 0f       	add	r30, r28
    19c8:	fd 1f       	adc	r31, r29
    19ca:	83 a1       	ldd	r24, Z+35	; 0x23
    19cc:	94 a1       	ldd	r25, Z+36	; 0x24
    19ce:	a5 a1       	ldd	r26, Z+37	; 0x25
    19d0:	b6 a1       	ldd	r27, Z+38	; 0x26
    19d2:	01 96       	adiw	r24, 0x01	; 1
    19d4:	a1 1d       	adc	r26, r1
    19d6:	b1 1d       	adc	r27, r1
    19d8:	83 a3       	std	Z+35, r24	; 0x23
    19da:	94 a3       	std	Z+36, r25	; 0x24
    19dc:	a5 a3       	std	Z+37, r26	; 0x25
    19de:	b6 a3       	std	Z+38, r27	; 0x26
    19e0:	10 c0       	rjmp	.+32     	; 0x1a02 <xTaskGenericNotifyFromISR+0xc8>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    19e2:	62 30       	cpi	r22, 0x02	; 2
    19e4:	11 f4       	brne	.+4      	; 0x19ea <xTaskGenericNotifyFromISR+0xb0>
    19e6:	80 e0       	ldi	r24, 0x00	; 0
    19e8:	41 c0       	rjmp	.+130    	; 0x1a6c <xTaskGenericNotifyFromISR+0x132>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    19ea:	aa 0f       	add	r26, r26
    19ec:	bb 1f       	adc	r27, r27
    19ee:	aa 0f       	add	r26, r26
    19f0:	bb 1f       	adc	r27, r27
    19f2:	ac 0f       	add	r26, r28
    19f4:	bd 1f       	adc	r27, r29
    19f6:	93 96       	adiw	r26, 0x23	; 35
    19f8:	2d 93       	st	X+, r18
    19fa:	3d 93       	st	X+, r19
    19fc:	4d 93       	st	X+, r20
    19fe:	5c 93       	st	X, r21
    1a00:	96 97       	sbiw	r26, 0x26	; 38

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1a02:	61 30       	cpi	r22, 0x01	; 1
    1a04:	91 f5       	brne	.+100    	; 0x1a6a <xTaskGenericNotifyFromISR+0x130>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1a06:	80 91 59 01 	lds	r24, 0x0159
    1a0a:	88 23       	and	r24, r24
    1a0c:	a9 f4       	brne	.+42     	; 0x1a38 <xTaskGenericNotifyFromISR+0xfe>
                {
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1a0e:	8e 01       	movw	r16, r28
    1a10:	0e 5f       	subi	r16, 0xFE	; 254
    1a12:	1f 4f       	sbci	r17, 0xFF	; 255
    1a14:	c8 01       	movw	r24, r16
    1a16:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    1a1a:	9e 89       	ldd	r25, Y+22	; 0x16
    1a1c:	80 91 5a 01 	lds	r24, 0x015A
    1a20:	89 17       	cp	r24, r25
    1a22:	10 f4       	brcc	.+4      	; 0x1a28 <xTaskGenericNotifyFromISR+0xee>
    1a24:	90 93 5a 01 	sts	0x015A, r25
    1a28:	89 e0       	ldi	r24, 0x09	; 9
    1a2a:	98 9f       	mul	r25, r24
    1a2c:	c0 01       	movw	r24, r0
    1a2e:	11 24       	eor	r1, r1
    1a30:	87 59       	subi	r24, 0x97	; 151
    1a32:	9e 4f       	sbci	r25, 0xFE	; 254
    1a34:	b8 01       	movw	r22, r16
    1a36:	05 c0       	rjmp	.+10     	; 0x1a42 <xTaskGenericNotifyFromISR+0x108>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1a38:	be 01       	movw	r22, r28
    1a3a:	64 5f       	subi	r22, 0xF4	; 244
    1a3c:	7f 4f       	sbci	r23, 0xFF	; 255
    1a3e:	83 ea       	ldi	r24, 0xA3	; 163
    1a40:	91 e0       	ldi	r25, 0x01	; 1
    1a42:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1a46:	e0 91 57 01 	lds	r30, 0x0157
    1a4a:	f0 91 58 01 	lds	r31, 0x0158
    1a4e:	9e 89       	ldd	r25, Y+22	; 0x16
    1a50:	86 89       	ldd	r24, Z+22	; 0x16
    1a52:	89 17       	cp	r24, r25
    1a54:	50 f4       	brcc	.+20     	; 0x1a6a <xTaskGenericNotifyFromISR+0x130>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    1a56:	c1 14       	cp	r12, r1
    1a58:	d1 04       	cpc	r13, r1
    1a5a:	19 f0       	breq	.+6      	; 0x1a62 <xTaskGenericNotifyFromISR+0x128>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    1a5c:	81 e0       	ldi	r24, 0x01	; 1
    1a5e:	f6 01       	movw	r30, r12
    1a60:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    1a62:	81 e0       	ldi	r24, 0x01	; 1
    1a64:	80 93 5b 01 	sts	0x015B, r24
    1a68:	01 c0       	rjmp	.+2      	; 0x1a6c <xTaskGenericNotifyFromISR+0x132>
    1a6a:	81 e0       	ldi	r24, 0x01	; 1
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    }
    1a6c:	df 91       	pop	r29
    1a6e:	cf 91       	pop	r28
    1a70:	1f 91       	pop	r17
    1a72:	0f 91       	pop	r16
    1a74:	ff 90       	pop	r15
    1a76:	ef 90       	pop	r14
    1a78:	df 90       	pop	r13
    1a7a:	cf 90       	pop	r12
    1a7c:	08 95       	ret

00001a7e <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
    1a7e:	0f 93       	push	r16
    1a80:	1f 93       	push	r17
    1a82:	cf 93       	push	r28
    1a84:	df 93       	push	r29
    1a86:	ec 01       	movw	r28, r24
        TCB_t * const pxTCB = pxMutexHolder;
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

        if( pxMutexHolder != NULL )
    1a88:	00 97       	sbiw	r24, 0x00	; 0
    1a8a:	b1 f1       	breq	.+108    	; 0x1af8 <vTaskPriorityDisinheritAfterTimeout+0x7a>
    1a8c:	89 a1       	ldd	r24, Y+33	; 0x21
    1a8e:	68 17       	cp	r22, r24
    1a90:	08 f4       	brcc	.+2      	; 0x1a94 <vTaskPriorityDisinheritAfterTimeout+0x16>
    1a92:	68 2f       	mov	r22, r24
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
    1a94:	2e 89       	ldd	r18, Y+22	; 0x16
    1a96:	26 17       	cp	r18, r22
    1a98:	79 f1       	breq	.+94     	; 0x1af8 <vTaskPriorityDisinheritAfterTimeout+0x7a>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    1a9a:	8a a1       	ldd	r24, Y+34	; 0x22
    1a9c:	81 30       	cpi	r24, 0x01	; 1
    1a9e:	61 f5       	brne	.+88     	; 0x1af8 <vTaskPriorityDisinheritAfterTimeout+0x7a>
                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
                    pxTCB->uxPriority = uxPriorityToUse;
    1aa0:	6e 8b       	std	Y+22, r22	; 0x16

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1aa2:	8c 85       	ldd	r24, Y+12	; 0x0c
    1aa4:	9d 85       	ldd	r25, Y+13	; 0x0d
    1aa6:	97 fd       	sbrc	r25, 7
    1aa8:	06 c0       	rjmp	.+12     	; 0x1ab6 <vTaskPriorityDisinheritAfterTimeout+0x38>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1aaa:	84 e0       	ldi	r24, 0x04	; 4
    1aac:	90 e0       	ldi	r25, 0x00	; 0
    1aae:	86 1b       	sub	r24, r22
    1ab0:	91 09       	sbc	r25, r1
    1ab2:	9d 87       	std	Y+13, r25	; 0x0d
    1ab4:	8c 87       	std	Y+12, r24	; 0x0c
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    1ab6:	89 e0       	ldi	r24, 0x09	; 9
    1ab8:	28 9f       	mul	r18, r24
    1aba:	c0 01       	movw	r24, r0
    1abc:	11 24       	eor	r1, r1
    1abe:	87 59       	subi	r24, 0x97	; 151
    1ac0:	9e 4f       	sbci	r25, 0xFE	; 254
    1ac2:	2a 85       	ldd	r18, Y+10	; 0x0a
    1ac4:	3b 85       	ldd	r19, Y+11	; 0x0b
    1ac6:	28 17       	cp	r18, r24
    1ac8:	39 07       	cpc	r19, r25
    1aca:	b1 f4       	brne	.+44     	; 0x1af8 <vTaskPriorityDisinheritAfterTimeout+0x7a>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1acc:	8e 01       	movw	r16, r28
    1ace:	0e 5f       	subi	r16, 0xFE	; 254
    1ad0:	1f 4f       	sbci	r17, 0xFF	; 255
    1ad2:	c8 01       	movw	r24, r16
    1ad4:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
    1ad8:	9e 89       	ldd	r25, Y+22	; 0x16
    1ada:	80 91 5a 01 	lds	r24, 0x015A
    1ade:	89 17       	cp	r24, r25
    1ae0:	10 f4       	brcc	.+4      	; 0x1ae6 <vTaskPriorityDisinheritAfterTimeout+0x68>
    1ae2:	90 93 5a 01 	sts	0x015A, r25
    1ae6:	89 e0       	ldi	r24, 0x09	; 9
    1ae8:	98 9f       	mul	r25, r24
    1aea:	c0 01       	movw	r24, r0
    1aec:	11 24       	eor	r1, r1
    1aee:	87 59       	subi	r24, 0x97	; 151
    1af0:	9e 4f       	sbci	r25, 0xFE	; 254
    1af2:	b8 01       	movw	r22, r16
    1af4:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    1af8:	df 91       	pop	r29
    1afa:	cf 91       	pop	r28
    1afc:	1f 91       	pop	r17
    1afe:	0f 91       	pop	r16
    1b00:	08 95       	ret

00001b02 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    1b02:	0f 93       	push	r16
    1b04:	1f 93       	push	r17
    1b06:	cf 93       	push	r28
    1b08:	df 93       	push	r29
    1b0a:	ec 01       	movw	r28, r24
        TCB_t * const pxTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    1b0c:	00 97       	sbiw	r24, 0x00	; 0
    1b0e:	41 f1       	breq	.+80     	; 0x1b60 <xTaskPriorityDisinherit+0x5e>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    1b10:	2a a1       	ldd	r18, Y+34	; 0x22
    1b12:	21 50       	subi	r18, 0x01	; 1
    1b14:	2a a3       	std	Y+34, r18	; 0x22

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1b16:	9e 89       	ldd	r25, Y+22	; 0x16
    1b18:	89 a1       	ldd	r24, Y+33	; 0x21
    1b1a:	98 17       	cp	r25, r24
    1b1c:	09 f1       	breq	.+66     	; 0x1b60 <xTaskPriorityDisinherit+0x5e>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1b1e:	22 23       	and	r18, r18
    1b20:	f9 f4       	brne	.+62     	; 0x1b60 <xTaskPriorityDisinherit+0x5e>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1b22:	8e 01       	movw	r16, r28
    1b24:	0e 5f       	subi	r16, 0xFE	; 254
    1b26:	1f 4f       	sbci	r17, 0xFF	; 255
    1b28:	c8 01       	movw	r24, r16
    1b2a:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    1b2e:	29 a1       	ldd	r18, Y+33	; 0x21
    1b30:	2e 8b       	std	Y+22, r18	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1b32:	84 e0       	ldi	r24, 0x04	; 4
    1b34:	90 e0       	ldi	r25, 0x00	; 0
    1b36:	82 1b       	sub	r24, r18
    1b38:	91 09       	sbc	r25, r1
    1b3a:	9d 87       	std	Y+13, r25	; 0x0d
    1b3c:	8c 87       	std	Y+12, r24	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    1b3e:	80 91 5a 01 	lds	r24, 0x015A
    1b42:	82 17       	cp	r24, r18
    1b44:	10 f4       	brcc	.+4      	; 0x1b4a <xTaskPriorityDisinherit+0x48>
    1b46:	20 93 5a 01 	sts	0x015A, r18
    1b4a:	89 e0       	ldi	r24, 0x09	; 9
    1b4c:	28 9f       	mul	r18, r24
    1b4e:	c0 01       	movw	r24, r0
    1b50:	11 24       	eor	r1, r1
    1b52:	87 59       	subi	r24, 0x97	; 151
    1b54:	9e 4f       	sbci	r25, 0xFE	; 254
    1b56:	b8 01       	movw	r22, r16
    1b58:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
    1b5c:	81 e0       	ldi	r24, 0x01	; 1
    1b5e:	01 c0       	rjmp	.+2      	; 0x1b62 <xTaskPriorityDisinherit+0x60>
    1b60:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    1b62:	df 91       	pop	r29
    1b64:	cf 91       	pop	r28
    1b66:	1f 91       	pop	r17
    1b68:	0f 91       	pop	r16
    1b6a:	08 95       	ret

00001b6c <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
    1b6c:	0f 93       	push	r16
    1b6e:	1f 93       	push	r17
    1b70:	cf 93       	push	r28
    1b72:	df 93       	push	r29
    1b74:	ec 01       	movw	r28, r24
        BaseType_t xReturn = pdFALSE;

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
    1b76:	00 97       	sbiw	r24, 0x00	; 0
    1b78:	11 f4       	brne	.+4      	; 0x1b7e <xTaskPriorityInherit+0x12>
    1b7a:	20 e0       	ldi	r18, 0x00	; 0
    1b7c:	50 c0       	rjmp	.+160    	; 0x1c1e <xTaskPriorityInherit+0xb2>
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    1b7e:	e0 91 57 01 	lds	r30, 0x0157
    1b82:	f0 91 58 01 	lds	r31, 0x0158
    1b86:	9e 89       	ldd	r25, Y+22	; 0x16
    1b88:	86 89       	ldd	r24, Z+22	; 0x16
    1b8a:	98 17       	cp	r25, r24
    1b8c:	f0 f5       	brcc	.+124    	; 0x1c0a <xTaskPriorityInherit+0x9e>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1b8e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b90:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b92:	97 fd       	sbrc	r25, 7
    1b94:	0b c0       	rjmp	.+22     	; 0x1bac <xTaskPriorityInherit+0x40>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1b96:	e0 91 57 01 	lds	r30, 0x0157
    1b9a:	f0 91 58 01 	lds	r31, 0x0158
    1b9e:	26 89       	ldd	r18, Z+22	; 0x16
    1ba0:	84 e0       	ldi	r24, 0x04	; 4
    1ba2:	90 e0       	ldi	r25, 0x00	; 0
    1ba4:	82 1b       	sub	r24, r18
    1ba6:	91 09       	sbc	r25, r1
    1ba8:	9d 87       	std	Y+13, r25	; 0x0d
    1baa:	8c 87       	std	Y+12, r24	; 0x0c
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    1bac:	8e 89       	ldd	r24, Y+22	; 0x16
    1bae:	29 e0       	ldi	r18, 0x09	; 9
    1bb0:	82 9f       	mul	r24, r18
    1bb2:	c0 01       	movw	r24, r0
    1bb4:	11 24       	eor	r1, r1
    1bb6:	87 59       	subi	r24, 0x97	; 151
    1bb8:	9e 4f       	sbci	r25, 0xFE	; 254
    1bba:	2a 85       	ldd	r18, Y+10	; 0x0a
    1bbc:	3b 85       	ldd	r19, Y+11	; 0x0b
    1bbe:	28 17       	cp	r18, r24
    1bc0:	39 07       	cpc	r19, r25
    1bc2:	e1 f4       	brne	.+56     	; 0x1bfc <xTaskPriorityInherit+0x90>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1bc4:	8e 01       	movw	r16, r28
    1bc6:	0e 5f       	subi	r16, 0xFE	; 254
    1bc8:	1f 4f       	sbci	r17, 0xFF	; 255
    1bca:	c8 01       	movw	r24, r16
    1bcc:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    1bd0:	e0 91 57 01 	lds	r30, 0x0157
    1bd4:	f0 91 58 01 	lds	r31, 0x0158
    1bd8:	96 89       	ldd	r25, Z+22	; 0x16
    1bda:	9e 8b       	std	Y+22, r25	; 0x16
                    prvAddTaskToReadyList( pxMutexHolderTCB );
    1bdc:	80 91 5a 01 	lds	r24, 0x015A
    1be0:	89 17       	cp	r24, r25
    1be2:	10 f4       	brcc	.+4      	; 0x1be8 <xTaskPriorityInherit+0x7c>
    1be4:	90 93 5a 01 	sts	0x015A, r25
    1be8:	89 e0       	ldi	r24, 0x09	; 9
    1bea:	98 9f       	mul	r25, r24
    1bec:	c0 01       	movw	r24, r0
    1bee:	11 24       	eor	r1, r1
    1bf0:	87 59       	subi	r24, 0x97	; 151
    1bf2:	9e 4f       	sbci	r25, 0xFE	; 254
    1bf4:	b8 01       	movw	r22, r16
    1bf6:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
    1bfa:	10 c0       	rjmp	.+32     	; 0x1c1c <xTaskPriorityInherit+0xb0>
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    1bfc:	e0 91 57 01 	lds	r30, 0x0157
    1c00:	f0 91 58 01 	lds	r31, 0x0158
    1c04:	86 89       	ldd	r24, Z+22	; 0x16
    1c06:	8e 8b       	std	Y+22, r24	; 0x16
    1c08:	09 c0       	rjmp	.+18     	; 0x1c1c <xTaskPriorityInherit+0xb0>
                /* Inheritance occurred. */
                xReturn = pdTRUE;
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    1c0a:	e0 91 57 01 	lds	r30, 0x0157
    1c0e:	f0 91 58 01 	lds	r31, 0x0158
    1c12:	20 e0       	ldi	r18, 0x00	; 0
    1c14:	99 a1       	ldd	r25, Y+33	; 0x21
    1c16:	86 89       	ldd	r24, Z+22	; 0x16
    1c18:	98 17       	cp	r25, r24
    1c1a:	08 f4       	brcc	.+2      	; 0x1c1e <xTaskPriorityInherit+0xb2>
    1c1c:	21 e0       	ldi	r18, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    1c1e:	82 2f       	mov	r24, r18
    1c20:	df 91       	pop	r29
    1c22:	cf 91       	pop	r28
    1c24:	1f 91       	pop	r17
    1c26:	0f 91       	pop	r16
    1c28:	08 95       	ret

00001c2a <vTaskRemoveFromUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    1c2a:	0f 93       	push	r16
    1c2c:	1f 93       	push	r17
    1c2e:	cf 93       	push	r28
    1c30:	df 93       	push	r29
    1c32:	fc 01       	movw	r30, r24
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1c34:	70 68       	ori	r23, 0x80	; 128
    1c36:	71 83       	std	Z+1, r23	; 0x01
    1c38:	60 83       	st	Z, r22

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1c3a:	c6 81       	ldd	r28, Z+6	; 0x06
    1c3c:	d7 81       	ldd	r29, Z+7	; 0x07
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( pxEventListItem );
    1c3e:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1c42:	8e 01       	movw	r16, r28
    1c44:	0e 5f       	subi	r16, 0xFE	; 254
    1c46:	1f 4f       	sbci	r17, 0xFF	; 255
    1c48:	c8 01       	movw	r24, r16
    1c4a:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
    prvAddTaskToReadyList( pxUnblockedTCB );
    1c4e:	9e 89       	ldd	r25, Y+22	; 0x16
    1c50:	80 91 5a 01 	lds	r24, 0x015A
    1c54:	89 17       	cp	r24, r25
    1c56:	10 f4       	brcc	.+4      	; 0x1c5c <vTaskRemoveFromUnorderedEventList+0x32>
    1c58:	90 93 5a 01 	sts	0x015A, r25
    1c5c:	89 e0       	ldi	r24, 0x09	; 9
    1c5e:	98 9f       	mul	r25, r24
    1c60:	c0 01       	movw	r24, r0
    1c62:	11 24       	eor	r1, r1
    1c64:	87 59       	subi	r24, 0x97	; 151
    1c66:	9e 4f       	sbci	r25, 0xFE	; 254
    1c68:	b8 01       	movw	r22, r16
    1c6a:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1c6e:	e0 91 57 01 	lds	r30, 0x0157
    1c72:	f0 91 58 01 	lds	r31, 0x0158
    1c76:	9e 89       	ldd	r25, Y+22	; 0x16
    1c78:	86 89       	ldd	r24, Z+22	; 0x16
    1c7a:	89 17       	cp	r24, r25
    1c7c:	18 f4       	brcc	.+6      	; 0x1c84 <vTaskRemoveFromUnorderedEventList+0x5a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    1c7e:	81 e0       	ldi	r24, 0x01	; 1
    1c80:	80 93 5b 01 	sts	0x015B, r24
    }
}
    1c84:	df 91       	pop	r29
    1c86:	cf 91       	pop	r28
    1c88:	1f 91       	pop	r17
    1c8a:	0f 91       	pop	r16
    1c8c:	08 95       	ret

00001c8e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1c8e:	0f 93       	push	r16
    1c90:	1f 93       	push	r17
    1c92:	cf 93       	push	r28
    1c94:	df 93       	push	r29
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1c96:	dc 01       	movw	r26, r24
    1c98:	15 96       	adiw	r26, 0x05	; 5
    1c9a:	ed 91       	ld	r30, X+
    1c9c:	fc 91       	ld	r31, X
    1c9e:	16 97       	sbiw	r26, 0x06	; 6
    1ca0:	c6 81       	ldd	r28, Z+6	; 0x06
    1ca2:	d7 81       	ldd	r29, Z+7	; 0x07
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1ca4:	8e 01       	movw	r16, r28
    1ca6:	04 5f       	subi	r16, 0xF4	; 244
    1ca8:	1f 4f       	sbci	r17, 0xFF	; 255
    1caa:	c8 01       	movw	r24, r16
    1cac:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1cb0:	80 91 59 01 	lds	r24, 0x0159
    1cb4:	88 23       	and	r24, r24
    1cb6:	a1 f4       	brne	.+40     	; 0x1ce0 <xTaskRemoveFromEventList+0x52>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1cb8:	8e 01       	movw	r16, r28
    1cba:	0e 5f       	subi	r16, 0xFE	; 254
    1cbc:	1f 4f       	sbci	r17, 0xFF	; 255
    1cbe:	c8 01       	movw	r24, r16
    1cc0:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
        prvAddTaskToReadyList( pxUnblockedTCB );
    1cc4:	9e 89       	ldd	r25, Y+22	; 0x16
    1cc6:	80 91 5a 01 	lds	r24, 0x015A
    1cca:	89 17       	cp	r24, r25
    1ccc:	10 f4       	brcc	.+4      	; 0x1cd2 <xTaskRemoveFromEventList+0x44>
    1cce:	90 93 5a 01 	sts	0x015A, r25
    1cd2:	89 e0       	ldi	r24, 0x09	; 9
    1cd4:	98 9f       	mul	r25, r24
    1cd6:	c0 01       	movw	r24, r0
    1cd8:	11 24       	eor	r1, r1
    1cda:	87 59       	subi	r24, 0x97	; 151
    1cdc:	9e 4f       	sbci	r25, 0xFE	; 254
    1cde:	02 c0       	rjmp	.+4      	; 0x1ce4 <xTaskRemoveFromEventList+0x56>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1ce0:	83 ea       	ldi	r24, 0xA3	; 163
    1ce2:	91 e0       	ldi	r25, 0x01	; 1
    1ce4:	b8 01       	movw	r22, r16
    1ce6:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1cea:	e0 91 57 01 	lds	r30, 0x0157
    1cee:	f0 91 58 01 	lds	r31, 0x0158
    1cf2:	9e 89       	ldd	r25, Y+22	; 0x16
    1cf4:	86 89       	ldd	r24, Z+22	; 0x16
    1cf6:	89 17       	cp	r24, r25
    1cf8:	10 f0       	brcs	.+4      	; 0x1cfe <xTaskRemoveFromEventList+0x70>
    1cfa:	80 e0       	ldi	r24, 0x00	; 0
    1cfc:	03 c0       	rjmp	.+6      	; 0x1d04 <xTaskRemoveFromEventList+0x76>
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    1cfe:	81 e0       	ldi	r24, 0x01	; 1
    1d00:	80 93 5b 01 	sts	0x015B, r24
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    1d04:	df 91       	pop	r29
    1d06:	cf 91       	pop	r28
    1d08:	1f 91       	pop	r17
    1d0a:	0f 91       	pop	r16
    1d0c:	08 95       	ret

00001d0e <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1d0e:	cf 92       	push	r12
    1d10:	df 92       	push	r13
    1d12:	ef 92       	push	r14
    1d14:	ff 92       	push	r15
    1d16:	0f 93       	push	r16
    1d18:	1f 93       	push	r17
    1d1a:	cf 93       	push	r28
    1d1c:	df 93       	push	r29
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1d1e:	80 91 59 01 	lds	r24, 0x0159
    1d22:	88 23       	and	r24, r24
    1d24:	09 f0       	breq	.+2      	; 0x1d28 <xTaskIncrementTick+0x1a>
    1d26:	a4 c0       	rjmp	.+328    	; 0x1e70 <xTaskIncrementTick+0x162>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    1d28:	00 91 5c 01 	lds	r16, 0x015C
    1d2c:	10 91 5d 01 	lds	r17, 0x015D
    1d30:	0f 5f       	subi	r16, 0xFF	; 255
    1d32:	1f 4f       	sbci	r17, 0xFF	; 255

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    1d34:	10 93 5d 01 	sts	0x015D, r17
    1d38:	00 93 5c 01 	sts	0x015C, r16

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    1d3c:	01 15       	cp	r16, r1
    1d3e:	11 05       	cpc	r17, r1
    1d40:	61 f5       	brne	.+88     	; 0x1d9a <xTaskIncrementTick+0x8c>
        {
            taskSWITCH_DELAYED_LISTS();
    1d42:	20 91 9f 01 	lds	r18, 0x019F
    1d46:	30 91 a0 01 	lds	r19, 0x01A0
    1d4a:	80 91 a1 01 	lds	r24, 0x01A1
    1d4e:	90 91 a2 01 	lds	r25, 0x01A2
    1d52:	90 93 a0 01 	sts	0x01A0, r25
    1d56:	80 93 9f 01 	sts	0x019F, r24
    1d5a:	30 93 a2 01 	sts	0x01A2, r19
    1d5e:	20 93 a1 01 	sts	0x01A1, r18
    1d62:	80 91 60 01 	lds	r24, 0x0160
    1d66:	8f 5f       	subi	r24, 0xFF	; 255
    1d68:	80 93 60 01 	sts	0x0160, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1d6c:	e0 91 9f 01 	lds	r30, 0x019F
    1d70:	f0 91 a0 01 	lds	r31, 0x01A0
    1d74:	80 81       	ld	r24, Z
    1d76:	88 23       	and	r24, r24
    1d78:	19 f4       	brne	.+6      	; 0x1d80 <xTaskIncrementTick+0x72>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    1d7a:	8f ef       	ldi	r24, 0xFF	; 255
    1d7c:	9f ef       	ldi	r25, 0xFF	; 255
    1d7e:	09 c0       	rjmp	.+18     	; 0x1d92 <xTaskIncrementTick+0x84>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    1d80:	e0 91 9f 01 	lds	r30, 0x019F
    1d84:	f0 91 a0 01 	lds	r31, 0x01A0
    1d88:	05 80       	ldd	r0, Z+5	; 0x05
    1d8a:	f6 81       	ldd	r31, Z+6	; 0x06
    1d8c:	e0 2d       	mov	r30, r0
    1d8e:	80 81       	ld	r24, Z
    1d90:	91 81       	ldd	r25, Z+1	; 0x01
    1d92:	90 93 5f 01 	sts	0x015F, r25
    1d96:	80 93 5e 01 	sts	0x015E, r24

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    1d9a:	80 91 5e 01 	lds	r24, 0x015E
    1d9e:	90 91 5f 01 	lds	r25, 0x015F
    1da2:	08 17       	cp	r16, r24
    1da4:	19 07       	cpc	r17, r25
    1da6:	08 f4       	brcc	.+2      	; 0x1daa <xTaskIncrementTick+0x9c>
    1da8:	4b c0       	rjmp	.+150    	; 0x1e40 <xTaskIncrementTick+0x132>
    1daa:	dd 24       	eor	r13, r13
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    1dac:	99 e0       	ldi	r25, 0x09	; 9
    1dae:	c9 2e       	mov	r12, r25
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1db0:	e0 91 9f 01 	lds	r30, 0x019F
    1db4:	f0 91 a0 01 	lds	r31, 0x01A0
    1db8:	80 81       	ld	r24, Z
    1dba:	88 23       	and	r24, r24
    1dbc:	19 f4       	brne	.+6      	; 0x1dc4 <xTaskIncrementTick+0xb6>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1dbe:	8f ef       	ldi	r24, 0xFF	; 255
    1dc0:	9f ef       	ldi	r25, 0xFF	; 255
    1dc2:	0e c0       	rjmp	.+28     	; 0x1de0 <xTaskIncrementTick+0xd2>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1dc4:	e0 91 9f 01 	lds	r30, 0x019F
    1dc8:	f0 91 a0 01 	lds	r31, 0x01A0
    1dcc:	05 80       	ldd	r0, Z+5	; 0x05
    1dce:	f6 81       	ldd	r31, Z+6	; 0x06
    1dd0:	e0 2d       	mov	r30, r0
    1dd2:	c6 81       	ldd	r28, Z+6	; 0x06
    1dd4:	d7 81       	ldd	r29, Z+7	; 0x07
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1dd6:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd8:	9b 81       	ldd	r25, Y+3	; 0x03

                    if( xConstTickCount < xItemValue )
    1dda:	08 17       	cp	r16, r24
    1ddc:	19 07       	cpc	r17, r25
    1dde:	28 f4       	brcc	.+10     	; 0x1dea <xTaskIncrementTick+0xdc>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    1de0:	90 93 5f 01 	sts	0x015F, r25
    1de4:	80 93 5e 01 	sts	0x015E, r24
    1de8:	2c c0       	rjmp	.+88     	; 0x1e42 <xTaskIncrementTick+0x134>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1dea:	82 e0       	ldi	r24, 0x02	; 2
    1dec:	e8 2e       	mov	r14, r24
    1dee:	f1 2c       	mov	r15, r1
    1df0:	ec 0e       	add	r14, r28
    1df2:	fd 1e       	adc	r15, r29
    1df4:	c7 01       	movw	r24, r14
    1df6:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1dfa:	8c 89       	ldd	r24, Y+20	; 0x14
    1dfc:	9d 89       	ldd	r25, Y+21	; 0x15
    1dfe:	89 2b       	or	r24, r25
    1e00:	21 f0       	breq	.+8      	; 0x1e0a <xTaskIncrementTick+0xfc>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1e02:	ce 01       	movw	r24, r28
    1e04:	0c 96       	adiw	r24, 0x0c	; 12
    1e06:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    1e0a:	9e 89       	ldd	r25, Y+22	; 0x16
    1e0c:	80 91 5a 01 	lds	r24, 0x015A
    1e10:	89 17       	cp	r24, r25
    1e12:	10 f4       	brcc	.+4      	; 0x1e18 <xTaskIncrementTick+0x10a>
    1e14:	90 93 5a 01 	sts	0x015A, r25
    1e18:	9c 9d       	mul	r25, r12
    1e1a:	c0 01       	movw	r24, r0
    1e1c:	11 24       	eor	r1, r1
    1e1e:	87 59       	subi	r24, 0x97	; 151
    1e20:	9e 4f       	sbci	r25, 0xFE	; 254
    1e22:	b7 01       	movw	r22, r14
    1e24:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1e28:	e0 91 57 01 	lds	r30, 0x0157
    1e2c:	f0 91 58 01 	lds	r31, 0x0158
    1e30:	9e 89       	ldd	r25, Y+22	; 0x16
    1e32:	86 89       	ldd	r24, Z+22	; 0x16
    1e34:	98 17       	cp	r25, r24
    1e36:	08 f4       	brcc	.+2      	; 0x1e3a <xTaskIncrementTick+0x12c>
    1e38:	bb cf       	rjmp	.-138    	; 0x1db0 <xTaskIncrementTick+0xa2>
    1e3a:	dd 24       	eor	r13, r13
    1e3c:	d3 94       	inc	r13
    1e3e:	b8 cf       	rjmp	.-144    	; 0x1db0 <xTaskIncrementTick+0xa2>
    1e40:	dd 24       	eor	r13, r13
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1e42:	e0 91 57 01 	lds	r30, 0x0157
    1e46:	f0 91 58 01 	lds	r31, 0x0158
    1e4a:	e6 89       	ldd	r30, Z+22	; 0x16
    1e4c:	89 e0       	ldi	r24, 0x09	; 9
    1e4e:	e8 9f       	mul	r30, r24
    1e50:	f0 01       	movw	r30, r0
    1e52:	11 24       	eor	r1, r1
    1e54:	e7 59       	subi	r30, 0x97	; 151
    1e56:	fe 4f       	sbci	r31, 0xFE	; 254
    1e58:	80 81       	ld	r24, Z
    1e5a:	82 30       	cpi	r24, 0x02	; 2
    1e5c:	10 f0       	brcs	.+4      	; 0x1e62 <xTaskIncrementTick+0x154>
    1e5e:	dd 24       	eor	r13, r13
    1e60:	d3 94       	inc	r13
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    1e62:	80 91 5b 01 	lds	r24, 0x015B
    1e66:	88 23       	and	r24, r24
    1e68:	69 f0       	breq	.+26     	; 0x1e84 <xTaskIncrementTick+0x176>
    1e6a:	dd 24       	eor	r13, r13
    1e6c:	d3 94       	inc	r13
    1e6e:	0a c0       	rjmp	.+20     	; 0x1e84 <xTaskIncrementTick+0x176>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    1e70:	80 91 61 01 	lds	r24, 0x0161
    1e74:	90 91 62 01 	lds	r25, 0x0162
    1e78:	01 96       	adiw	r24, 0x01	; 1
    1e7a:	90 93 62 01 	sts	0x0162, r25
    1e7e:	80 93 61 01 	sts	0x0161, r24
    1e82:	dd 24       	eor	r13, r13
            }
        #endif
    }

    return xSwitchRequired;
}
    1e84:	8d 2d       	mov	r24, r13
    1e86:	df 91       	pop	r29
    1e88:	cf 91       	pop	r28
    1e8a:	1f 91       	pop	r17
    1e8c:	0f 91       	pop	r16
    1e8e:	ff 90       	pop	r15
    1e90:	ef 90       	pop	r14
    1e92:	df 90       	pop	r13
    1e94:	cf 90       	pop	r12
    1e96:	08 95       	ret

00001e98 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
    1e98:	ff 92       	push	r15
    1e9a:	0f 93       	push	r16
    1e9c:	1f 93       	push	r17
    1e9e:	cf 93       	push	r28
    1ea0:	df 93       	push	r29
    1ea2:	ec 01       	movw	r28, r24

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    1ea4:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ea6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ea8:	85 5b       	subi	r24, 0xB5	; 181
    1eaa:	91 40       	sbci	r25, 0x01	; 1
    1eac:	a9 f5       	brne	.+106    	; 0x1f18 <xTaskResumeFromISR+0x80>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    1eae:	8c 89       	ldd	r24, Y+20	; 0x14
    1eb0:	9d 89       	ldd	r25, Y+21	; 0x15
    1eb2:	21 e0       	ldi	r18, 0x01	; 1
    1eb4:	83 3a       	cpi	r24, 0xA3	; 163
    1eb6:	92 07       	cpc	r25, r18
    1eb8:	79 f1       	breq	.+94     	; 0x1f18 <xTaskResumeFromISR+0x80>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    1eba:	89 2b       	or	r24, r25
    1ebc:	69 f5       	brne	.+90     	; 0x1f18 <xTaskResumeFromISR+0x80>
    1ebe:	34 c0       	rjmp	.+104    	; 0x1f28 <xTaskResumeFromISR+0x90>
                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1ec0:	e0 91 57 01 	lds	r30, 0x0157
    1ec4:	f0 91 58 01 	lds	r31, 0x0158
    1ec8:	9e 89       	ldd	r25, Y+22	; 0x16
    1eca:	86 89       	ldd	r24, Z+22	; 0x16
    1ecc:	98 17       	cp	r25, r24
    1ece:	10 f4       	brcc	.+4      	; 0x1ed4 <xTaskResumeFromISR+0x3c>
    1ed0:	ff 24       	eor	r15, r15
    1ed2:	05 c0       	rjmp	.+10     	; 0x1ede <xTaskResumeFromISR+0x46>
                        xYieldRequired = pdTRUE;

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. */
                        xYieldPending = pdTRUE;
    1ed4:	81 e0       	ldi	r24, 0x01	; 1
    1ed6:	80 93 5b 01 	sts	0x015B, r24
    1eda:	ff 24       	eor	r15, r15
    1edc:	f3 94       	inc	r15
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1ede:	8e 01       	movw	r16, r28
    1ee0:	0e 5f       	subi	r16, 0xFE	; 254
    1ee2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ee4:	c8 01       	movw	r24, r16
    1ee6:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    1eea:	6e 89       	ldd	r22, Y+22	; 0x16
    1eec:	80 91 5a 01 	lds	r24, 0x015A
    1ef0:	86 17       	cp	r24, r22
    1ef2:	10 f4       	brcc	.+4      	; 0x1ef8 <xTaskResumeFromISR+0x60>
    1ef4:	60 93 5a 01 	sts	0x015A, r22
    1ef8:	89 e0       	ldi	r24, 0x09	; 9
    1efa:	68 9f       	mul	r22, r24
    1efc:	c0 01       	movw	r24, r0
    1efe:	11 24       	eor	r1, r1
    1f00:	87 59       	subi	r24, 0x97	; 151
    1f02:	9e 4f       	sbci	r25, 0xFE	; 254
    1f04:	b8 01       	movw	r22, r16
    1f06:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
    1f0a:	07 c0       	rjmp	.+14     	; 0x1f1a <xTaskResumeFromISR+0x82>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1f0c:	2c 96       	adiw	r28, 0x0c	; 12
    1f0e:	83 ea       	ldi	r24, 0xA3	; 163
    1f10:	91 e0       	ldi	r25, 0x01	; 1
    1f12:	be 01       	movw	r22, r28
    1f14:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
    1f18:	ff 24       	eor	r15, r15
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
    }
    1f1a:	8f 2d       	mov	r24, r15
    1f1c:	df 91       	pop	r29
    1f1e:	cf 91       	pop	r28
    1f20:	1f 91       	pop	r17
    1f22:	0f 91       	pop	r16
    1f24:	ff 90       	pop	r15
    1f26:	08 95       	ret
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1f28:	80 91 59 01 	lds	r24, 0x0159
    1f2c:	88 23       	and	r24, r24
    1f2e:	41 f2       	breq	.-112    	; 0x1ec0 <xTaskResumeFromISR+0x28>
    1f30:	ed cf       	rjmp	.-38     	; 0x1f0c <xTaskResumeFromISR+0x74>

00001f32 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    1f32:	ef 92       	push	r14
    1f34:	ff 92       	push	r15
    1f36:	0f 93       	push	r16
    1f38:	1f 93       	push	r17
    1f3a:	cf 93       	push	r28
    1f3c:	df 93       	push	r29
    1f3e:	ec 01       	movw	r28, r24

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
    1f40:	0f b6       	in	r0, 0x3f	; 63
    1f42:	f8 94       	cli
    1f44:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    1f46:	e1 14       	cp	r14, r1
    1f48:	f1 04       	cpc	r15, r1
    1f4a:	89 f0       	breq	.+34     	; 0x1f6e <xTaskGenericNotify+0x3c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    1f4c:	e6 2f       	mov	r30, r22
    1f4e:	f0 e0       	ldi	r31, 0x00	; 0
    1f50:	ee 0f       	add	r30, r30
    1f52:	ff 1f       	adc	r31, r31
    1f54:	ee 0f       	add	r30, r30
    1f56:	ff 1f       	adc	r31, r31
    1f58:	e8 0f       	add	r30, r24
    1f5a:	f9 1f       	adc	r31, r25
    1f5c:	83 a1       	ldd	r24, Z+35	; 0x23
    1f5e:	94 a1       	ldd	r25, Z+36	; 0x24
    1f60:	a5 a1       	ldd	r26, Z+37	; 0x25
    1f62:	b6 a1       	ldd	r27, Z+38	; 0x26
    1f64:	f7 01       	movw	r30, r14
    1f66:	80 83       	st	Z, r24
    1f68:	91 83       	std	Z+1, r25	; 0x01
    1f6a:	a2 83       	std	Z+2, r26	; 0x02
    1f6c:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1f6e:	a6 2f       	mov	r26, r22
    1f70:	b0 e0       	ldi	r27, 0x00	; 0
    1f72:	fe 01       	movw	r30, r28
    1f74:	ea 0f       	add	r30, r26
    1f76:	fb 1f       	adc	r31, r27
    1f78:	67 a1       	ldd	r22, Z+39	; 0x27

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1f7a:	82 e0       	ldi	r24, 0x02	; 2
    1f7c:	87 a3       	std	Z+39, r24	; 0x27

            switch( eAction )
    1f7e:	02 30       	cpi	r16, 0x02	; 2
    1f80:	d1 f0       	breq	.+52     	; 0x1fb6 <xTaskGenericNotify+0x84>
    1f82:	03 30       	cpi	r16, 0x03	; 3
    1f84:	18 f4       	brcc	.+6      	; 0x1f8c <xTaskGenericNotify+0x5a>
    1f86:	01 30       	cpi	r16, 0x01	; 1
    1f88:	c9 f5       	brne	.+114    	; 0x1ffc <xTaskGenericNotify+0xca>
    1f8a:	05 c0       	rjmp	.+10     	; 0x1f96 <xTaskGenericNotify+0x64>
    1f8c:	03 30       	cpi	r16, 0x03	; 3
    1f8e:	51 f1       	breq	.+84     	; 0x1fe4 <xTaskGenericNotify+0xb2>
    1f90:	04 30       	cpi	r16, 0x04	; 4
    1f92:	a1 f5       	brne	.+104    	; 0x1ffc <xTaskGenericNotify+0xca>
    1f94:	23 c0       	rjmp	.+70     	; 0x1fdc <xTaskGenericNotify+0xaa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    1f96:	fd 01       	movw	r30, r26
    1f98:	ee 0f       	add	r30, r30
    1f9a:	ff 1f       	adc	r31, r31
    1f9c:	ee 0f       	add	r30, r30
    1f9e:	ff 1f       	adc	r31, r31
    1fa0:	ec 0f       	add	r30, r28
    1fa2:	fd 1f       	adc	r31, r29
    1fa4:	83 a1       	ldd	r24, Z+35	; 0x23
    1fa6:	94 a1       	ldd	r25, Z+36	; 0x24
    1fa8:	a5 a1       	ldd	r26, Z+37	; 0x25
    1faa:	b6 a1       	ldd	r27, Z+38	; 0x26
    1fac:	82 2b       	or	r24, r18
    1fae:	93 2b       	or	r25, r19
    1fb0:	a4 2b       	or	r26, r20
    1fb2:	b5 2b       	or	r27, r21
    1fb4:	0e c0       	rjmp	.+28     	; 0x1fd2 <xTaskGenericNotify+0xa0>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    1fb6:	fd 01       	movw	r30, r26
    1fb8:	ee 0f       	add	r30, r30
    1fba:	ff 1f       	adc	r31, r31
    1fbc:	ee 0f       	add	r30, r30
    1fbe:	ff 1f       	adc	r31, r31
    1fc0:	ec 0f       	add	r30, r28
    1fc2:	fd 1f       	adc	r31, r29
    1fc4:	83 a1       	ldd	r24, Z+35	; 0x23
    1fc6:	94 a1       	ldd	r25, Z+36	; 0x24
    1fc8:	a5 a1       	ldd	r26, Z+37	; 0x25
    1fca:	b6 a1       	ldd	r27, Z+38	; 0x26
    1fcc:	01 96       	adiw	r24, 0x01	; 1
    1fce:	a1 1d       	adc	r26, r1
    1fd0:	b1 1d       	adc	r27, r1
    1fd2:	83 a3       	std	Z+35, r24	; 0x23
    1fd4:	94 a3       	std	Z+36, r25	; 0x24
    1fd6:	a5 a3       	std	Z+37, r26	; 0x25
    1fd8:	b6 a3       	std	Z+38, r27	; 0x26
    1fda:	10 c0       	rjmp	.+32     	; 0x1ffc <xTaskGenericNotify+0xca>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1fdc:	62 30       	cpi	r22, 0x02	; 2
    1fde:	11 f4       	brne	.+4      	; 0x1fe4 <xTaskGenericNotify+0xb2>
    1fe0:	80 e0       	ldi	r24, 0x00	; 0
    1fe2:	2f c0       	rjmp	.+94     	; 0x2042 <xTaskGenericNotify+0x110>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    1fe4:	aa 0f       	add	r26, r26
    1fe6:	bb 1f       	adc	r27, r27
    1fe8:	aa 0f       	add	r26, r26
    1fea:	bb 1f       	adc	r27, r27
    1fec:	ac 0f       	add	r26, r28
    1fee:	bd 1f       	adc	r27, r29
    1ff0:	93 96       	adiw	r26, 0x23	; 35
    1ff2:	2d 93       	st	X+, r18
    1ff4:	3d 93       	st	X+, r19
    1ff6:	4d 93       	st	X+, r20
    1ff8:	5c 93       	st	X, r21
    1ffa:	96 97       	sbiw	r26, 0x26	; 38

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1ffc:	61 30       	cpi	r22, 0x01	; 1
    1ffe:	01 f5       	brne	.+64     	; 0x2040 <xTaskGenericNotify+0x10e>
            {
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2000:	8e 01       	movw	r16, r28
    2002:	0e 5f       	subi	r16, 0xFE	; 254
    2004:	1f 4f       	sbci	r17, 0xFF	; 255
    2006:	c8 01       	movw	r24, r16
    2008:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                prvAddTaskToReadyList( pxTCB );
    200c:	9e 89       	ldd	r25, Y+22	; 0x16
    200e:	80 91 5a 01 	lds	r24, 0x015A
    2012:	89 17       	cp	r24, r25
    2014:	10 f4       	brcc	.+4      	; 0x201a <xTaskGenericNotify+0xe8>
    2016:	90 93 5a 01 	sts	0x015A, r25
    201a:	89 e0       	ldi	r24, 0x09	; 9
    201c:	98 9f       	mul	r25, r24
    201e:	c0 01       	movw	r24, r0
    2020:	11 24       	eor	r1, r1
    2022:	87 59       	subi	r24, 0x97	; 151
    2024:	9e 4f       	sbci	r25, 0xFE	; 254
    2026:	b8 01       	movw	r22, r16
    2028:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    202c:	e0 91 57 01 	lds	r30, 0x0157
    2030:	f0 91 58 01 	lds	r31, 0x0158
    2034:	9e 89       	ldd	r25, Y+22	; 0x16
    2036:	86 89       	ldd	r24, Z+22	; 0x16
    2038:	89 17       	cp	r24, r25
    203a:	10 f4       	brcc	.+4      	; 0x2040 <xTaskGenericNotify+0x10e>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    203c:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
    2040:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2042:	0f 90       	pop	r0
    2044:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    2046:	df 91       	pop	r29
    2048:	cf 91       	pop	r28
    204a:	1f 91       	pop	r17
    204c:	0f 91       	pop	r16
    204e:	ff 90       	pop	r15
    2050:	ef 90       	pop	r14
    2052:	08 95       	ret

00002054 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2054:	ef 92       	push	r14
    2056:	ff 92       	push	r15
    2058:	0f 93       	push	r16
    205a:	1f 93       	push	r17
    205c:	cf 93       	push	r28
    205e:	df 93       	push	r29
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    2060:	0f b6       	in	r0, 0x3f	; 63
    2062:	f8 94       	cli
    2064:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    2066:	80 91 59 01 	lds	r24, 0x0159
    206a:	81 50       	subi	r24, 0x01	; 1
    206c:	80 93 59 01 	sts	0x0159, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2070:	80 91 59 01 	lds	r24, 0x0159
    2074:	88 23       	and	r24, r24
    2076:	09 f0       	breq	.+2      	; 0x207a <xTaskResumeAll+0x26>
    2078:	6d c0       	rjmp	.+218    	; 0x2154 <xTaskResumeAll+0x100>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    207a:	80 91 63 01 	lds	r24, 0x0163
    207e:	88 23       	and	r24, r24
    2080:	09 f4       	brne	.+2      	; 0x2084 <xTaskResumeAll+0x30>
    2082:	68 c0       	rjmp	.+208    	; 0x2154 <xTaskResumeAll+0x100>
    2084:	c0 e0       	ldi	r28, 0x00	; 0
    2086:	d0 e0       	ldi	r29, 0x00	; 0
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
    2088:	09 e0       	ldi	r16, 0x09	; 9
    208a:	e0 2e       	mov	r14, r16

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
                    {
                        xYieldPending = pdTRUE;
    208c:	ff 24       	eor	r15, r15
    208e:	f3 94       	inc	r15
    2090:	29 c0       	rjmp	.+82     	; 0x20e4 <xTaskResumeAll+0x90>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2092:	e0 91 a8 01 	lds	r30, 0x01A8
    2096:	f0 91 a9 01 	lds	r31, 0x01A9
    209a:	c6 81       	ldd	r28, Z+6	; 0x06
    209c:	d7 81       	ldd	r29, Z+7	; 0x07
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    209e:	ce 01       	movw	r24, r28
    20a0:	0c 96       	adiw	r24, 0x0c	; 12
    20a2:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    20a6:	8e 01       	movw	r16, r28
    20a8:	0e 5f       	subi	r16, 0xFE	; 254
    20aa:	1f 4f       	sbci	r17, 0xFF	; 255
    20ac:	c8 01       	movw	r24, r16
    20ae:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    20b2:	9e 89       	ldd	r25, Y+22	; 0x16
    20b4:	80 91 5a 01 	lds	r24, 0x015A
    20b8:	89 17       	cp	r24, r25
    20ba:	10 f4       	brcc	.+4      	; 0x20c0 <xTaskResumeAll+0x6c>
    20bc:	90 93 5a 01 	sts	0x015A, r25
    20c0:	9e 9d       	mul	r25, r14
    20c2:	c0 01       	movw	r24, r0
    20c4:	11 24       	eor	r1, r1
    20c6:	87 59       	subi	r24, 0x97	; 151
    20c8:	9e 4f       	sbci	r25, 0xFE	; 254
    20ca:	b8 01       	movw	r22, r16
    20cc:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    20d0:	e0 91 57 01 	lds	r30, 0x0157
    20d4:	f0 91 58 01 	lds	r31, 0x0158
    20d8:	9e 89       	ldd	r25, Y+22	; 0x16
    20da:	86 89       	ldd	r24, Z+22	; 0x16
    20dc:	98 17       	cp	r25, r24
    20de:	10 f0       	brcs	.+4      	; 0x20e4 <xTaskResumeAll+0x90>
                    {
                        xYieldPending = pdTRUE;
    20e0:	f0 92 5b 01 	sts	0x015B, r15
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    20e4:	80 91 a3 01 	lds	r24, 0x01A3
    20e8:	88 23       	and	r24, r24
    20ea:	99 f6       	brne	.-90     	; 0x2092 <xTaskResumeAll+0x3e>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    20ec:	cd 2b       	or	r28, r29
    20ee:	b9 f0       	breq	.+46     	; 0x211e <xTaskResumeAll+0xca>
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    20f0:	e0 91 9f 01 	lds	r30, 0x019F
    20f4:	f0 91 a0 01 	lds	r31, 0x01A0
    20f8:	80 81       	ld	r24, Z
    20fa:	88 23       	and	r24, r24
    20fc:	19 f4       	brne	.+6      	; 0x2104 <xTaskResumeAll+0xb0>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    20fe:	8f ef       	ldi	r24, 0xFF	; 255
    2100:	9f ef       	ldi	r25, 0xFF	; 255
    2102:	09 c0       	rjmp	.+18     	; 0x2116 <xTaskResumeAll+0xc2>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    2104:	e0 91 9f 01 	lds	r30, 0x019F
    2108:	f0 91 a0 01 	lds	r31, 0x01A0
    210c:	05 80       	ldd	r0, Z+5	; 0x05
    210e:	f6 81       	ldd	r31, Z+6	; 0x06
    2110:	e0 2d       	mov	r30, r0
    2112:	80 81       	ld	r24, Z
    2114:	91 81       	ldd	r25, Z+1	; 0x01
    2116:	90 93 5f 01 	sts	0x015F, r25
    211a:	80 93 5e 01 	sts	0x015E, r24
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    211e:	c0 91 61 01 	lds	r28, 0x0161
    2122:	d0 91 62 01 	lds	r29, 0x0162

                    if( xPendedCounts > ( TickType_t ) 0U )
    2126:	20 97       	sbiw	r28, 0x00	; 0
    2128:	69 f0       	breq	.+26     	; 0x2144 <xTaskResumeAll+0xf0>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
    212a:	11 e0       	ldi	r17, 0x01	; 1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    212c:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <xTaskIncrementTick>
    2130:	88 23       	and	r24, r24
    2132:	11 f0       	breq	.+4      	; 0x2138 <xTaskResumeAll+0xe4>
                            {
                                xYieldPending = pdTRUE;
    2134:	10 93 5b 01 	sts	0x015B, r17
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    2138:	21 97       	sbiw	r28, 0x01	; 1
                        } while( xPendedCounts > ( TickType_t ) 0U );
    213a:	c1 f7       	brne	.-16     	; 0x212c <xTaskResumeAll+0xd8>

                        xPendedTicks = 0;
    213c:	10 92 62 01 	sts	0x0162, r1
    2140:	10 92 61 01 	sts	0x0161, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    2144:	80 91 5b 01 	lds	r24, 0x015B
    2148:	88 23       	and	r24, r24
    214a:	21 f0       	breq	.+8      	; 0x2154 <xTaskResumeAll+0x100>
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    214c:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
    2150:	81 e0       	ldi	r24, 0x01	; 1
    2152:	01 c0       	rjmp	.+2      	; 0x2156 <xTaskResumeAll+0x102>
    2154:	80 e0       	ldi	r24, 0x00	; 0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    2156:	0f 90       	pop	r0
    2158:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
}
    215a:	df 91       	pop	r29
    215c:	cf 91       	pop	r28
    215e:	1f 91       	pop	r17
    2160:	0f 91       	pop	r16
    2162:	ff 90       	pop	r15
    2164:	ef 90       	pop	r14
    2166:	08 95       	ret

00002168 <xTaskCatchUpTicks>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    2168:	20 91 59 01 	lds	r18, 0x0159
    216c:	2f 5f       	subi	r18, 0xFF	; 255
    216e:	20 93 59 01 	sts	0x0159, r18
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    xPendedTicks += xTicksToCatchUp;
    2172:	20 91 61 01 	lds	r18, 0x0161
    2176:	30 91 62 01 	lds	r19, 0x0162
    217a:	28 0f       	add	r18, r24
    217c:	39 1f       	adc	r19, r25
    217e:	30 93 62 01 	sts	0x0162, r19
    2182:	20 93 61 01 	sts	0x0161, r18
    xYieldOccurred = xTaskResumeAll();
    2186:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>

    return xYieldOccurred;
}
    218a:	08 95       	ret

0000218c <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
    218c:	0f 93       	push	r16
    218e:	1f 93       	push	r17
    2190:	cf 93       	push	r28
    2192:	df 93       	push	r29
    2194:	ec 01       	movw	r28, r24
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    2196:	80 91 57 01 	lds	r24, 0x0157
    219a:	90 91 58 01 	lds	r25, 0x0158
    219e:	c8 17       	cp	r28, r24
    21a0:	d9 07       	cpc	r29, r25
    21a2:	b9 f1       	breq	.+110    	; 0x2212 <vTaskResume+0x86>
    21a4:	20 97       	sbiw	r28, 0x00	; 0
    21a6:	a9 f1       	breq	.+106    	; 0x2212 <vTaskResume+0x86>
        {
            taskENTER_CRITICAL();
    21a8:	0f b6       	in	r0, 0x3f	; 63
    21aa:	f8 94       	cli
    21ac:	0f 92       	push	r0

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    21ae:	8a 85       	ldd	r24, Y+10	; 0x0a
    21b0:	9b 85       	ldd	r25, Y+11	; 0x0b
    21b2:	85 5b       	subi	r24, 0xB5	; 181
    21b4:	91 40       	sbci	r25, 0x01	; 1
    21b6:	f1 f4       	brne	.+60     	; 0x21f4 <vTaskResume+0x68>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    21b8:	8c 89       	ldd	r24, Y+20	; 0x14
    21ba:	9d 89       	ldd	r25, Y+21	; 0x15
    21bc:	21 e0       	ldi	r18, 0x01	; 1
    21be:	83 3a       	cpi	r24, 0xA3	; 163
    21c0:	92 07       	cpc	r25, r18
    21c2:	c1 f0       	breq	.+48     	; 0x21f4 <vTaskResume+0x68>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    21c4:	89 2b       	or	r24, r25
    21c6:	b1 f4       	brne	.+44     	; 0x21f4 <vTaskResume+0x68>
    21c8:	18 c0       	rjmp	.+48     	; 0x21fa <vTaskResume+0x6e>
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
    21ca:	90 93 5a 01 	sts	0x015A, r25
    21ce:	89 e0       	ldi	r24, 0x09	; 9
    21d0:	98 9f       	mul	r25, r24
    21d2:	c0 01       	movw	r24, r0
    21d4:	11 24       	eor	r1, r1
    21d6:	87 59       	subi	r24, 0x97	; 151
    21d8:	9e 4f       	sbci	r25, 0xFE	; 254
    21da:	b8 01       	movw	r22, r16
    21dc:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    21e0:	e0 91 57 01 	lds	r30, 0x0157
    21e4:	f0 91 58 01 	lds	r31, 0x0158
    21e8:	9e 89       	ldd	r25, Y+22	; 0x16
    21ea:	86 89       	ldd	r24, Z+22	; 0x16
    21ec:	98 17       	cp	r25, r24
    21ee:	10 f0       	brcs	.+4      	; 0x21f4 <vTaskResume+0x68>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
    21f0:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    21f4:	0f 90       	pop	r0
    21f6:	0f be       	out	0x3f, r0	; 63
    21f8:	0c c0       	rjmp	.+24     	; 0x2212 <vTaskResume+0x86>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    21fa:	8e 01       	movw	r16, r28
    21fc:	0e 5f       	subi	r16, 0xFE	; 254
    21fe:	1f 4f       	sbci	r17, 0xFF	; 255
    2200:	c8 01       	movw	r24, r16
    2202:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    2206:	9e 89       	ldd	r25, Y+22	; 0x16
    2208:	80 91 5a 01 	lds	r24, 0x015A
    220c:	89 17       	cp	r24, r25
    220e:	e8 f2       	brcs	.-70     	; 0x21ca <vTaskResume+0x3e>
    2210:	de cf       	rjmp	.-68     	; 0x21ce <vTaskResume+0x42>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    2212:	df 91       	pop	r29
    2214:	cf 91       	pop	r28
    2216:	1f 91       	pop	r17
    2218:	0f 91       	pop	r16
    221a:	08 95       	ret

0000221c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
    221c:	0f 93       	push	r16
    221e:	1f 93       	push	r17
    2220:	cf 93       	push	r28
    2222:	df 93       	push	r29
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    2224:	0f b6       	in	r0, 0x3f	; 63
    2226:	f8 94       	cli
    2228:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    222a:	00 97       	sbiw	r24, 0x00	; 0
    222c:	11 f0       	breq	.+4      	; 0x2232 <vTaskSuspend+0x16>
    222e:	ec 01       	movw	r28, r24
    2230:	04 c0       	rjmp	.+8      	; 0x223a <vTaskSuspend+0x1e>
    2232:	c0 91 57 01 	lds	r28, 0x0157
    2236:	d0 91 58 01 	lds	r29, 0x0158

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    223a:	8e 01       	movw	r16, r28
    223c:	0e 5f       	subi	r16, 0xFE	; 254
    223e:	1f 4f       	sbci	r17, 0xFF	; 255
    2240:	c8 01       	movw	r24, r16
    2242:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2246:	8c 89       	ldd	r24, Y+20	; 0x14
    2248:	9d 89       	ldd	r25, Y+21	; 0x15
    224a:	89 2b       	or	r24, r25
    224c:	21 f0       	breq	.+8      	; 0x2256 <vTaskSuspend+0x3a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    224e:	ce 01       	movw	r24, r28
    2250:	0c 96       	adiw	r24, 0x0c	; 12
    2252:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    2256:	85 eb       	ldi	r24, 0xB5	; 181
    2258:	91 e0       	ldi	r25, 0x01	; 1
    225a:	b8 01       	movw	r22, r16
    225c:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
                {
                    BaseType_t x;

                    for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
                    {
                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
    2260:	8f a1       	ldd	r24, Y+39	; 0x27
    2262:	81 30       	cpi	r24, 0x01	; 1
    2264:	09 f4       	brne	.+2      	; 0x2268 <vTaskSuspend+0x4c>
                        {
                            /* The task was blocked to wait for a notification, but is
                             * now suspended, so no notification was received. */
                            pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
    2266:	1f a2       	std	Y+39, r1	; 0x27
                        }
                    }
                }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
    2268:	0f 90       	pop	r0
    226a:	0f be       	out	0x3f, r0	; 63

        if( xSchedulerRunning != pdFALSE )
    226c:	80 91 64 01 	lds	r24, 0x0164
    2270:	88 23       	and	r24, r24
    2272:	e1 f0       	breq	.+56     	; 0x22ac <vTaskSuspend+0x90>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
    2274:	0f b6       	in	r0, 0x3f	; 63
    2276:	f8 94       	cli
    2278:	0f 92       	push	r0
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    227a:	e0 91 9f 01 	lds	r30, 0x019F
    227e:	f0 91 a0 01 	lds	r31, 0x01A0
    2282:	80 81       	ld	r24, Z
    2284:	88 23       	and	r24, r24
    2286:	19 f4       	brne	.+6      	; 0x228e <vTaskSuspend+0x72>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    2288:	8f ef       	ldi	r24, 0xFF	; 255
    228a:	9f ef       	ldi	r25, 0xFF	; 255
    228c:	09 c0       	rjmp	.+18     	; 0x22a0 <vTaskSuspend+0x84>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    228e:	e0 91 9f 01 	lds	r30, 0x019F
    2292:	f0 91 a0 01 	lds	r31, 0x01A0
    2296:	05 80       	ldd	r0, Z+5	; 0x05
    2298:	f6 81       	ldd	r31, Z+6	; 0x06
    229a:	e0 2d       	mov	r30, r0
    229c:	80 81       	ld	r24, Z
    229e:	91 81       	ldd	r25, Z+1	; 0x01
    22a0:	90 93 5f 01 	sts	0x015F, r25
    22a4:	80 93 5e 01 	sts	0x015E, r24
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
            {
                prvResetNextTaskUnblockTime();
            }
            taskEXIT_CRITICAL();
    22a8:	0f 90       	pop	r0
    22aa:	0f be       	out	0x3f, r0	; 63
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
    22ac:	80 91 57 01 	lds	r24, 0x0157
    22b0:	90 91 58 01 	lds	r25, 0x0158
    22b4:	c8 17       	cp	r28, r24
    22b6:	d9 07       	cpc	r29, r25
    22b8:	a1 f4       	brne	.+40     	; 0x22e2 <vTaskSuspend+0xc6>
        {
            if( xSchedulerRunning != pdFALSE )
    22ba:	80 91 64 01 	lds	r24, 0x0164
    22be:	88 23       	and	r24, r24
    22c0:	19 f0       	breq	.+6      	; 0x22c8 <vTaskSuspend+0xac>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    22c2:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
    22c6:	0d c0       	rjmp	.+26     	; 0x22e2 <vTaskSuspend+0xc6>
            else
            {
                /* The scheduler is not running, but the task that was pointed
                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
                 * must be adjusted to point to a different task. */
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    22c8:	90 91 b5 01 	lds	r25, 0x01B5
    22cc:	80 91 63 01 	lds	r24, 0x0163
    22d0:	98 17       	cp	r25, r24
    22d2:	29 f4       	brne	.+10     	; 0x22de <vTaskSuspend+0xc2>
                {
                    /* No other tasks are ready, so set pxCurrentTCB back to
                     * NULL so when the next task is created pxCurrentTCB will
                     * be set to point to it no matter what its relative priority
                     * is. */
                    pxCurrentTCB = NULL;
    22d4:	10 92 58 01 	sts	0x0158, r1
    22d8:	10 92 57 01 	sts	0x0157, r1
    22dc:	02 c0       	rjmp	.+4      	; 0x22e2 <vTaskSuspend+0xc6>
                }
                else
                {
                    vTaskSwitchContext();
    22de:	0e 94 33 0b 	call	0x1666	; 0x1666 <vTaskSwitchContext>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    22e2:	df 91       	pop	r29
    22e4:	cf 91       	pop	r28
    22e6:	1f 91       	pop	r17
    22e8:	0f 91       	pop	r16
    22ea:	08 95       	ret

000022ec <vTaskPrioritySet>:

#if ( INCLUDE_vTaskPrioritySet == 1 )

    void vTaskPrioritySet( TaskHandle_t xTask,
                           UBaseType_t uxNewPriority )
    {
    22ec:	ff 92       	push	r15
    22ee:	0f 93       	push	r16
    22f0:	1f 93       	push	r17
    22f2:	cf 93       	push	r28
    22f4:	df 93       	push	r29
    22f6:	64 30       	cpi	r22, 0x04	; 4
    22f8:	08 f0       	brcs	.+2      	; 0x22fc <vTaskPrioritySet+0x10>
    22fa:	63 e0       	ldi	r22, 0x03	; 3
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        taskENTER_CRITICAL();
    22fc:	0f b6       	in	r0, 0x3f	; 63
    22fe:	f8 94       	cli
    2300:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being changed. */
            pxTCB = prvGetTCBFromHandle( xTask );
    2302:	00 97       	sbiw	r24, 0x00	; 0
    2304:	11 f0       	breq	.+4      	; 0x230a <vTaskPrioritySet+0x1e>
    2306:	ec 01       	movw	r28, r24
    2308:	04 c0       	rjmp	.+8      	; 0x2312 <vTaskPrioritySet+0x26>
    230a:	c0 91 57 01 	lds	r28, 0x0157
    230e:	d0 91 58 01 	lds	r29, 0x0158

            traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

            #if ( configUSE_MUTEXES == 1 )
                {
                    uxCurrentBasePriority = pxTCB->uxBasePriority;
    2312:	29 a1       	ldd	r18, Y+33	; 0x21
                {
                    uxCurrentBasePriority = pxTCB->uxPriority;
                }
            #endif

            if( uxCurrentBasePriority != uxNewPriority )
    2314:	26 17       	cp	r18, r22
    2316:	09 f4       	brne	.+2      	; 0x231a <vTaskPrioritySet+0x2e>
    2318:	52 c0       	rjmp	.+164    	; 0x23be <vTaskPrioritySet+0xd2>
            {
                /* The priority change may have readied a task of higher
                 * priority than the calling task. */
                if( uxNewPriority > uxCurrentBasePriority )
    231a:	26 17       	cp	r18, r22
    231c:	90 f4       	brcc	.+36     	; 0x2342 <vTaskPrioritySet+0x56>
                {
                    if( pxTCB != pxCurrentTCB )
    231e:	80 91 57 01 	lds	r24, 0x0157
    2322:	90 91 58 01 	lds	r25, 0x0158
    2326:	c8 17       	cp	r28, r24
    2328:	d9 07       	cpc	r29, r25
    232a:	11 f4       	brne	.+4      	; 0x2330 <vTaskPrioritySet+0x44>
    232c:	ff 24       	eor	r15, r15
    232e:	13 c0       	rjmp	.+38     	; 0x2356 <vTaskPrioritySet+0x6a>
                    {
                        /* The priority of a task other than the currently
                         * running task is being raised.  Is the priority being
                         * raised above that of the running task? */
                        if( uxNewPriority >= pxCurrentTCB->uxPriority )
    2330:	e0 91 57 01 	lds	r30, 0x0157
    2334:	f0 91 58 01 	lds	r31, 0x0158
    2338:	ff 24       	eor	r15, r15
    233a:	86 89       	ldd	r24, Z+22	; 0x16
    233c:	68 17       	cp	r22, r24
    233e:	58 f0       	brcs	.+22     	; 0x2356 <vTaskPrioritySet+0x6a>
    2340:	08 c0       	rjmp	.+16     	; 0x2352 <vTaskPrioritySet+0x66>
                        /* The priority of the running task is being raised,
                         * but the running task must already be the highest
                         * priority task able to run so no yield is required. */
                    }
                }
                else if( pxTCB == pxCurrentTCB )
    2342:	80 91 57 01 	lds	r24, 0x0157
    2346:	90 91 58 01 	lds	r25, 0x0158
    234a:	ff 24       	eor	r15, r15
    234c:	c8 17       	cp	r28, r24
    234e:	d9 07       	cpc	r29, r25
    2350:	11 f4       	brne	.+4      	; 0x2356 <vTaskPrioritySet+0x6a>
    2352:	ff 24       	eor	r15, r15
    2354:	f3 94       	inc	r15
                }

                /* Remember the ready list the task might be referenced from
                 * before its uxPriority member is changed so the
                 * taskRESET_READY_PRIORITY() macro can function correctly. */
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
    2356:	3e 89       	ldd	r19, Y+22	; 0x16

                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* Only change the priority being used if the task is not
                         * currently using an inherited priority. */
                        if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    2358:	23 17       	cp	r18, r19
    235a:	09 f4       	brne	.+2      	; 0x235e <vTaskPrioritySet+0x72>
                        {
                            pxTCB->uxPriority = uxNewPriority;
    235c:	6e 8b       	std	Y+22, r22	; 0x16
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        /* The base priority gets set whatever. */
                        pxTCB->uxBasePriority = uxNewPriority;
    235e:	69 a3       	std	Y+33, r22	; 0x21
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                /* Only reset the event list item value if the value is not
                 * being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2360:	8c 85       	ldd	r24, Y+12	; 0x0c
    2362:	9d 85       	ldd	r25, Y+13	; 0x0d
    2364:	97 fd       	sbrc	r25, 7
    2366:	06 c0       	rjmp	.+12     	; 0x2374 <vTaskPrioritySet+0x88>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2368:	84 e0       	ldi	r24, 0x04	; 4
    236a:	90 e0       	ldi	r25, 0x00	; 0
    236c:	86 1b       	sub	r24, r22
    236e:	91 09       	sbc	r25, r1
    2370:	9d 87       	std	Y+13, r25	; 0x0d
    2372:	8c 87       	std	Y+12, r24	; 0x0c

                /* If the task is in the blocked or suspended list we need do
                 * nothing more than change its priority variable. However, if
                 * the task is in a ready list it needs to be removed and placed
                 * in the list appropriate to its new priority. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    2374:	89 e0       	ldi	r24, 0x09	; 9
    2376:	38 9f       	mul	r19, r24
    2378:	c0 01       	movw	r24, r0
    237a:	11 24       	eor	r1, r1
    237c:	87 59       	subi	r24, 0x97	; 151
    237e:	9e 4f       	sbci	r25, 0xFE	; 254
    2380:	2a 85       	ldd	r18, Y+10	; 0x0a
    2382:	3b 85       	ldd	r19, Y+11	; 0x0b
    2384:	28 17       	cp	r18, r24
    2386:	39 07       	cpc	r19, r25
    2388:	b1 f4       	brne	.+44     	; 0x23b6 <vTaskPrioritySet+0xca>
                {
                    /* The task is currently in its ready list - remove before
                     * adding it to it's new ready list.  As we are in a critical
                     * section we can do this even if the scheduler is suspended. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    238a:	8e 01       	movw	r16, r28
    238c:	0e 5f       	subi	r16, 0xFE	; 254
    238e:	1f 4f       	sbci	r17, 0xFF	; 255
    2390:	c8 01       	movw	r24, r16
    2392:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    prvAddTaskToReadyList( pxTCB );
    2396:	9e 89       	ldd	r25, Y+22	; 0x16
    2398:	80 91 5a 01 	lds	r24, 0x015A
    239c:	89 17       	cp	r24, r25
    239e:	10 f4       	brcc	.+4      	; 0x23a4 <vTaskPrioritySet+0xb8>
    23a0:	90 93 5a 01 	sts	0x015A, r25
    23a4:	89 e0       	ldi	r24, 0x09	; 9
    23a6:	98 9f       	mul	r25, r24
    23a8:	c0 01       	movw	r24, r0
    23aa:	11 24       	eor	r1, r1
    23ac:	87 59       	subi	r24, 0x97	; 151
    23ae:	9e 4f       	sbci	r25, 0xFE	; 254
    23b0:	b8 01       	movw	r22, r16
    23b2:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                if( xYieldRequired != pdFALSE )
    23b6:	ff 20       	and	r15, r15
    23b8:	11 f0       	breq	.+4      	; 0x23be <vTaskPrioritySet+0xd2>
                {
                    taskYIELD_IF_USING_PREEMPTION();
    23ba:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
                /* Remove compiler warning about unused variables when the port
                 * optimised task selection is not being used. */
                ( void ) uxPriorityUsedOnEntry;
            }
        }
        taskEXIT_CRITICAL();
    23be:	0f 90       	pop	r0
    23c0:	0f be       	out	0x3f, r0	; 63
    }
    23c2:	df 91       	pop	r29
    23c4:	cf 91       	pop	r28
    23c6:	1f 91       	pop	r17
    23c8:	0f 91       	pop	r16
    23ca:	ff 90       	pop	r15
    23cc:	08 95       	ret

000023ce <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    23ce:	ff 92       	push	r15
    23d0:	0f 93       	push	r16
    23d2:	1f 93       	push	r17
    23d4:	cf 93       	push	r28
    23d6:	df 93       	push	r29
    23d8:	ec 01       	movw	r28, r24
    23da:	f6 2e       	mov	r15, r22
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    23dc:	00 91 5c 01 	lds	r16, 0x015C
    23e0:	10 91 5d 01 	lds	r17, 0x015D
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    23e4:	80 91 57 01 	lds	r24, 0x0157
    23e8:	90 91 58 01 	lds	r25, 0x0158
    23ec:	02 96       	adiw	r24, 0x02	; 2
    23ee:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    23f2:	8f ef       	ldi	r24, 0xFF	; 255
    23f4:	cf 3f       	cpi	r28, 0xFF	; 255
    23f6:	d8 07       	cpc	r29, r24
    23f8:	69 f4       	brne	.+26     	; 0x2414 <prvAddCurrentTaskToDelayedList+0x46>
    23fa:	ff 20       	and	r15, r15
    23fc:	59 f0       	breq	.+22     	; 0x2414 <prvAddCurrentTaskToDelayedList+0x46>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    23fe:	60 91 57 01 	lds	r22, 0x0157
    2402:	70 91 58 01 	lds	r23, 0x0158
    2406:	6e 5f       	subi	r22, 0xFE	; 254
    2408:	7f 4f       	sbci	r23, 0xFF	; 255
    240a:	85 eb       	ldi	r24, 0xB5	; 181
    240c:	91 e0       	ldi	r25, 0x01	; 1
    240e:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
    2412:	2f c0       	rjmp	.+94     	; 0x2472 <prvAddCurrentTaskToDelayedList+0xa4>
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
    2414:	c0 0f       	add	r28, r16
    2416:	d1 1f       	adc	r29, r17

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    2418:	e0 91 57 01 	lds	r30, 0x0157
    241c:	f0 91 58 01 	lds	r31, 0x0158
    2420:	d3 83       	std	Z+3, r29	; 0x03
    2422:	c2 83       	std	Z+2, r28	; 0x02

                if( xTimeToWake < xConstTickCount )
    2424:	c0 17       	cp	r28, r16
    2426:	d1 07       	cpc	r29, r17
    2428:	68 f4       	brcc	.+26     	; 0x2444 <prvAddCurrentTaskToDelayedList+0x76>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    242a:	80 91 a1 01 	lds	r24, 0x01A1
    242e:	90 91 a2 01 	lds	r25, 0x01A2
    2432:	60 91 57 01 	lds	r22, 0x0157
    2436:	70 91 58 01 	lds	r23, 0x0158
    243a:	6e 5f       	subi	r22, 0xFE	; 254
    243c:	7f 4f       	sbci	r23, 0xFF	; 255
    243e:	0e 94 7e 1b 	call	0x36fc	; 0x36fc <vListInsert>
    2442:	17 c0       	rjmp	.+46     	; 0x2472 <prvAddCurrentTaskToDelayedList+0xa4>
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    2444:	80 91 9f 01 	lds	r24, 0x019F
    2448:	90 91 a0 01 	lds	r25, 0x01A0
    244c:	60 91 57 01 	lds	r22, 0x0157
    2450:	70 91 58 01 	lds	r23, 0x0158
    2454:	6e 5f       	subi	r22, 0xFE	; 254
    2456:	7f 4f       	sbci	r23, 0xFF	; 255
    2458:	0e 94 7e 1b 	call	0x36fc	; 0x36fc <vListInsert>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
    245c:	80 91 5e 01 	lds	r24, 0x015E
    2460:	90 91 5f 01 	lds	r25, 0x015F
    2464:	c8 17       	cp	r28, r24
    2466:	d9 07       	cpc	r29, r25
    2468:	20 f4       	brcc	.+8      	; 0x2472 <prvAddCurrentTaskToDelayedList+0xa4>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
    246a:	d0 93 5f 01 	sts	0x015F, r29
    246e:	c0 93 5e 01 	sts	0x015E, r28

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    2472:	df 91       	pop	r29
    2474:	cf 91       	pop	r28
    2476:	1f 91       	pop	r17
    2478:	0f 91       	pop	r16
    247a:	ff 90       	pop	r15
    247c:	08 95       	ret

0000247e <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    247e:	8f 92       	push	r8
    2480:	9f 92       	push	r9
    2482:	af 92       	push	r10
    2484:	bf 92       	push	r11
    2486:	cf 92       	push	r12
    2488:	df 92       	push	r13
    248a:	ef 92       	push	r14
    248c:	ff 92       	push	r15
    248e:	0f 93       	push	r16
    2490:	1f 93       	push	r17
    2492:	cf 93       	push	r28
    2494:	df 93       	push	r29
    2496:	48 01       	movw	r8, r16
    2498:	59 01       	movw	r10, r18
    249a:	e7 01       	movw	r28, r14
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    249c:	0f b6       	in	r0, 0x3f	; 63
    249e:	f8 94       	cli
    24a0:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    24a2:	e0 91 57 01 	lds	r30, 0x0157
    24a6:	f0 91 58 01 	lds	r31, 0x0158
    24aa:	e8 2e       	mov	r14, r24
    24ac:	ff 24       	eor	r15, r15
    24ae:	ee 0d       	add	r30, r14
    24b0:	ff 1d       	adc	r31, r15
    24b2:	87 a1       	ldd	r24, Z+39	; 0x27
    24b4:	82 30       	cpi	r24, 0x02	; 2
    24b6:	61 f1       	breq	.+88     	; 0x2510 <xTaskGenericNotifyWait+0x92>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    24b8:	e0 91 57 01 	lds	r30, 0x0157
    24bc:	f0 91 58 01 	lds	r31, 0x0158
    24c0:	c7 01       	movw	r24, r14
    24c2:	88 0f       	add	r24, r24
    24c4:	99 1f       	adc	r25, r25
    24c6:	88 0f       	add	r24, r24
    24c8:	99 1f       	adc	r25, r25
    24ca:	e8 0f       	add	r30, r24
    24cc:	f9 1f       	adc	r31, r25
    24ce:	83 a1       	ldd	r24, Z+35	; 0x23
    24d0:	94 a1       	ldd	r25, Z+36	; 0x24
    24d2:	a5 a1       	ldd	r26, Z+37	; 0x25
    24d4:	b6 a1       	ldd	r27, Z+38	; 0x26
    24d6:	40 95       	com	r20
    24d8:	50 95       	com	r21
    24da:	60 95       	com	r22
    24dc:	70 95       	com	r23
    24de:	84 23       	and	r24, r20
    24e0:	95 23       	and	r25, r21
    24e2:	a6 23       	and	r26, r22
    24e4:	b7 23       	and	r27, r23
    24e6:	83 a3       	std	Z+35, r24	; 0x23
    24e8:	94 a3       	std	Z+36, r25	; 0x24
    24ea:	a5 a3       	std	Z+37, r26	; 0x25
    24ec:	b6 a3       	std	Z+38, r27	; 0x26

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    24ee:	e0 91 57 01 	lds	r30, 0x0157
    24f2:	f0 91 58 01 	lds	r31, 0x0158
    24f6:	ee 0d       	add	r30, r14
    24f8:	ff 1d       	adc	r31, r15
    24fa:	81 e0       	ldi	r24, 0x01	; 1
    24fc:	87 a3       	std	Z+39, r24	; 0x27

                if( xTicksToWait > ( TickType_t ) 0 )
    24fe:	c1 14       	cp	r12, r1
    2500:	d1 04       	cpc	r13, r1
    2502:	31 f0       	breq	.+12     	; 0x2510 <xTaskGenericNotifyWait+0x92>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2504:	c6 01       	movw	r24, r12
    2506:	61 e0       	ldi	r22, 0x01	; 1
    2508:	0e 94 e7 11 	call	0x23ce	; 0x23ce <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    250c:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2510:	0f 90       	pop	r0
    2512:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    2514:	0f b6       	in	r0, 0x3f	; 63
    2516:	f8 94       	cli
    2518:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    251a:	20 97       	sbiw	r28, 0x00	; 0
    251c:	99 f0       	breq	.+38     	; 0x2544 <xTaskGenericNotifyWait+0xc6>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    251e:	e0 91 57 01 	lds	r30, 0x0157
    2522:	f0 91 58 01 	lds	r31, 0x0158
    2526:	c7 01       	movw	r24, r14
    2528:	88 0f       	add	r24, r24
    252a:	99 1f       	adc	r25, r25
    252c:	88 0f       	add	r24, r24
    252e:	99 1f       	adc	r25, r25
    2530:	e8 0f       	add	r30, r24
    2532:	f9 1f       	adc	r31, r25
    2534:	83 a1       	ldd	r24, Z+35	; 0x23
    2536:	94 a1       	ldd	r25, Z+36	; 0x24
    2538:	a5 a1       	ldd	r26, Z+37	; 0x25
    253a:	b6 a1       	ldd	r27, Z+38	; 0x26
    253c:	88 83       	st	Y, r24
    253e:	99 83       	std	Y+1, r25	; 0x01
    2540:	aa 83       	std	Y+2, r26	; 0x02
    2542:	bb 83       	std	Y+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    2544:	e0 91 57 01 	lds	r30, 0x0157
    2548:	f0 91 58 01 	lds	r31, 0x0158
    254c:	ee 0d       	add	r30, r14
    254e:	ff 1d       	adc	r31, r15
    2550:	87 a1       	ldd	r24, Z+39	; 0x27
    2552:	82 30       	cpi	r24, 0x02	; 2
    2554:	11 f0       	breq	.+4      	; 0x255a <xTaskGenericNotifyWait+0xdc>
    2556:	80 e0       	ldi	r24, 0x00	; 0
    2558:	1c c0       	rjmp	.+56     	; 0x2592 <xTaskGenericNotifyWait+0x114>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    255a:	e0 91 57 01 	lds	r30, 0x0157
    255e:	f0 91 58 01 	lds	r31, 0x0158
    2562:	c7 01       	movw	r24, r14
    2564:	88 0f       	add	r24, r24
    2566:	99 1f       	adc	r25, r25
    2568:	88 0f       	add	r24, r24
    256a:	99 1f       	adc	r25, r25
    256c:	e8 0f       	add	r30, r24
    256e:	f9 1f       	adc	r31, r25
    2570:	83 a1       	ldd	r24, Z+35	; 0x23
    2572:	94 a1       	ldd	r25, Z+36	; 0x24
    2574:	a5 a1       	ldd	r26, Z+37	; 0x25
    2576:	b6 a1       	ldd	r27, Z+38	; 0x26
    2578:	80 94       	com	r8
    257a:	90 94       	com	r9
    257c:	a0 94       	com	r10
    257e:	b0 94       	com	r11
    2580:	88 21       	and	r24, r8
    2582:	99 21       	and	r25, r9
    2584:	aa 21       	and	r26, r10
    2586:	bb 21       	and	r27, r11
    2588:	83 a3       	std	Z+35, r24	; 0x23
    258a:	94 a3       	std	Z+36, r25	; 0x24
    258c:	a5 a3       	std	Z+37, r26	; 0x25
    258e:	b6 a3       	std	Z+38, r27	; 0x26
    2590:	81 e0       	ldi	r24, 0x01	; 1
                xReturn = pdTRUE;
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    2592:	e0 91 57 01 	lds	r30, 0x0157
    2596:	f0 91 58 01 	lds	r31, 0x0158
    259a:	ee 0d       	add	r30, r14
    259c:	ff 1d       	adc	r31, r15
    259e:	17 a2       	std	Z+39, r1	; 0x27
        }
        taskEXIT_CRITICAL();
    25a0:	0f 90       	pop	r0
    25a2:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    25a4:	df 91       	pop	r29
    25a6:	cf 91       	pop	r28
    25a8:	1f 91       	pop	r17
    25aa:	0f 91       	pop	r16
    25ac:	ff 90       	pop	r15
    25ae:	ef 90       	pop	r14
    25b0:	df 90       	pop	r13
    25b2:	cf 90       	pop	r12
    25b4:	bf 90       	pop	r11
    25b6:	af 90       	pop	r10
    25b8:	9f 90       	pop	r9
    25ba:	8f 90       	pop	r8
    25bc:	08 95       	ret

000025be <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    25be:	1f 93       	push	r17
    25c0:	cf 93       	push	r28
    25c2:	df 93       	push	r29
    25c4:	16 2f       	mov	r17, r22
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    25c6:	0f b6       	in	r0, 0x3f	; 63
    25c8:	f8 94       	cli
    25ca:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    25cc:	e0 91 57 01 	lds	r30, 0x0157
    25d0:	f0 91 58 01 	lds	r31, 0x0158
    25d4:	c8 2f       	mov	r28, r24
    25d6:	d0 e0       	ldi	r29, 0x00	; 0
    25d8:	ce 01       	movw	r24, r28
    25da:	88 0f       	add	r24, r24
    25dc:	99 1f       	adc	r25, r25
    25de:	88 0f       	add	r24, r24
    25e0:	99 1f       	adc	r25, r25
    25e2:	e8 0f       	add	r30, r24
    25e4:	f9 1f       	adc	r31, r25
    25e6:	83 a1       	ldd	r24, Z+35	; 0x23
    25e8:	94 a1       	ldd	r25, Z+36	; 0x24
    25ea:	a5 a1       	ldd	r26, Z+37	; 0x25
    25ec:	b6 a1       	ldd	r27, Z+38	; 0x26
    25ee:	00 97       	sbiw	r24, 0x00	; 0
    25f0:	a1 05       	cpc	r26, r1
    25f2:	b1 05       	cpc	r27, r1
    25f4:	89 f4       	brne	.+34     	; 0x2618 <ulTaskGenericNotifyTake+0x5a>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    25f6:	e0 91 57 01 	lds	r30, 0x0157
    25fa:	f0 91 58 01 	lds	r31, 0x0158
    25fe:	ec 0f       	add	r30, r28
    2600:	fd 1f       	adc	r31, r29
    2602:	81 e0       	ldi	r24, 0x01	; 1
    2604:	87 a3       	std	Z+39, r24	; 0x27

                if( xTicksToWait > ( TickType_t ) 0 )
    2606:	41 15       	cp	r20, r1
    2608:	51 05       	cpc	r21, r1
    260a:	31 f0       	breq	.+12     	; 0x2618 <ulTaskGenericNotifyTake+0x5a>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    260c:	ca 01       	movw	r24, r20
    260e:	61 e0       	ldi	r22, 0x01	; 1
    2610:	0e 94 e7 11 	call	0x23ce	; 0x23ce <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    2614:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2618:	0f 90       	pop	r0
    261a:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    261c:	0f b6       	in	r0, 0x3f	; 63
    261e:	f8 94       	cli
    2620:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    2622:	e0 91 57 01 	lds	r30, 0x0157
    2626:	f0 91 58 01 	lds	r31, 0x0158
    262a:	ce 01       	movw	r24, r28
    262c:	88 0f       	add	r24, r24
    262e:	99 1f       	adc	r25, r25
    2630:	88 0f       	add	r24, r24
    2632:	99 1f       	adc	r25, r25
    2634:	e8 0f       	add	r30, r24
    2636:	f9 1f       	adc	r31, r25
    2638:	23 a1       	ldd	r18, Z+35	; 0x23
    263a:	34 a1       	ldd	r19, Z+36	; 0x24
    263c:	45 a1       	ldd	r20, Z+37	; 0x25
    263e:	56 a1       	ldd	r21, Z+38	; 0x26

            if( ulReturn != 0UL )
    2640:	21 15       	cp	r18, r1
    2642:	31 05       	cpc	r19, r1
    2644:	41 05       	cpc	r20, r1
    2646:	51 05       	cpc	r21, r1
    2648:	f9 f0       	breq	.+62     	; 0x2688 <ulTaskGenericNotifyTake+0xca>
            {
                if( xClearCountOnExit != pdFALSE )
    264a:	11 23       	and	r17, r17
    264c:	59 f0       	breq	.+22     	; 0x2664 <ulTaskGenericNotifyTake+0xa6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    264e:	e0 91 57 01 	lds	r30, 0x0157
    2652:	f0 91 58 01 	lds	r31, 0x0158
    2656:	e8 0f       	add	r30, r24
    2658:	f9 1f       	adc	r31, r25
    265a:	13 a2       	std	Z+35, r1	; 0x23
    265c:	14 a2       	std	Z+36, r1	; 0x24
    265e:	15 a2       	std	Z+37, r1	; 0x25
    2660:	16 a2       	std	Z+38, r1	; 0x26
    2662:	12 c0       	rjmp	.+36     	; 0x2688 <ulTaskGenericNotifyTake+0xca>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    2664:	e0 91 57 01 	lds	r30, 0x0157
    2668:	f0 91 58 01 	lds	r31, 0x0158
    266c:	21 50       	subi	r18, 0x01	; 1
    266e:	30 40       	sbci	r19, 0x00	; 0
    2670:	40 40       	sbci	r20, 0x00	; 0
    2672:	50 40       	sbci	r21, 0x00	; 0
    2674:	e8 0f       	add	r30, r24
    2676:	f9 1f       	adc	r31, r25
    2678:	23 a3       	std	Z+35, r18	; 0x23
    267a:	34 a3       	std	Z+36, r19	; 0x24
    267c:	45 a3       	std	Z+37, r20	; 0x25
    267e:	56 a3       	std	Z+38, r21	; 0x26
    2680:	2f 5f       	subi	r18, 0xFF	; 255
    2682:	3f 4f       	sbci	r19, 0xFF	; 255
    2684:	4f 4f       	sbci	r20, 0xFF	; 255
    2686:	5f 4f       	sbci	r21, 0xFF	; 255
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    2688:	e0 91 57 01 	lds	r30, 0x0157
    268c:	f0 91 58 01 	lds	r31, 0x0158
    2690:	ec 0f       	add	r30, r28
    2692:	fd 1f       	adc	r31, r29
    2694:	17 a2       	std	Z+39, r1	; 0x27
        }
        taskEXIT_CRITICAL();
    2696:	0f 90       	pop	r0
    2698:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    269a:	b9 01       	movw	r22, r18
    269c:	ca 01       	movw	r24, r20
    269e:	df 91       	pop	r29
    26a0:	cf 91       	pop	r28
    26a2:	1f 91       	pop	r17
    26a4:	08 95       	ret

000026a6 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    26a6:	0f 93       	push	r16
    26a8:	1f 93       	push	r17
    26aa:	8a 01       	movw	r16, r20
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    26ac:	e0 91 57 01 	lds	r30, 0x0157
    26b0:	f0 91 58 01 	lds	r31, 0x0158
    26b4:	70 68       	ori	r23, 0x80	; 128
    26b6:	75 87       	std	Z+13, r23	; 0x0d
    26b8:	64 87       	std	Z+12, r22	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    26ba:	60 91 57 01 	lds	r22, 0x0157
    26be:	70 91 58 01 	lds	r23, 0x0158
    26c2:	64 5f       	subi	r22, 0xF4	; 244
    26c4:	7f 4f       	sbci	r23, 0xFF	; 255
    26c6:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    26ca:	c8 01       	movw	r24, r16
    26cc:	61 e0       	ldi	r22, 0x01	; 1
    26ce:	0e 94 e7 11 	call	0x23ce	; 0x23ce <prvAddCurrentTaskToDelayedList>
}
    26d2:	1f 91       	pop	r17
    26d4:	0f 91       	pop	r16
    26d6:	08 95       	ret

000026d8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    26d8:	9c 01       	movw	r18, r24
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    26da:	00 97       	sbiw	r24, 0x00	; 0
    26dc:	69 f0       	breq	.+26     	; 0x26f8 <vTaskDelay+0x20>
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    26de:	80 91 59 01 	lds	r24, 0x0159
    26e2:	8f 5f       	subi	r24, 0xFF	; 255
    26e4:	80 93 59 01 	sts	0x0159, r24
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    26e8:	c9 01       	movw	r24, r18
    26ea:	60 e0       	ldi	r22, 0x00	; 0
    26ec:	0e 94 e7 11 	call	0x23ce	; 0x23ce <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    26f0:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    26f4:	88 23       	and	r24, r24
    26f6:	11 f4       	brne	.+4      	; 0x26fc <vTaskDelay+0x24>
        {
            portYIELD_WITHIN_API();
    26f8:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
    26fc:	08 95       	ret

000026fe <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    26fe:	1f 93       	push	r17
    2700:	fc 01       	movw	r30, r24
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    2702:	80 91 59 01 	lds	r24, 0x0159
    2706:	8f 5f       	subi	r24, 0xFF	; 255
    2708:	80 93 59 01 	sts	0x0159, r24

        vTaskSuspendAll();
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    270c:	80 91 5c 01 	lds	r24, 0x015C
    2710:	90 91 5d 01 	lds	r25, 0x015D

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2714:	20 81       	ld	r18, Z
    2716:	31 81       	ldd	r19, Z+1	; 0x01
    2718:	62 0f       	add	r22, r18
    271a:	73 1f       	adc	r23, r19

            if( xConstTickCount < *pxPreviousWakeTime )
    271c:	82 17       	cp	r24, r18
    271e:	93 07       	cpc	r25, r19
    2720:	28 f4       	brcc	.+10     	; 0x272c <xTaskDelayUntil+0x2e>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2722:	62 17       	cp	r22, r18
    2724:	73 07       	cpc	r23, r19
    2726:	28 f0       	brcs	.+10     	; 0x2732 <xTaskDelayUntil+0x34>
    2728:	10 e0       	ldi	r17, 0x00	; 0
    272a:	08 c0       	rjmp	.+16     	; 0x273c <xTaskDelayUntil+0x3e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    272c:	62 17       	cp	r22, r18
    272e:	73 07       	cpc	r23, r19
    2730:	20 f0       	brcs	.+8      	; 0x273a <xTaskDelayUntil+0x3c>
    2732:	10 e0       	ldi	r17, 0x00	; 0
    2734:	86 17       	cp	r24, r22
    2736:	97 07       	cpc	r25, r23
    2738:	08 f4       	brcc	.+2      	; 0x273c <xTaskDelayUntil+0x3e>
    273a:	11 e0       	ldi	r17, 0x01	; 1
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    273c:	71 83       	std	Z+1, r23	; 0x01
    273e:	60 83       	st	Z, r22

            if( xShouldDelay != pdFALSE )
    2740:	11 23       	and	r17, r17
    2742:	39 f0       	breq	.+14     	; 0x2752 <xTaskDelayUntil+0x54>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    2744:	9b 01       	movw	r18, r22
    2746:	28 1b       	sub	r18, r24
    2748:	39 0b       	sbc	r19, r25
    274a:	c9 01       	movw	r24, r18
    274c:	60 e0       	ldi	r22, 0x00	; 0
    274e:	0e 94 e7 11 	call	0x23ce	; 0x23ce <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    2752:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    2756:	88 23       	and	r24, r24
    2758:	11 f4       	brne	.+4      	; 0x275e <xTaskDelayUntil+0x60>
        {
            portYIELD_WITHIN_API();
    275a:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    }
    275e:	81 2f       	mov	r24, r17
    2760:	1f 91       	pop	r17
    2762:	08 95       	ret

00002764 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    2764:	0f 93       	push	r16
    2766:	1f 93       	push	r17
    2768:	8b 01       	movw	r16, r22

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    276a:	60 91 57 01 	lds	r22, 0x0157
    276e:	70 91 58 01 	lds	r23, 0x0158
    2772:	64 5f       	subi	r22, 0xF4	; 244
    2774:	7f 4f       	sbci	r23, 0xFF	; 255
    2776:	0e 94 7e 1b 	call	0x36fc	; 0x36fc <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    277a:	c8 01       	movw	r24, r16
    277c:	61 e0       	ldi	r22, 0x01	; 1
    277e:	0e 94 e7 11 	call	0x23ce	; 0x23ce <prvAddCurrentTaskToDelayedList>
}
    2782:	1f 91       	pop	r17
    2784:	0f 91       	pop	r16
    2786:	08 95       	ret

00002788 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    2788:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    278a:	10 92 64 01 	sts	0x0164, r1
    vPortEndScheduler();
    278e:	0e 94 67 1e 	call	0x3cce	; 0x3cce <vPortEndScheduler>
}
    2792:	08 95       	ret

00002794 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2794:	0f 93       	push	r16
    2796:	1f 93       	push	r17
    2798:	21 c0       	rjmp	.+66     	; 0x27dc <prvIdleTask+0x48>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    279a:	0f b6       	in	r0, 0x3f	; 63
    279c:	f8 94       	cli
    279e:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    27a0:	e0 91 b1 01 	lds	r30, 0x01B1
    27a4:	f0 91 b2 01 	lds	r31, 0x01B2
    27a8:	06 81       	ldd	r16, Z+6	; 0x06
    27aa:	17 81       	ldd	r17, Z+7	; 0x07
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    27ac:	c8 01       	movw	r24, r16
    27ae:	02 96       	adiw	r24, 0x02	; 2
    27b0:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                    --uxCurrentNumberOfTasks;
    27b4:	80 91 63 01 	lds	r24, 0x0163
    27b8:	81 50       	subi	r24, 0x01	; 1
    27ba:	80 93 63 01 	sts	0x0163, r24
                    --uxDeletedTasksWaitingCleanUp;
    27be:	80 91 67 01 	lds	r24, 0x0167
    27c2:	81 50       	subi	r24, 0x01	; 1
    27c4:	80 93 67 01 	sts	0x0167, r24
                }
                taskEXIT_CRITICAL();
    27c8:	0f 90       	pop	r0
    27ca:	0f be       	out	0x3f, r0	; 63

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
    27cc:	f8 01       	movw	r30, r16
    27ce:	87 89       	ldd	r24, Z+23	; 0x17
    27d0:	90 8d       	ldd	r25, Z+24	; 0x18
    27d2:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <vPortFree>
                vPortFree( pxTCB );
    27d6:	c8 01       	movw	r24, r16
    27d8:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <vPortFree>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    27dc:	80 91 67 01 	lds	r24, 0x0167
    27e0:	88 23       	and	r24, r24
    27e2:	d9 f6       	brne	.-74     	; 0x279a <prvIdleTask+0x6>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    27e4:	80 91 69 01 	lds	r24, 0x0169
    27e8:	82 30       	cpi	r24, 0x02	; 2
    27ea:	c0 f3       	brcs	.-16     	; 0x27dc <prvIdleTask+0x48>
                {
                    taskYIELD();
    27ec:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
    27f0:	f5 cf       	rjmp	.-22     	; 0x27dc <prvIdleTask+0x48>

000027f2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    27f2:	0f 93       	push	r16
    27f4:	1f 93       	push	r17
    27f6:	cf 93       	push	r28
    27f8:	df 93       	push	r29
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    27fa:	0f b6       	in	r0, 0x3f	; 63
    27fc:	f8 94       	cli
    27fe:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    2800:	00 97       	sbiw	r24, 0x00	; 0
    2802:	11 f0       	breq	.+4      	; 0x2808 <vTaskDelete+0x16>
    2804:	ec 01       	movw	r28, r24
    2806:	04 c0       	rjmp	.+8      	; 0x2810 <vTaskDelete+0x1e>
    2808:	c0 91 57 01 	lds	r28, 0x0157
    280c:	d0 91 58 01 	lds	r29, 0x0158

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2810:	8e 01       	movw	r16, r28
    2812:	0e 5f       	subi	r16, 0xFE	; 254
    2814:	1f 4f       	sbci	r17, 0xFF	; 255
    2816:	c8 01       	movw	r24, r16
    2818:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    281c:	8c 89       	ldd	r24, Y+20	; 0x14
    281e:	9d 89       	ldd	r25, Y+21	; 0x15
    2820:	89 2b       	or	r24, r25
    2822:	21 f0       	breq	.+8      	; 0x282c <vTaskDelete+0x3a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2824:	ce 01       	movw	r24, r28
    2826:	0c 96       	adiw	r24, 0x0c	; 12
    2828:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    282c:	80 91 68 01 	lds	r24, 0x0168
    2830:	8f 5f       	subi	r24, 0xFF	; 255
    2832:	80 93 68 01 	sts	0x0168, r24

            if( pxTCB == pxCurrentTCB )
    2836:	80 91 57 01 	lds	r24, 0x0157
    283a:	90 91 58 01 	lds	r25, 0x0158
    283e:	c8 17       	cp	r28, r24
    2840:	d9 07       	cpc	r29, r25
    2842:	59 f4       	brne	.+22     	; 0x285a <vTaskDelete+0x68>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    2844:	8c ea       	ldi	r24, 0xAC	; 172
    2846:	91 e0       	ldi	r25, 0x01	; 1
    2848:	b8 01       	movw	r22, r16
    284a:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    284e:	80 91 67 01 	lds	r24, 0x0167
    2852:	8f 5f       	subi	r24, 0xFF	; 255
    2854:	80 93 67 01 	sts	0x0167, r24
    2858:	1c c0       	rjmp	.+56     	; 0x2892 <vTaskDelete+0xa0>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    285a:	80 91 63 01 	lds	r24, 0x0163
    285e:	81 50       	subi	r24, 0x01	; 1
    2860:	80 93 63 01 	sts	0x0163, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2864:	e0 91 9f 01 	lds	r30, 0x019F
    2868:	f0 91 a0 01 	lds	r31, 0x01A0
    286c:	80 81       	ld	r24, Z
    286e:	88 23       	and	r24, r24
    2870:	19 f4       	brne	.+6      	; 0x2878 <vTaskDelete+0x86>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    2872:	8f ef       	ldi	r24, 0xFF	; 255
    2874:	9f ef       	ldi	r25, 0xFF	; 255
    2876:	09 c0       	rjmp	.+18     	; 0x288a <vTaskDelete+0x98>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    2878:	e0 91 9f 01 	lds	r30, 0x019F
    287c:	f0 91 a0 01 	lds	r31, 0x01A0
    2880:	05 80       	ldd	r0, Z+5	; 0x05
    2882:	f6 81       	ldd	r31, Z+6	; 0x06
    2884:	e0 2d       	mov	r30, r0
    2886:	80 81       	ld	r24, Z
    2888:	91 81       	ldd	r25, Z+1	; 0x01
    288a:	90 93 5f 01 	sts	0x015F, r25
    288e:	80 93 5e 01 	sts	0x015E, r24
                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
            }
        }
        taskEXIT_CRITICAL();
    2892:	0f 90       	pop	r0
    2894:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    2896:	80 91 57 01 	lds	r24, 0x0157
    289a:	90 91 58 01 	lds	r25, 0x0158
    289e:	c8 17       	cp	r28, r24
    28a0:	d9 07       	cpc	r29, r25
    28a2:	39 f0       	breq	.+14     	; 0x28b2 <vTaskDelete+0xc0>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
    28a4:	8f 89       	ldd	r24, Y+23	; 0x17
    28a6:	98 8d       	ldd	r25, Y+24	; 0x18
    28a8:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <vPortFree>
                vPortFree( pxTCB );
    28ac:	ce 01       	movw	r24, r28
    28ae:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <vPortFree>
            prvDeleteTCB( pxTCB );
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    28b2:	80 91 64 01 	lds	r24, 0x0164
    28b6:	88 23       	and	r24, r24
    28b8:	49 f0       	breq	.+18     	; 0x28cc <vTaskDelete+0xda>
        {
            if( pxTCB == pxCurrentTCB )
    28ba:	80 91 57 01 	lds	r24, 0x0157
    28be:	90 91 58 01 	lds	r25, 0x0158
    28c2:	c8 17       	cp	r28, r24
    28c4:	d9 07       	cpc	r29, r25
    28c6:	11 f4       	brne	.+4      	; 0x28cc <vTaskDelete+0xda>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    28c8:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    28cc:	df 91       	pop	r29
    28ce:	cf 91       	pop	r28
    28d0:	1f 91       	pop	r17
    28d2:	0f 91       	pop	r16
    28d4:	08 95       	ret

000028d6 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    28d6:	4f 92       	push	r4
    28d8:	5f 92       	push	r5
    28da:	6f 92       	push	r6
    28dc:	7f 92       	push	r7
    28de:	8f 92       	push	r8
    28e0:	9f 92       	push	r9
    28e2:	af 92       	push	r10
    28e4:	bf 92       	push	r11
    28e6:	cf 92       	push	r12
    28e8:	df 92       	push	r13
    28ea:	ef 92       	push	r14
    28ec:	ff 92       	push	r15
    28ee:	0f 93       	push	r16
    28f0:	1f 93       	push	r17
    28f2:	cf 93       	push	r28
    28f4:	df 93       	push	r29
    28f6:	2c 01       	movw	r4, r24
    28f8:	5b 01       	movw	r10, r22
    28fa:	6a 01       	movw	r12, r20
    28fc:	39 01       	movw	r6, r18
    28fe:	47 01       	movw	r8, r14
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2900:	ca 01       	movw	r24, r20
    2902:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <pvPortMalloc>
    2906:	7c 01       	movw	r14, r24

                if( pxStack != NULL )
    2908:	00 97       	sbiw	r24, 0x00	; 0
    290a:	81 f0       	breq	.+32     	; 0x292c <xTaskCreate+0x56>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    290c:	88 e2       	ldi	r24, 0x28	; 40
    290e:	90 e0       	ldi	r25, 0x00	; 0
    2910:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <pvPortMalloc>
    2914:	ec 01       	movw	r28, r24

                    if( pxNewTCB != NULL )
    2916:	00 97       	sbiw	r24, 0x00	; 0
    2918:	31 f0       	breq	.+12     	; 0x2926 <xTaskCreate+0x50>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    291a:	f8 8e       	std	Y+24, r15	; 0x18
    291c:	ef 8a       	std	Y+23, r14	; 0x17
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    291e:	a1 14       	cp	r10, r1
    2920:	b1 04       	cpc	r11, r1
    2922:	31 f4       	brne	.+12     	; 0x2930 <xTaskCreate+0x5a>
    2924:	16 c0       	rjmp	.+44     	; 0x2952 <xTaskCreate+0x7c>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
    2926:	c7 01       	movw	r24, r14
    2928:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <vPortFree>
    292c:	8f ef       	ldi	r24, 0xFF	; 255
    292e:	c4 c0       	rjmp	.+392    	; 0x2ab8 <xTaskCreate+0x1e2>
    2930:	f5 01       	movw	r30, r10
    2932:	dc 01       	movw	r26, r24
    2934:	90 e0       	ldi	r25, 0x00	; 0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    2936:	80 81       	ld	r24, Z
    2938:	59 96       	adiw	r26, 0x19	; 25
    293a:	8c 93       	st	X, r24
    293c:	59 97       	sbiw	r26, 0x19	; 25

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    293e:	80 81       	ld	r24, Z
    2940:	88 23       	and	r24, r24
    2942:	29 f0       	breq	.+10     	; 0x294e <xTaskCreate+0x78>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2944:	9f 5f       	subi	r25, 0xFF	; 255
    2946:	31 96       	adiw	r30, 0x01	; 1
    2948:	11 96       	adiw	r26, 0x01	; 1
    294a:	98 30       	cpi	r25, 0x08	; 8
    294c:	a1 f7       	brne	.-24     	; 0x2936 <xTaskCreate+0x60>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    294e:	18 a2       	std	Y+32, r1	; 0x20
    2950:	01 c0       	rjmp	.+2      	; 0x2954 <xTaskCreate+0x7e>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    2952:	19 8e       	std	Y+25, r1	; 0x19
    2954:	04 30       	cpi	r16, 0x04	; 4
    2956:	08 f0       	brcs	.+2      	; 0x295a <xTaskCreate+0x84>
    2958:	03 e0       	ldi	r16, 0x03	; 3
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    295a:	0e 8b       	std	Y+22, r16	; 0x16
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
    295c:	09 a3       	std	Y+33, r16	; 0x21
            pxNewTCB->uxMutexesHeld = 0;
    295e:	1a a2       	std	Y+34, r1	; 0x22
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    2960:	42 e0       	ldi	r20, 0x02	; 2
    2962:	a4 2e       	mov	r10, r20
    2964:	b1 2c       	mov	r11, r1
    2966:	ac 0e       	add	r10, r28
    2968:	bd 1e       	adc	r11, r29
    296a:	c5 01       	movw	r24, r10
    296c:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    2970:	ce 01       	movw	r24, r28
    2972:	0c 96       	adiw	r24, 0x0c	; 12
    2974:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2978:	d9 87       	std	Y+9, r29	; 0x09
    297a:	c8 87       	std	Y+8, r28	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    297c:	84 e0       	ldi	r24, 0x04	; 4
    297e:	90 e0       	ldi	r25, 0x00	; 0
    2980:	80 1b       	sub	r24, r16
    2982:	91 09       	sbc	r25, r1
    2984:	9d 87       	std	Y+13, r25	; 0x0d
    2986:	8c 87       	std	Y+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2988:	db 8b       	std	Y+19, r29	; 0x13
    298a:	ca 8b       	std	Y+18, r28	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    298c:	1b a2       	std	Y+35, r1	; 0x23
    298e:	1c a2       	std	Y+36, r1	; 0x24
    2990:	1d a2       	std	Y+37, r1	; 0x25
    2992:	1e a2       	std	Y+38, r1	; 0x26
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    2994:	1f a2       	std	Y+39, r1	; 0x27
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2996:	08 94       	sec
    2998:	c1 08       	sbc	r12, r1
    299a:	d1 08       	sbc	r13, r1
    299c:	c7 01       	movw	r24, r14
    299e:	8c 0d       	add	r24, r12
    29a0:	9d 1d       	adc	r25, r13
    29a2:	b2 01       	movw	r22, r4
    29a4:	a3 01       	movw	r20, r6
    29a6:	0e 94 e5 1d 	call	0x3bca	; 0x3bca <pxPortInitialiseStack>
    29aa:	99 83       	std	Y+1, r25	; 0x01
    29ac:	88 83       	st	Y, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    29ae:	81 14       	cp	r8, r1
    29b0:	91 04       	cpc	r9, r1
    29b2:	19 f0       	breq	.+6      	; 0x29ba <xTaskCreate+0xe4>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    29b4:	f4 01       	movw	r30, r8
    29b6:	d1 83       	std	Z+1, r29	; 0x01
    29b8:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    29ba:	0f b6       	in	r0, 0x3f	; 63
    29bc:	f8 94       	cli
    29be:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    29c0:	80 91 63 01 	lds	r24, 0x0163
    29c4:	8f 5f       	subi	r24, 0xFF	; 255
    29c6:	80 93 63 01 	sts	0x0163, r24

        if( pxCurrentTCB == NULL )
    29ca:	80 91 57 01 	lds	r24, 0x0157
    29ce:	90 91 58 01 	lds	r25, 0x0158
    29d2:	89 2b       	or	r24, r25
    29d4:	d1 f5       	brne	.+116    	; 0x2a4a <xTaskCreate+0x174>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    29d6:	d0 93 58 01 	sts	0x0158, r29
    29da:	c0 93 57 01 	sts	0x0157, r28

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    29de:	80 91 63 01 	lds	r24, 0x0163
    29e2:	81 30       	cpi	r24, 0x01	; 1
    29e4:	09 f0       	breq	.+2      	; 0x29e8 <xTaskCreate+0x112>
    29e6:	41 c0       	rjmp	.+130    	; 0x2a6a <xTaskCreate+0x194>
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    29e8:	89 e6       	ldi	r24, 0x69	; 105
    29ea:	91 e0       	ldi	r25, 0x01	; 1
    29ec:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
    29f0:	82 e7       	ldi	r24, 0x72	; 114
    29f2:	91 e0       	ldi	r25, 0x01	; 1
    29f4:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
    29f8:	8b e7       	ldi	r24, 0x7B	; 123
    29fa:	91 e0       	ldi	r25, 0x01	; 1
    29fc:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
    2a00:	84 e8       	ldi	r24, 0x84	; 132
    2a02:	91 e0       	ldi	r25, 0x01	; 1
    2a04:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
    }

    vListInitialise( &xDelayedTaskList1 );
    2a08:	3d e8       	ldi	r19, 0x8D	; 141
    2a0a:	e3 2e       	mov	r14, r19
    2a0c:	31 e0       	ldi	r19, 0x01	; 1
    2a0e:	f3 2e       	mov	r15, r19
    2a10:	c7 01       	movw	r24, r14
    2a12:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    2a16:	06 e9       	ldi	r16, 0x96	; 150
    2a18:	11 e0       	ldi	r17, 0x01	; 1
    2a1a:	c8 01       	movw	r24, r16
    2a1c:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    2a20:	83 ea       	ldi	r24, 0xA3	; 163
    2a22:	91 e0       	ldi	r25, 0x01	; 1
    2a24:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    2a28:	8c ea       	ldi	r24, 0xAC	; 172
    2a2a:	91 e0       	ldi	r25, 0x01	; 1
    2a2c:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
    2a30:	85 eb       	ldi	r24, 0xB5	; 181
    2a32:	91 e0       	ldi	r25, 0x01	; 1
    2a34:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    2a38:	f0 92 a0 01 	sts	0x01A0, r15
    2a3c:	e0 92 9f 01 	sts	0x019F, r14
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2a40:	10 93 a2 01 	sts	0x01A2, r17
    2a44:	00 93 a1 01 	sts	0x01A1, r16
    2a48:	10 c0       	rjmp	.+32     	; 0x2a6a <xTaskCreate+0x194>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    2a4a:	80 91 64 01 	lds	r24, 0x0164
    2a4e:	88 23       	and	r24, r24
    2a50:	61 f4       	brne	.+24     	; 0x2a6a <xTaskCreate+0x194>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    2a52:	e0 91 57 01 	lds	r30, 0x0157
    2a56:	f0 91 58 01 	lds	r31, 0x0158
    2a5a:	96 89       	ldd	r25, Z+22	; 0x16
    2a5c:	8e 89       	ldd	r24, Y+22	; 0x16
    2a5e:	89 17       	cp	r24, r25
    2a60:	20 f0       	brcs	.+8      	; 0x2a6a <xTaskCreate+0x194>
                {
                    pxCurrentTCB = pxNewTCB;
    2a62:	d0 93 58 01 	sts	0x0158, r29
    2a66:	c0 93 57 01 	sts	0x0157, r28
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    2a6a:	80 91 68 01 	lds	r24, 0x0168
    2a6e:	8f 5f       	subi	r24, 0xFF	; 255
    2a70:	80 93 68 01 	sts	0x0168, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    2a74:	9e 89       	ldd	r25, Y+22	; 0x16
    2a76:	80 91 5a 01 	lds	r24, 0x015A
    2a7a:	89 17       	cp	r24, r25
    2a7c:	10 f4       	brcc	.+4      	; 0x2a82 <xTaskCreate+0x1ac>
    2a7e:	90 93 5a 01 	sts	0x015A, r25
    2a82:	8e 89       	ldd	r24, Y+22	; 0x16
    2a84:	29 e0       	ldi	r18, 0x09	; 9
    2a86:	82 9f       	mul	r24, r18
    2a88:	c0 01       	movw	r24, r0
    2a8a:	11 24       	eor	r1, r1
    2a8c:	87 59       	subi	r24, 0x97	; 151
    2a8e:	9e 4f       	sbci	r25, 0xFE	; 254
    2a90:	b5 01       	movw	r22, r10
    2a92:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    2a96:	0f 90       	pop	r0
    2a98:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    2a9a:	80 91 64 01 	lds	r24, 0x0164
    2a9e:	88 23       	and	r24, r24
    2aa0:	51 f0       	breq	.+20     	; 0x2ab6 <xTaskCreate+0x1e0>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    2aa2:	e0 91 57 01 	lds	r30, 0x0157
    2aa6:	f0 91 58 01 	lds	r31, 0x0158
    2aaa:	96 89       	ldd	r25, Z+22	; 0x16
    2aac:	8e 89       	ldd	r24, Y+22	; 0x16
    2aae:	98 17       	cp	r25, r24
    2ab0:	10 f4       	brcc	.+4      	; 0x2ab6 <xTaskCreate+0x1e0>
        {
            taskYIELD_IF_USING_PREEMPTION();
    2ab2:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
    2ab6:	81 e0       	ldi	r24, 0x01	; 1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
    2ab8:	df 91       	pop	r29
    2aba:	cf 91       	pop	r28
    2abc:	1f 91       	pop	r17
    2abe:	0f 91       	pop	r16
    2ac0:	ff 90       	pop	r15
    2ac2:	ef 90       	pop	r14
    2ac4:	df 90       	pop	r13
    2ac6:	cf 90       	pop	r12
    2ac8:	bf 90       	pop	r11
    2aca:	af 90       	pop	r10
    2acc:	9f 90       	pop	r9
    2ace:	8f 90       	pop	r8
    2ad0:	7f 90       	pop	r7
    2ad2:	6f 90       	pop	r6
    2ad4:	5f 90       	pop	r5
    2ad6:	4f 90       	pop	r4
    2ad8:	08 95       	ret

00002ada <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2ada:	ef 92       	push	r14
    2adc:	ff 92       	push	r15
    2ade:	0f 93       	push	r16
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    2ae0:	8a ec       	ldi	r24, 0xCA	; 202
    2ae2:	93 e1       	ldi	r25, 0x13	; 19
    2ae4:	65 e2       	ldi	r22, 0x25	; 37
    2ae6:	71 e0       	ldi	r23, 0x01	; 1
    2ae8:	45 e5       	ldi	r20, 0x55	; 85
    2aea:	50 e0       	ldi	r21, 0x00	; 0
    2aec:	20 e0       	ldi	r18, 0x00	; 0
    2aee:	30 e0       	ldi	r19, 0x00	; 0
    2af0:	00 e0       	ldi	r16, 0x00	; 0
    2af2:	e5 e6       	ldi	r30, 0x65	; 101
    2af4:	ee 2e       	mov	r14, r30
    2af6:	e1 e0       	ldi	r30, 0x01	; 1
    2af8:	fe 2e       	mov	r15, r30
    2afa:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <xTaskCreate>
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    2afe:	81 30       	cpi	r24, 0x01	; 1
    2b00:	81 f4       	brne	.+32     	; 0x2b22 <vTaskStartScheduler+0x48>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    2b02:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    2b04:	8f ef       	ldi	r24, 0xFF	; 255
    2b06:	9f ef       	ldi	r25, 0xFF	; 255
    2b08:	90 93 5f 01 	sts	0x015F, r25
    2b0c:	80 93 5e 01 	sts	0x015E, r24
        xSchedulerRunning = pdTRUE;
    2b10:	81 e0       	ldi	r24, 0x01	; 1
    2b12:	80 93 64 01 	sts	0x0164, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    2b16:	10 92 5d 01 	sts	0x015D, r1
    2b1a:	10 92 5c 01 	sts	0x015C, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    2b1e:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    2b22:	80 91 2a 01 	lds	r24, 0x012A
}
    2b26:	0f 91       	pop	r16
    2b28:	ff 90       	pop	r15
    2b2a:	ef 90       	pop	r14
    2b2c:	08 95       	ret

00002b2e <uxQueueMessagesWaiting>:
    return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2b2e:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    2b30:	0f b6       	in	r0, 0x3f	; 63
    2b32:	f8 94       	cli
    2b34:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2b36:	82 8d       	ldd	r24, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    2b38:	0f 90       	pop	r0
    2b3a:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2b3c:	08 95       	ret

00002b3e <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2b3e:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    2b40:	0f b6       	in	r0, 0x3f	; 63
    2b42:	f8 94       	cli
    2b44:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2b46:	92 8d       	ldd	r25, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    2b48:	0f 90       	pop	r0
    2b4a:	0f be       	out	0x3f, r0	; 63
    2b4c:	83 8d       	ldd	r24, Z+27	; 0x1b

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2b4e:	89 1b       	sub	r24, r25
    2b50:	08 95       	ret

00002b52 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2b52:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    2b54:	82 8d       	ldd	r24, Z+26	; 0x1a

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2b56:	08 95       	ret

00002b58 <xQueueIsQueueEmptyFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2b58:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2b5a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b5c:	90 e0       	ldi	r25, 0x00	; 0
    2b5e:	88 23       	and	r24, r24
    2b60:	09 f4       	brne	.+2      	; 0x2b64 <xQueueIsQueueEmptyFromISR+0xc>
    2b62:	91 e0       	ldi	r25, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2b64:	89 2f       	mov	r24, r25
    2b66:	08 95       	ret

00002b68 <xQueueIsQueueFullFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2b68:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2b6a:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b6c:	20 e0       	ldi	r18, 0x00	; 0
    2b6e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2b70:	98 17       	cp	r25, r24
    2b72:	09 f4       	brne	.+2      	; 0x2b76 <xQueueIsQueueFullFromISR+0xe>
    2b74:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2b76:	82 2f       	mov	r24, r18
    2b78:	08 95       	ret

00002b7a <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    2b7a:	fc 01       	movw	r30, r24
    2b7c:	56 2f       	mov	r21, r22
    2b7e:	a7 2f       	mov	r26, r23
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2b80:	24 8d       	ldd	r18, Z+28	; 0x1c
    2b82:	22 23       	and	r18, r18
    2b84:	b9 f0       	breq	.+46     	; 0x2bb4 <prvCopyDataFromQueue+0x3a>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2b86:	86 81       	ldd	r24, Z+6	; 0x06
    2b88:	97 81       	ldd	r25, Z+7	; 0x07
    2b8a:	82 0f       	add	r24, r18
    2b8c:	91 1d       	adc	r25, r1
    2b8e:	97 83       	std	Z+7, r25	; 0x07
    2b90:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2b92:	24 81       	ldd	r18, Z+4	; 0x04
    2b94:	35 81       	ldd	r19, Z+5	; 0x05
    2b96:	82 17       	cp	r24, r18
    2b98:	93 07       	cpc	r25, r19
    2b9a:	20 f0       	brcs	.+8      	; 0x2ba4 <prvCopyDataFromQueue+0x2a>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2b9c:	80 81       	ld	r24, Z
    2b9e:	91 81       	ldd	r25, Z+1	; 0x01
    2ba0:	97 83       	std	Z+7, r25	; 0x07
    2ba2:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2ba4:	44 8d       	ldd	r20, Z+28	; 0x1c
    2ba6:	66 81       	ldd	r22, Z+6	; 0x06
    2ba8:	77 81       	ldd	r23, Z+7	; 0x07
    2baa:	85 2f       	mov	r24, r21
    2bac:	9a 2f       	mov	r25, r26
    2bae:	50 e0       	ldi	r21, 0x00	; 0
    2bb0:	0e 94 76 21 	call	0x42ec	; 0x42ec <memcpy>
    2bb4:	08 95       	ret

00002bb6 <xQueuePeekFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    2bb6:	0f 93       	push	r16
    2bb8:	1f 93       	push	r17
    2bba:	cf 93       	push	r28
    2bbc:	df 93       	push	r29
    2bbe:	ec 01       	movw	r28, r24
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2bc0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2bc2:	88 23       	and	r24, r24
    2bc4:	41 f0       	breq	.+16     	; 0x2bd6 <xQueuePeekFromISR+0x20>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2bc6:	0e 81       	ldd	r16, Y+6	; 0x06
    2bc8:	1f 81       	ldd	r17, Y+7	; 0x07
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2bca:	ce 01       	movw	r24, r28
    2bcc:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2bd0:	1f 83       	std	Y+7, r17	; 0x07
    2bd2:	0e 83       	std	Y+6, r16	; 0x06
    2bd4:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    2bd6:	df 91       	pop	r29
    2bd8:	cf 91       	pop	r28
    2bda:	1f 91       	pop	r17
    2bdc:	0f 91       	pop	r16
    2bde:	08 95       	ret

00002be0 <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    2be0:	0f 93       	push	r16
    2be2:	1f 93       	push	r17
    2be4:	cf 93       	push	r28
    2be6:	df 93       	push	r29
    2be8:	ec 01       	movw	r28, r24
    2bea:	fb 01       	movw	r30, r22
    2bec:	8a 01       	movw	r16, r20
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2bee:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2bf0:	88 23       	and	r24, r24
    2bf2:	61 f1       	breq	.+88     	; 0x2c4c <xQueueCRReceiveFromISR+0x6c>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2bf4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2bf6:	2e 81       	ldd	r18, Y+6	; 0x06
    2bf8:	3f 81       	ldd	r19, Y+7	; 0x07
    2bfa:	28 0f       	add	r18, r24
    2bfc:	31 1d       	adc	r19, r1
    2bfe:	3f 83       	std	Y+7, r19	; 0x07
    2c00:	2e 83       	std	Y+6, r18	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2c02:	8c 81       	ldd	r24, Y+4	; 0x04
    2c04:	9d 81       	ldd	r25, Y+5	; 0x05
    2c06:	28 17       	cp	r18, r24
    2c08:	39 07       	cpc	r19, r25
    2c0a:	20 f0       	brcs	.+8      	; 0x2c14 <xQueueCRReceiveFromISR+0x34>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2c0c:	88 81       	ld	r24, Y
    2c0e:	99 81       	ldd	r25, Y+1	; 0x01
    2c10:	9f 83       	std	Y+7, r25	; 0x07
    2c12:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    2c14:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2c16:	81 50       	subi	r24, 0x01	; 1
    2c18:	8a 8f       	std	Y+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2c1a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2c1c:	6e 81       	ldd	r22, Y+6	; 0x06
    2c1e:	7f 81       	ldd	r23, Y+7	; 0x07
    2c20:	cf 01       	movw	r24, r30
    2c22:	50 e0       	ldi	r21, 0x00	; 0
    2c24:	0e 94 76 21 	call	0x42ec	; 0x42ec <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    2c28:	f8 01       	movw	r30, r16
    2c2a:	80 81       	ld	r24, Z
    2c2c:	88 23       	and	r24, r24
    2c2e:	69 f4       	brne	.+26     	; 0x2c4a <xQueueCRReceiveFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2c30:	88 85       	ldd	r24, Y+8	; 0x08
    2c32:	88 23       	and	r24, r24
    2c34:	51 f0       	breq	.+20     	; 0x2c4a <xQueueCRReceiveFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2c36:	ce 01       	movw	r24, r28
    2c38:	08 96       	adiw	r24, 0x08	; 8
    2c3a:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <xCoRoutineRemoveFromEventList>
    2c3e:	88 23       	and	r24, r24
    2c40:	21 f0       	breq	.+8      	; 0x2c4a <xQueueCRReceiveFromISR+0x6a>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    2c42:	81 e0       	ldi	r24, 0x01	; 1
    2c44:	f8 01       	movw	r30, r16
    2c46:	80 83       	st	Z, r24
    2c48:	01 c0       	rjmp	.+2      	; 0x2c4c <xQueueCRReceiveFromISR+0x6c>
    2c4a:	81 e0       	ldi	r24, 0x01	; 1
        {
            xReturn = pdFAIL;
        }

        return xReturn;
    }
    2c4c:	df 91       	pop	r29
    2c4e:	cf 91       	pop	r28
    2c50:	1f 91       	pop	r17
    2c52:	0f 91       	pop	r16
    2c54:	08 95       	ret

00002c56 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    2c56:	0f 93       	push	r16
    2c58:	1f 93       	push	r17
    2c5a:	cf 93       	push	r28
    2c5c:	df 93       	push	r29
    2c5e:	ec 01       	movw	r28, r24
    2c60:	04 2f       	mov	r16, r20
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2c62:	1a 8d       	ldd	r17, Y+26	; 0x1a

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2c64:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2c66:	44 23       	and	r20, r20
    2c68:	61 f4       	brne	.+24     	; 0x2c82 <prvCopyDataToQueue+0x2c>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2c6a:	88 81       	ld	r24, Y
    2c6c:	99 81       	ldd	r25, Y+1	; 0x01
    2c6e:	89 2b       	or	r24, r25
    2c70:	09 f0       	breq	.+2      	; 0x2c74 <prvCopyDataToQueue+0x1e>
    2c72:	3f c0       	rjmp	.+126    	; 0x2cf2 <prvCopyDataToQueue+0x9c>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    2c74:	8c 81       	ldd	r24, Y+4	; 0x04
    2c76:	9d 81       	ldd	r25, Y+5	; 0x05
    2c78:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <xTaskPriorityDisinherit>
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
    2c7c:	1d 82       	std	Y+5, r1	; 0x05
    2c7e:	1c 82       	std	Y+4, r1	; 0x04
    2c80:	39 c0       	rjmp	.+114    	; 0x2cf4 <prvCopyDataToQueue+0x9e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    2c82:	00 23       	and	r16, r16
    2c84:	b1 f4       	brne	.+44     	; 0x2cb2 <prvCopyDataToQueue+0x5c>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2c86:	8a 81       	ldd	r24, Y+2	; 0x02
    2c88:	9b 81       	ldd	r25, Y+3	; 0x03
    2c8a:	50 e0       	ldi	r21, 0x00	; 0
    2c8c:	0e 94 76 21 	call	0x42ec	; 0x42ec <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2c90:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2c92:	2a 81       	ldd	r18, Y+2	; 0x02
    2c94:	3b 81       	ldd	r19, Y+3	; 0x03
    2c96:	28 0f       	add	r18, r24
    2c98:	31 1d       	adc	r19, r1
    2c9a:	3b 83       	std	Y+3, r19	; 0x03
    2c9c:	2a 83       	std	Y+2, r18	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2c9e:	8c 81       	ldd	r24, Y+4	; 0x04
    2ca0:	9d 81       	ldd	r25, Y+5	; 0x05
    2ca2:	28 17       	cp	r18, r24
    2ca4:	39 07       	cpc	r19, r25
    2ca6:	28 f1       	brcs	.+74     	; 0x2cf2 <prvCopyDataToQueue+0x9c>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2ca8:	88 81       	ld	r24, Y
    2caa:	99 81       	ldd	r25, Y+1	; 0x01
    2cac:	9b 83       	std	Y+3, r25	; 0x03
    2cae:	8a 83       	std	Y+2, r24	; 0x02
    2cb0:	20 c0       	rjmp	.+64     	; 0x2cf2 <prvCopyDataToQueue+0x9c>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2cb2:	8e 81       	ldd	r24, Y+6	; 0x06
    2cb4:	9f 81       	ldd	r25, Y+7	; 0x07
    2cb6:	50 e0       	ldi	r21, 0x00	; 0
    2cb8:	0e 94 76 21 	call	0x42ec	; 0x42ec <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2cbc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2cbe:	90 e0       	ldi	r25, 0x00	; 0
    2cc0:	44 27       	eor	r20, r20
    2cc2:	55 27       	eor	r21, r21
    2cc4:	48 1b       	sub	r20, r24
    2cc6:	59 0b       	sbc	r21, r25
    2cc8:	8e 81       	ldd	r24, Y+6	; 0x06
    2cca:	9f 81       	ldd	r25, Y+7	; 0x07
    2ccc:	84 0f       	add	r24, r20
    2cce:	95 1f       	adc	r25, r21
    2cd0:	9f 83       	std	Y+7, r25	; 0x07
    2cd2:	8e 83       	std	Y+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2cd4:	28 81       	ld	r18, Y
    2cd6:	39 81       	ldd	r19, Y+1	; 0x01
    2cd8:	82 17       	cp	r24, r18
    2cda:	93 07       	cpc	r25, r19
    2cdc:	30 f4       	brcc	.+12     	; 0x2cea <prvCopyDataToQueue+0x94>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2cde:	8c 81       	ldd	r24, Y+4	; 0x04
    2ce0:	9d 81       	ldd	r25, Y+5	; 0x05
    2ce2:	84 0f       	add	r24, r20
    2ce4:	95 1f       	adc	r25, r21
    2ce6:	9f 83       	std	Y+7, r25	; 0x07
    2ce8:	8e 83       	std	Y+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    2cea:	02 30       	cpi	r16, 0x02	; 2
    2cec:	11 f4       	brne	.+4      	; 0x2cf2 <prvCopyDataToQueue+0x9c>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2cee:	11 11       	cpse	r17, r1
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    2cf0:	11 50       	subi	r17, 0x01	; 1
    2cf2:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2cf4:	1f 5f       	subi	r17, 0xFF	; 255
    2cf6:	1a 8f       	std	Y+26, r17	; 0x1a

    return xReturn;
}
    2cf8:	df 91       	pop	r29
    2cfa:	cf 91       	pop	r28
    2cfc:	1f 91       	pop	r17
    2cfe:	0f 91       	pop	r16
    2d00:	08 95       	ret

00002d02 <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    2d02:	1f 93       	push	r17
    2d04:	cf 93       	push	r28
    2d06:	df 93       	push	r29
    2d08:	ec 01       	movw	r28, r24
    2d0a:	14 2f       	mov	r17, r20
        Queue_t * const pxQueue = xQueue;

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2d0c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2d0e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2d10:	98 17       	cp	r25, r24
    2d12:	88 f4       	brcc	.+34     	; 0x2d36 <xQueueCRSendFromISR+0x34>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2d14:	ce 01       	movw	r24, r28
    2d16:	40 e0       	ldi	r20, 0x00	; 0
    2d18:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    2d1c:	11 23       	and	r17, r17
    2d1e:	59 f4       	brne	.+22     	; 0x2d36 <xQueueCRSendFromISR+0x34>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2d20:	89 89       	ldd	r24, Y+17	; 0x11
    2d22:	88 23       	and	r24, r24
    2d24:	41 f0       	breq	.+16     	; 0x2d36 <xQueueCRSendFromISR+0x34>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2d26:	ce 01       	movw	r24, r28
    2d28:	41 96       	adiw	r24, 0x11	; 17
    2d2a:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <xCoRoutineRemoveFromEventList>
    2d2e:	48 2f       	mov	r20, r24
    2d30:	81 11       	cpse	r24, r1
    2d32:	41 e0       	ldi	r20, 0x01	; 1
    2d34:	14 2f       	mov	r17, r20
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    }
    2d36:	81 2f       	mov	r24, r17
    2d38:	df 91       	pop	r29
    2d3a:	cf 91       	pop	r28
    2d3c:	1f 91       	pop	r17
    2d3e:	08 95       	ret

00002d40 <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    2d40:	cf 93       	push	r28
    2d42:	df 93       	push	r29
    2d44:	ec 01       	movw	r28, r24
    2d46:	fb 01       	movw	r30, r22
        Queue_t * const pxQueue = xQueue;

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    2d48:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2d4a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2d4c:	88 23       	and	r24, r24
    2d4e:	71 f4       	brne	.+28     	; 0x2d6c <xQueueCRReceive+0x2c>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    2d50:	41 15       	cp	r20, r1
    2d52:	51 05       	cpc	r21, r1
    2d54:	41 f0       	breq	.+16     	; 0x2d66 <xQueueCRReceive+0x26>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2d56:	61 96       	adiw	r28, 0x11	; 17
    2d58:	ca 01       	movw	r24, r20
    2d5a:	be 01       	movw	r22, r28
    2d5c:	0e 94 ea 1c 	call	0x39d4	; 0x39d4 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2d60:	78 94       	sei
    2d62:	8c ef       	ldi	r24, 0xFC	; 252
    2d64:	2f c0       	rjmp	.+94     	; 0x2dc4 <xQueueCRReceive+0x84>
                    return errQUEUE_BLOCKED;
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2d66:	78 94       	sei
    2d68:	80 e0       	ldi	r24, 0x00	; 0
    2d6a:	2c c0       	rjmp	.+88     	; 0x2dc4 <xQueueCRReceive+0x84>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    2d6c:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2d6e:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2d70:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2d72:	88 23       	and	r24, r24
    2d74:	31 f1       	breq	.+76     	; 0x2dc2 <xQueueCRReceive+0x82>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2d76:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2d78:	2e 81       	ldd	r18, Y+6	; 0x06
    2d7a:	3f 81       	ldd	r19, Y+7	; 0x07
    2d7c:	28 0f       	add	r18, r24
    2d7e:	31 1d       	adc	r19, r1
    2d80:	3f 83       	std	Y+7, r19	; 0x07
    2d82:	2e 83       	std	Y+6, r18	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2d84:	8c 81       	ldd	r24, Y+4	; 0x04
    2d86:	9d 81       	ldd	r25, Y+5	; 0x05
    2d88:	28 17       	cp	r18, r24
    2d8a:	39 07       	cpc	r19, r25
    2d8c:	20 f0       	brcs	.+8      	; 0x2d96 <xQueueCRReceive+0x56>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2d8e:	88 81       	ld	r24, Y
    2d90:	99 81       	ldd	r25, Y+1	; 0x01
    2d92:	9f 83       	std	Y+7, r25	; 0x07
    2d94:	8e 83       	std	Y+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    2d96:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2d98:	81 50       	subi	r24, 0x01	; 1
    2d9a:	8a 8f       	std	Y+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2d9c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2d9e:	6e 81       	ldd	r22, Y+6	; 0x06
    2da0:	7f 81       	ldd	r23, Y+7	; 0x07
    2da2:	cf 01       	movw	r24, r30
    2da4:	50 e0       	ldi	r21, 0x00	; 0
    2da6:	0e 94 76 21 	call	0x42ec	; 0x42ec <memcpy>

                xReturn = pdPASS;

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2daa:	88 85       	ldd	r24, Y+8	; 0x08
    2dac:	88 23       	and	r24, r24
    2dae:	41 f0       	breq	.+16     	; 0x2dc0 <xQueueCRReceive+0x80>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2db0:	ce 01       	movw	r24, r28
    2db2:	08 96       	adiw	r24, 0x08	; 8
    2db4:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <xCoRoutineRemoveFromEventList>
    2db8:	88 23       	and	r24, r24
    2dba:	11 f0       	breq	.+4      	; 0x2dc0 <xQueueCRReceive+0x80>
    2dbc:	8b ef       	ldi	r24, 0xFB	; 251
    2dbe:	01 c0       	rjmp	.+2      	; 0x2dc2 <xQueueCRReceive+0x82>
    2dc0:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                xReturn = pdFAIL;
            }
        }
        portENABLE_INTERRUPTS();
    2dc2:	78 94       	sei

        return xReturn;
    }
    2dc4:	df 91       	pop	r29
    2dc6:	cf 91       	pop	r28
    2dc8:	08 95       	ret

00002dca <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    2dca:	cf 93       	push	r28
    2dcc:	df 93       	push	r29
    2dce:	ec 01       	movw	r28, r24
        Queue_t * const pxQueue = xQueue;

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    2dd0:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2dd2:	0f b6       	in	r0, 0x3f	; 63
    2dd4:	f8 94       	cli
    2dd6:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2dd8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2dda:	9b 8d       	ldd	r25, Y+27	; 0x1b
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    2ddc:	0f 90       	pop	r0
    2dde:	0f be       	out	0x3f, r0	; 63
        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2de0:	89 17       	cp	r24, r25
    2de2:	71 f4       	brne	.+28     	; 0x2e00 <xQueueCRSend+0x36>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    2de4:	41 15       	cp	r20, r1
    2de6:	51 05       	cpc	r21, r1
    2de8:	41 f0       	breq	.+16     	; 0x2dfa <xQueueCRSend+0x30>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    2dea:	28 96       	adiw	r28, 0x08	; 8
    2dec:	ca 01       	movw	r24, r20
    2dee:	be 01       	movw	r22, r28
    2df0:	0e 94 ea 1c 	call	0x39d4	; 0x39d4 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2df4:	78 94       	sei
    2df6:	8c ef       	ldi	r24, 0xFC	; 252
    2df8:	1b c0       	rjmp	.+54     	; 0x2e30 <xQueueCRSend+0x66>
                    return errQUEUE_BLOCKED;
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2dfa:	78 94       	sei
    2dfc:	80 e0       	ldi	r24, 0x00	; 0
    2dfe:	18 c0       	rjmp	.+48     	; 0x2e30 <xQueueCRSend+0x66>
                    return errQUEUE_FULL;
                }
            }
        }
        portENABLE_INTERRUPTS();
    2e00:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2e02:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2e04:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2e06:	89 17       	cp	r24, r25
    2e08:	10 f0       	brcs	.+4      	; 0x2e0e <xQueueCRSend+0x44>
    2e0a:	80 e0       	ldi	r24, 0x00	; 0
    2e0c:	10 c0       	rjmp	.+32     	; 0x2e2e <xQueueCRSend+0x64>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2e0e:	ce 01       	movw	r24, r28
    2e10:	40 e0       	ldi	r20, 0x00	; 0
    2e12:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <prvCopyDataToQueue>
                xReturn = pdPASS;

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2e16:	89 89       	ldd	r24, Y+17	; 0x11
    2e18:	88 23       	and	r24, r24
    2e1a:	41 f0       	breq	.+16     	; 0x2e2c <xQueueCRSend+0x62>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2e1c:	ce 01       	movw	r24, r28
    2e1e:	41 96       	adiw	r24, 0x11	; 17
    2e20:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <xCoRoutineRemoveFromEventList>
    2e24:	88 23       	and	r24, r24
    2e26:	11 f0       	breq	.+4      	; 0x2e2c <xQueueCRSend+0x62>
    2e28:	8b ef       	ldi	r24, 0xFB	; 251
    2e2a:	01 c0       	rjmp	.+2      	; 0x2e2e <xQueueCRSend+0x64>
    2e2c:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                xReturn = errQUEUE_FULL;
            }
        }
        portENABLE_INTERRUPTS();
    2e2e:	78 94       	sei

        return xReturn;
    }
    2e30:	df 91       	pop	r29
    2e32:	cf 91       	pop	r28
    2e34:	08 95       	ret

00002e36 <vQueueDelete>:

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    2e36:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2e3a:	08 95       	ret

00002e3c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2e3c:	ef 92       	push	r14
    2e3e:	ff 92       	push	r15
    2e40:	0f 93       	push	r16
    2e42:	1f 93       	push	r17
    2e44:	cf 93       	push	r28
    2e46:	df 93       	push	r29
    2e48:	ec 01       	movw	r28, r24
    2e4a:	7a 01       	movw	r14, r20
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2e4c:	1a 8d       	ldd	r17, Y+26	; 0x1a

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2e4e:	11 23       	and	r17, r17
    2e50:	11 f4       	brne	.+4      	; 0x2e56 <xQueueReceiveFromISR+0x1a>
    2e52:	80 e0       	ldi	r24, 0x00	; 0
    2e54:	1a c0       	rjmp	.+52     	; 0x2e8a <xQueueReceiveFromISR+0x4e>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    2e56:	0d 8d       	ldd	r16, Y+29	; 0x1d

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2e58:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2e5c:	11 50       	subi	r17, 0x01	; 1
    2e5e:	1a 8f       	std	Y+26, r17	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    2e60:	0f 3f       	cpi	r16, 0xFF	; 255
    2e62:	81 f4       	brne	.+32     	; 0x2e84 <xQueueReceiveFromISR+0x48>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2e64:	88 85       	ldd	r24, Y+8	; 0x08
    2e66:	88 23       	and	r24, r24
    2e68:	79 f0       	breq	.+30     	; 0x2e88 <xQueueReceiveFromISR+0x4c>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2e6a:	ce 01       	movw	r24, r28
    2e6c:	08 96       	adiw	r24, 0x08	; 8
    2e6e:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <xTaskRemoveFromEventList>
    2e72:	88 23       	and	r24, r24
    2e74:	49 f0       	breq	.+18     	; 0x2e88 <xQueueReceiveFromISR+0x4c>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    2e76:	e1 14       	cp	r14, r1
    2e78:	f1 04       	cpc	r15, r1
    2e7a:	31 f0       	breq	.+12     	; 0x2e88 <xQueueReceiveFromISR+0x4c>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    2e7c:	81 e0       	ldi	r24, 0x01	; 1
    2e7e:	f7 01       	movw	r30, r14
    2e80:	80 83       	st	Z, r24
    2e82:	03 c0       	rjmp	.+6      	; 0x2e8a <xQueueReceiveFromISR+0x4e>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2e84:	0f 5f       	subi	r16, 0xFF	; 255
    2e86:	0d 8f       	std	Y+29, r16	; 0x1d
    2e88:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    2e8a:	df 91       	pop	r29
    2e8c:	cf 91       	pop	r28
    2e8e:	1f 91       	pop	r17
    2e90:	0f 91       	pop	r16
    2e92:	ff 90       	pop	r15
    2e94:	ef 90       	pop	r14
    2e96:	08 95       	ret

00002e98 <xQueueGiveFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    2e98:	cf 93       	push	r28
    2e9a:	df 93       	push	r29
    2e9c:	fc 01       	movw	r30, r24
    2e9e:	eb 01       	movw	r28, r22
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2ea0:	92 8d       	ldd	r25, Z+26	; 0x1a

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    2ea2:	83 8d       	ldd	r24, Z+27	; 0x1b
    2ea4:	98 17       	cp	r25, r24
    2ea6:	10 f0       	brcs	.+4      	; 0x2eac <xQueueGiveFromISR+0x14>
    2ea8:	80 e0       	ldi	r24, 0x00	; 0
    2eaa:	16 c0       	rjmp	.+44     	; 0x2ed8 <xQueueGiveFromISR+0x40>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2eac:	86 8d       	ldd	r24, Z+30	; 0x1e
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2eae:	9f 5f       	subi	r25, 0xFF	; 255
    2eb0:	92 8f       	std	Z+26, r25	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    2eb2:	8f 3f       	cpi	r24, 0xFF	; 255
    2eb4:	71 f4       	brne	.+28     	; 0x2ed2 <xQueueGiveFromISR+0x3a>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2eb6:	81 89       	ldd	r24, Z+17	; 0x11
    2eb8:	88 23       	and	r24, r24
    2eba:	69 f0       	breq	.+26     	; 0x2ed6 <xQueueGiveFromISR+0x3e>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2ebc:	cf 01       	movw	r24, r30
    2ebe:	41 96       	adiw	r24, 0x11	; 17
    2ec0:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <xTaskRemoveFromEventList>
    2ec4:	88 23       	and	r24, r24
    2ec6:	39 f0       	breq	.+14     	; 0x2ed6 <xQueueGiveFromISR+0x3e>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    2ec8:	20 97       	sbiw	r28, 0x00	; 0
    2eca:	29 f0       	breq	.+10     	; 0x2ed6 <xQueueGiveFromISR+0x3e>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2ecc:	81 e0       	ldi	r24, 0x01	; 1
    2ece:	88 83       	st	Y, r24
    2ed0:	03 c0       	rjmp	.+6      	; 0x2ed8 <xQueueGiveFromISR+0x40>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2ed2:	8f 5f       	subi	r24, 0xFF	; 255
    2ed4:	86 8f       	std	Z+30, r24	; 0x1e
    2ed6:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    2ed8:	df 91       	pop	r29
    2eda:	cf 91       	pop	r28
    2edc:	08 95       	ret

00002ede <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    2ede:	ef 92       	push	r14
    2ee0:	ff 92       	push	r15
    2ee2:	1f 93       	push	r17
    2ee4:	cf 93       	push	r28
    2ee6:	df 93       	push	r29
    2ee8:	ec 01       	movw	r28, r24
    2eea:	7a 01       	movw	r14, r20
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2eec:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2eee:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2ef0:	98 17       	cp	r25, r24
    2ef2:	20 f0       	brcs	.+8      	; 0x2efc <xQueueGenericSendFromISR+0x1e>
    2ef4:	22 30       	cpi	r18, 0x02	; 2
    2ef6:	11 f0       	breq	.+4      	; 0x2efc <xQueueGenericSendFromISR+0x1e>
    2ef8:	80 e0       	ldi	r24, 0x00	; 0
    2efa:	1b c0       	rjmp	.+54     	; 0x2f32 <xQueueGenericSendFromISR+0x54>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2efc:	1e 8d       	ldd	r17, Y+30	; 0x1e
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    2efe:	8a 8d       	ldd	r24, Y+26	; 0x1a
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2f00:	ce 01       	movw	r24, r28
    2f02:	42 2f       	mov	r20, r18
    2f04:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    2f08:	1f 3f       	cpi	r17, 0xFF	; 255
    2f0a:	81 f4       	brne	.+32     	; 0x2f2c <xQueueGenericSendFromISR+0x4e>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2f0c:	89 89       	ldd	r24, Y+17	; 0x11
    2f0e:	88 23       	and	r24, r24
    2f10:	79 f0       	breq	.+30     	; 0x2f30 <xQueueGenericSendFromISR+0x52>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2f12:	ce 01       	movw	r24, r28
    2f14:	41 96       	adiw	r24, 0x11	; 17
    2f16:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <xTaskRemoveFromEventList>
    2f1a:	88 23       	and	r24, r24
    2f1c:	49 f0       	breq	.+18     	; 0x2f30 <xQueueGenericSendFromISR+0x52>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    2f1e:	e1 14       	cp	r14, r1
    2f20:	f1 04       	cpc	r15, r1
    2f22:	31 f0       	breq	.+12     	; 0x2f30 <xQueueGenericSendFromISR+0x52>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2f24:	81 e0       	ldi	r24, 0x01	; 1
    2f26:	f7 01       	movw	r30, r14
    2f28:	80 83       	st	Z, r24
    2f2a:	03 c0       	rjmp	.+6      	; 0x2f32 <xQueueGenericSendFromISR+0x54>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2f2c:	1f 5f       	subi	r17, 0xFF	; 255
    2f2e:	1e 8f       	std	Y+30, r17	; 0x1e
    2f30:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    2f32:	df 91       	pop	r29
    2f34:	cf 91       	pop	r28
    2f36:	1f 91       	pop	r17
    2f38:	ff 90       	pop	r15
    2f3a:	ef 90       	pop	r14
    2f3c:	08 95       	ret

00002f3e <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2f3e:	ef 92       	push	r14
    2f40:	ff 92       	push	r15
    2f42:	1f 93       	push	r17
    2f44:	cf 93       	push	r28
    2f46:	df 93       	push	r29
    2f48:	ec 01       	movw	r28, r24

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    2f4a:	0f b6       	in	r0, 0x3f	; 63
    2f4c:	f8 94       	cli
    2f4e:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    2f50:	1e 8d       	ldd	r17, Y+30	; 0x1e
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2f52:	91 e1       	ldi	r25, 0x11	; 17
    2f54:	e9 2e       	mov	r14, r25
    2f56:	f1 2c       	mov	r15, r1
    2f58:	ec 0e       	add	r14, r28
    2f5a:	fd 1e       	adc	r15, r29
    2f5c:	0b c0       	rjmp	.+22     	; 0x2f74 <prvUnlockQueue+0x36>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2f5e:	89 89       	ldd	r24, Y+17	; 0x11
    2f60:	88 23       	and	r24, r24
    2f62:	51 f0       	breq	.+20     	; 0x2f78 <prvUnlockQueue+0x3a>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2f64:	c7 01       	movw	r24, r14
    2f66:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <xTaskRemoveFromEventList>
    2f6a:	88 23       	and	r24, r24
    2f6c:	11 f0       	breq	.+4      	; 0x2f72 <prvUnlockQueue+0x34>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    2f6e:	0e 94 c0 0b 	call	0x1780	; 0x1780 <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    2f72:	11 50       	subi	r17, 0x01	; 1
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    2f74:	11 16       	cp	r1, r17
    2f76:	9c f3       	brlt	.-26     	; 0x2f5e <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    2f78:	8f ef       	ldi	r24, 0xFF	; 255
    2f7a:	8e 8f       	std	Y+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    2f7c:	0f 90       	pop	r0
    2f7e:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    2f80:	0f b6       	in	r0, 0x3f	; 63
    2f82:	f8 94       	cli
    2f84:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    2f86:	1d 8d       	ldd	r17, Y+29	; 0x1d

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2f88:	88 e0       	ldi	r24, 0x08	; 8
    2f8a:	e8 2e       	mov	r14, r24
    2f8c:	f1 2c       	mov	r15, r1
    2f8e:	ec 0e       	add	r14, r28
    2f90:	fd 1e       	adc	r15, r29
    2f92:	0b c0       	rjmp	.+22     	; 0x2faa <prvUnlockQueue+0x6c>
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2f94:	88 85       	ldd	r24, Y+8	; 0x08
    2f96:	88 23       	and	r24, r24
    2f98:	51 f0       	breq	.+20     	; 0x2fae <prvUnlockQueue+0x70>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2f9a:	c7 01       	movw	r24, r14
    2f9c:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <xTaskRemoveFromEventList>
    2fa0:	88 23       	and	r24, r24
    2fa2:	11 f0       	breq	.+4      	; 0x2fa8 <prvUnlockQueue+0x6a>
                {
                    vTaskMissedYield();
    2fa4:	0e 94 c0 0b 	call	0x1780	; 0x1780 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    2fa8:	11 50       	subi	r17, 0x01	; 1
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    2faa:	11 16       	cp	r1, r17
    2fac:	9c f3       	brlt	.-26     	; 0x2f94 <prvUnlockQueue+0x56>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    2fae:	8f ef       	ldi	r24, 0xFF	; 255
    2fb0:	8d 8f       	std	Y+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    2fb2:	0f 90       	pop	r0
    2fb4:	0f be       	out	0x3f, r0	; 63
}
    2fb6:	df 91       	pop	r29
    2fb8:	cf 91       	pop	r28
    2fba:	1f 91       	pop	r17
    2fbc:	ff 90       	pop	r15
    2fbe:	ef 90       	pop	r14
    2fc0:	08 95       	ret

00002fc2 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    2fc2:	8f 92       	push	r8
    2fc4:	9f 92       	push	r9
    2fc6:	af 92       	push	r10
    2fc8:	bf 92       	push	r11
    2fca:	cf 92       	push	r12
    2fcc:	df 92       	push	r13
    2fce:	ef 92       	push	r14
    2fd0:	ff 92       	push	r15
    2fd2:	0f 93       	push	r16
    2fd4:	1f 93       	push	r17
    2fd6:	df 93       	push	r29
    2fd8:	cf 93       	push	r28
    2fda:	00 d0       	rcall	.+0      	; 0x2fdc <xQueuePeek+0x1a>
    2fdc:	00 d0       	rcall	.+0      	; 0x2fde <xQueuePeek+0x1c>
    2fde:	0f 92       	push	r0
    2fe0:	cd b7       	in	r28, 0x3d	; 61
    2fe2:	de b7       	in	r29, 0x3e	; 62
    2fe4:	7c 01       	movw	r14, r24
    2fe6:	5b 01       	movw	r10, r22
    2fe8:	5d 83       	std	Y+5, r21	; 0x05
    2fea:	4c 83       	std	Y+4, r20	; 0x04
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2fec:	41 e1       	ldi	r20, 0x11	; 17
    2fee:	c4 2e       	mov	r12, r20
    2ff0:	d1 2c       	mov	r13, r1
    2ff2:	c8 0e       	add	r12, r24
    2ff4:	d9 1e       	adc	r13, r25
    2ff6:	20 e0       	ldi	r18, 0x00	; 0
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2ff8:	8e 01       	movw	r16, r28
    2ffa:	0f 5f       	subi	r16, 0xFF	; 255
    2ffc:	1f 4f       	sbci	r17, 0xFF	; 255

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2ffe:	34 e0       	ldi	r19, 0x04	; 4
    3000:	83 2e       	mov	r8, r19
    3002:	91 2c       	mov	r9, r1
    3004:	8c 0e       	add	r8, r28
    3006:	9d 1e       	adc	r9, r29
    3008:	01 c0       	rjmp	.+2      	; 0x300c <xQueuePeek+0x4a>
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    300a:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    300c:	0f b6       	in	r0, 0x3f	; 63
    300e:	f8 94       	cli
    3010:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3012:	f7 01       	movw	r30, r14
    3014:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3016:	88 23       	and	r24, r24
    3018:	b9 f0       	breq	.+46     	; 0x3048 <xQueuePeek+0x86>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    301a:	06 81       	ldd	r16, Z+6	; 0x06
    301c:	17 81       	ldd	r17, Z+7	; 0x07

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    301e:	c7 01       	movw	r24, r14
    3020:	b5 01       	movw	r22, r10
    3022:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3026:	f7 01       	movw	r30, r14
    3028:	17 83       	std	Z+7, r17	; 0x07
    302a:	06 83       	std	Z+6, r16	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    302c:	81 89       	ldd	r24, Z+17	; 0x11
    302e:	88 23       	and	r24, r24
    3030:	39 f0       	breq	.+14     	; 0x3040 <xQueuePeek+0x7e>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3032:	c6 01       	movw	r24, r12
    3034:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <xTaskRemoveFromEventList>
    3038:	88 23       	and	r24, r24
    303a:	11 f0       	breq	.+4      	; 0x3040 <xQueuePeek+0x7e>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    303c:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3040:	0f 90       	pop	r0
    3042:	0f be       	out	0x3f, r0	; 63
    3044:	81 e0       	ldi	r24, 0x01	; 1
    3046:	54 c0       	rjmp	.+168    	; 0x30f0 <xQueuePeek+0x12e>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3048:	8c 81       	ldd	r24, Y+4	; 0x04
    304a:	9d 81       	ldd	r25, Y+5	; 0x05
    304c:	89 2b       	or	r24, r25
    304e:	21 f4       	brne	.+8      	; 0x3058 <xQueuePeek+0x96>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3050:	0f 90       	pop	r0
    3052:	0f be       	out	0x3f, r0	; 63
    3054:	80 e0       	ldi	r24, 0x00	; 0
    3056:	4c c0       	rjmp	.+152    	; 0x30f0 <xQueuePeek+0x12e>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    3058:	22 23       	and	r18, r18
    305a:	19 f4       	brne	.+6      	; 0x3062 <xQueuePeek+0xa0>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    305c:	c8 01       	movw	r24, r16
    305e:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3062:	0f 90       	pop	r0
    3064:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3066:	0e 94 0e 0b 	call	0x161c	; 0x161c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    306a:	0f b6       	in	r0, 0x3f	; 63
    306c:	f8 94       	cli
    306e:	0f 92       	push	r0
    3070:	f7 01       	movw	r30, r14
    3072:	85 8d       	ldd	r24, Z+29	; 0x1d
    3074:	8f 3f       	cpi	r24, 0xFF	; 255
    3076:	09 f4       	brne	.+2      	; 0x307a <xQueuePeek+0xb8>
    3078:	15 8e       	std	Z+29, r1	; 0x1d
    307a:	f7 01       	movw	r30, r14
    307c:	86 8d       	ldd	r24, Z+30	; 0x1e
    307e:	8f 3f       	cpi	r24, 0xFF	; 255
    3080:	09 f4       	brne	.+2      	; 0x3084 <xQueuePeek+0xc2>
    3082:	16 8e       	std	Z+30, r1	; 0x1e
    3084:	0f 90       	pop	r0
    3086:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3088:	c8 01       	movw	r24, r16
    308a:	b4 01       	movw	r22, r8
    308c:	0e 94 88 0b 	call	0x1710	; 0x1710 <xTaskCheckForTimeOut>
    3090:	88 23       	and	r24, r24
    3092:	f9 f4       	brne	.+62     	; 0x30d2 <xQueuePeek+0x110>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    3094:	0f b6       	in	r0, 0x3f	; 63
    3096:	f8 94       	cli
    3098:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    309a:	f7 01       	movw	r30, r14
    309c:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    309e:	0f 90       	pop	r0
    30a0:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    30a2:	88 23       	and	r24, r24
    30a4:	81 f4       	brne	.+32     	; 0x30c6 <xQueuePeek+0x104>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    30a6:	6c 81       	ldd	r22, Y+4	; 0x04
    30a8:	7d 81       	ldd	r23, Y+5	; 0x05
    30aa:	c6 01       	movw	r24, r12
    30ac:	0e 94 b2 13 	call	0x2764	; 0x2764 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    30b0:	c7 01       	movw	r24, r14
    30b2:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    30b6:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>
    30ba:	88 23       	and	r24, r24
    30bc:	09 f0       	breq	.+2      	; 0x30c0 <xQueuePeek+0xfe>
    30be:	a5 cf       	rjmp	.-182    	; 0x300a <xQueuePeek+0x48>
                {
                    portYIELD_WITHIN_API();
    30c0:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
    30c4:	a2 cf       	rjmp	.-188    	; 0x300a <xQueuePeek+0x48>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    30c6:	c7 01       	movw	r24, r14
    30c8:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    30cc:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>
    30d0:	9c cf       	rjmp	.-200    	; 0x300a <xQueuePeek+0x48>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    30d2:	c7 01       	movw	r24, r14
    30d4:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    30d8:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    30dc:	0f b6       	in	r0, 0x3f	; 63
    30de:	f8 94       	cli
    30e0:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    30e2:	f7 01       	movw	r30, r14
    30e4:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    30e6:	0f 90       	pop	r0
    30e8:	0f be       	out	0x3f, r0	; 63
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    30ea:	88 23       	and	r24, r24
    30ec:	09 f0       	breq	.+2      	; 0x30f0 <xQueuePeek+0x12e>
    30ee:	8d cf       	rjmp	.-230    	; 0x300a <xQueuePeek+0x48>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    30f0:	0f 90       	pop	r0
    30f2:	0f 90       	pop	r0
    30f4:	0f 90       	pop	r0
    30f6:	0f 90       	pop	r0
    30f8:	0f 90       	pop	r0
    30fa:	cf 91       	pop	r28
    30fc:	df 91       	pop	r29
    30fe:	1f 91       	pop	r17
    3100:	0f 91       	pop	r16
    3102:	ff 90       	pop	r15
    3104:	ef 90       	pop	r14
    3106:	df 90       	pop	r13
    3108:	cf 90       	pop	r12
    310a:	bf 90       	pop	r11
    310c:	af 90       	pop	r10
    310e:	9f 90       	pop	r9
    3110:	8f 90       	pop	r8
    3112:	08 95       	ret

00003114 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    3114:	6f 92       	push	r6
    3116:	7f 92       	push	r7
    3118:	8f 92       	push	r8
    311a:	9f 92       	push	r9
    311c:	af 92       	push	r10
    311e:	bf 92       	push	r11
    3120:	cf 92       	push	r12
    3122:	df 92       	push	r13
    3124:	ff 92       	push	r15
    3126:	0f 93       	push	r16
    3128:	1f 93       	push	r17
    312a:	df 93       	push	r29
    312c:	cf 93       	push	r28
    312e:	00 d0       	rcall	.+0      	; 0x3130 <xQueueReceive+0x1c>
    3130:	00 d0       	rcall	.+0      	; 0x3132 <xQueueReceive+0x1e>
    3132:	0f 92       	push	r0
    3134:	cd b7       	in	r28, 0x3d	; 61
    3136:	de b7       	in	r29, 0x3e	; 62
    3138:	8c 01       	movw	r16, r24
    313a:	5b 01       	movw	r10, r22
    313c:	5d 83       	std	Y+5, r21	; 0x05
    313e:	4c 83       	std	Y+4, r20	; 0x04
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3140:	61 e1       	ldi	r22, 0x11	; 17
    3142:	c6 2e       	mov	r12, r22
    3144:	d1 2c       	mov	r13, r1
    3146:	c8 0e       	add	r12, r24
    3148:	d9 1e       	adc	r13, r25
    314a:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    314c:	4e 01       	movw	r8, r28
    314e:	08 94       	sec
    3150:	81 1c       	adc	r8, r1
    3152:	91 1c       	adc	r9, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3154:	54 e0       	ldi	r21, 0x04	; 4
    3156:	65 2e       	mov	r6, r21
    3158:	71 2c       	mov	r7, r1
    315a:	6c 0e       	add	r6, r28
    315c:	7d 1e       	adc	r7, r29
    315e:	01 c0       	rjmp	.+2      	; 0x3162 <xQueueReceive+0x4e>
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3160:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3162:	0f b6       	in	r0, 0x3f	; 63
    3164:	f8 94       	cli
    3166:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3168:	f8 01       	movw	r30, r16
    316a:	f2 8c       	ldd	r15, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    316c:	ff 20       	and	r15, r15
    316e:	b1 f0       	breq	.+44     	; 0x319c <xQueueReceive+0x88>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    3170:	c8 01       	movw	r24, r16
    3172:	b5 01       	movw	r22, r10
    3174:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3178:	fa 94       	dec	r15
    317a:	f8 01       	movw	r30, r16
    317c:	f2 8e       	std	Z+26, r15	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    317e:	80 85       	ldd	r24, Z+8	; 0x08
    3180:	88 23       	and	r24, r24
    3182:	41 f0       	breq	.+16     	; 0x3194 <xQueueReceive+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3184:	c8 01       	movw	r24, r16
    3186:	08 96       	adiw	r24, 0x08	; 8
    3188:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <xTaskRemoveFromEventList>
    318c:	88 23       	and	r24, r24
    318e:	11 f0       	breq	.+4      	; 0x3194 <xQueueReceive+0x80>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    3190:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3194:	0f 90       	pop	r0
    3196:	0f be       	out	0x3f, r0	; 63
    3198:	81 e0       	ldi	r24, 0x01	; 1
    319a:	54 c0       	rjmp	.+168    	; 0x3244 <xQueueReceive+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    319c:	8c 81       	ldd	r24, Y+4	; 0x04
    319e:	9d 81       	ldd	r25, Y+5	; 0x05
    31a0:	89 2b       	or	r24, r25
    31a2:	21 f4       	brne	.+8      	; 0x31ac <xQueueReceive+0x98>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    31a4:	0f 90       	pop	r0
    31a6:	0f be       	out	0x3f, r0	; 63
    31a8:	80 e0       	ldi	r24, 0x00	; 0
    31aa:	4c c0       	rjmp	.+152    	; 0x3244 <xQueueReceive+0x130>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    31ac:	22 23       	and	r18, r18
    31ae:	19 f4       	brne	.+6      	; 0x31b6 <xQueueReceive+0xa2>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    31b0:	c4 01       	movw	r24, r8
    31b2:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    31b6:	0f 90       	pop	r0
    31b8:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    31ba:	0e 94 0e 0b 	call	0x161c	; 0x161c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    31be:	0f b6       	in	r0, 0x3f	; 63
    31c0:	f8 94       	cli
    31c2:	0f 92       	push	r0
    31c4:	f8 01       	movw	r30, r16
    31c6:	85 8d       	ldd	r24, Z+29	; 0x1d
    31c8:	8f 3f       	cpi	r24, 0xFF	; 255
    31ca:	09 f4       	brne	.+2      	; 0x31ce <xQueueReceive+0xba>
    31cc:	15 8e       	std	Z+29, r1	; 0x1d
    31ce:	f8 01       	movw	r30, r16
    31d0:	86 8d       	ldd	r24, Z+30	; 0x1e
    31d2:	8f 3f       	cpi	r24, 0xFF	; 255
    31d4:	09 f4       	brne	.+2      	; 0x31d8 <xQueueReceive+0xc4>
    31d6:	16 8e       	std	Z+30, r1	; 0x1e
    31d8:	0f 90       	pop	r0
    31da:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    31dc:	c4 01       	movw	r24, r8
    31de:	b3 01       	movw	r22, r6
    31e0:	0e 94 88 0b 	call	0x1710	; 0x1710 <xTaskCheckForTimeOut>
    31e4:	88 23       	and	r24, r24
    31e6:	f9 f4       	brne	.+62     	; 0x3226 <xQueueReceive+0x112>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    31e8:	0f b6       	in	r0, 0x3f	; 63
    31ea:	f8 94       	cli
    31ec:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    31ee:	f8 01       	movw	r30, r16
    31f0:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    31f2:	0f 90       	pop	r0
    31f4:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    31f6:	88 23       	and	r24, r24
    31f8:	81 f4       	brne	.+32     	; 0x321a <xQueueReceive+0x106>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    31fa:	6c 81       	ldd	r22, Y+4	; 0x04
    31fc:	7d 81       	ldd	r23, Y+5	; 0x05
    31fe:	c6 01       	movw	r24, r12
    3200:	0e 94 b2 13 	call	0x2764	; 0x2764 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3204:	c8 01       	movw	r24, r16
    3206:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    320a:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>
    320e:	88 23       	and	r24, r24
    3210:	09 f0       	breq	.+2      	; 0x3214 <xQueueReceive+0x100>
    3212:	a6 cf       	rjmp	.-180    	; 0x3160 <xQueueReceive+0x4c>
                {
                    portYIELD_WITHIN_API();
    3214:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
    3218:	a3 cf       	rjmp	.-186    	; 0x3160 <xQueueReceive+0x4c>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    321a:	c8 01       	movw	r24, r16
    321c:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3220:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>
    3224:	9d cf       	rjmp	.-198    	; 0x3160 <xQueueReceive+0x4c>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    3226:	c8 01       	movw	r24, r16
    3228:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    322c:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    3230:	0f b6       	in	r0, 0x3f	; 63
    3232:	f8 94       	cli
    3234:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3236:	f8 01       	movw	r30, r16
    3238:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    323a:	0f 90       	pop	r0
    323c:	0f be       	out	0x3f, r0	; 63
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    323e:	88 23       	and	r24, r24
    3240:	09 f0       	breq	.+2      	; 0x3244 <xQueueReceive+0x130>
    3242:	8e cf       	rjmp	.-228    	; 0x3160 <xQueueReceive+0x4c>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    3244:	0f 90       	pop	r0
    3246:	0f 90       	pop	r0
    3248:	0f 90       	pop	r0
    324a:	0f 90       	pop	r0
    324c:	0f 90       	pop	r0
    324e:	cf 91       	pop	r28
    3250:	df 91       	pop	r29
    3252:	1f 91       	pop	r17
    3254:	0f 91       	pop	r16
    3256:	ff 90       	pop	r15
    3258:	df 90       	pop	r13
    325a:	cf 90       	pop	r12
    325c:	bf 90       	pop	r11
    325e:	af 90       	pop	r10
    3260:	9f 90       	pop	r9
    3262:	8f 90       	pop	r8
    3264:	7f 90       	pop	r7
    3266:	6f 90       	pop	r6
    3268:	08 95       	ret

0000326a <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    326a:	6f 92       	push	r6
    326c:	7f 92       	push	r7
    326e:	9f 92       	push	r9
    3270:	af 92       	push	r10
    3272:	bf 92       	push	r11
    3274:	cf 92       	push	r12
    3276:	df 92       	push	r13
    3278:	ef 92       	push	r14
    327a:	ff 92       	push	r15
    327c:	0f 93       	push	r16
    327e:	1f 93       	push	r17
    3280:	df 93       	push	r29
    3282:	cf 93       	push	r28
    3284:	00 d0       	rcall	.+0      	; 0x3286 <xQueueGenericSend+0x1c>
    3286:	00 d0       	rcall	.+0      	; 0x3288 <xQueueGenericSend+0x1e>
    3288:	0f 92       	push	r0
    328a:	cd b7       	in	r28, 0x3d	; 61
    328c:	de b7       	in	r29, 0x3e	; 62
    328e:	8c 01       	movw	r16, r24
    3290:	6b 01       	movw	r12, r22
    3292:	5d 83       	std	Y+5, r21	; 0x05
    3294:	4c 83       	std	Y+4, r20	; 0x04
    3296:	92 2e       	mov	r9, r18
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3298:	e8 e0       	ldi	r30, 0x08	; 8
    329a:	ee 2e       	mov	r14, r30
    329c:	f1 2c       	mov	r15, r1
    329e:	e8 0e       	add	r14, r24
    32a0:	f9 1e       	adc	r15, r25
    32a2:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    32a4:	5e 01       	movw	r10, r28
    32a6:	08 94       	sec
    32a8:	a1 1c       	adc	r10, r1
    32aa:	b1 1c       	adc	r11, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    32ac:	74 e0       	ldi	r23, 0x04	; 4
    32ae:	67 2e       	mov	r6, r23
    32b0:	71 2c       	mov	r7, r1
    32b2:	6c 0e       	add	r6, r28
    32b4:	7d 1e       	adc	r7, r29
    32b6:	01 c0       	rjmp	.+2      	; 0x32ba <xQueueGenericSend+0x50>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    32b8:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    32ba:	0f b6       	in	r0, 0x3f	; 63
    32bc:	f8 94       	cli
    32be:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    32c0:	f8 01       	movw	r30, r16
    32c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    32c4:	83 8d       	ldd	r24, Z+27	; 0x1b
    32c6:	98 17       	cp	r25, r24
    32c8:	18 f0       	brcs	.+6      	; 0x32d0 <xQueueGenericSend+0x66>
    32ca:	f2 e0       	ldi	r31, 0x02	; 2
    32cc:	9f 16       	cp	r9, r31
    32ce:	c9 f4       	brne	.+50     	; 0x3302 <xQueueGenericSend+0x98>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    32d0:	c8 01       	movw	r24, r16
    32d2:	b6 01       	movw	r22, r12
    32d4:	49 2d       	mov	r20, r9
    32d6:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <prvCopyDataToQueue>
    32da:	98 2f       	mov	r25, r24

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    32dc:	f8 01       	movw	r30, r16
    32de:	81 89       	ldd	r24, Z+17	; 0x11
    32e0:	88 23       	and	r24, r24
    32e2:	39 f0       	breq	.+14     	; 0x32f2 <xQueueGenericSend+0x88>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    32e4:	c8 01       	movw	r24, r16
    32e6:	41 96       	adiw	r24, 0x11	; 17
    32e8:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <xTaskRemoveFromEventList>
    32ec:	88 23       	and	r24, r24
    32ee:	29 f0       	breq	.+10     	; 0x32fa <xQueueGenericSend+0x90>
    32f0:	02 c0       	rjmp	.+4      	; 0x32f6 <xQueueGenericSend+0x8c>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    32f2:	99 23       	and	r25, r25
    32f4:	11 f0       	breq	.+4      	; 0x32fa <xQueueGenericSend+0x90>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    32f6:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    32fa:	0f 90       	pop	r0
    32fc:	0f be       	out	0x3f, r0	; 63
    32fe:	81 e0       	ldi	r24, 0x01	; 1
    3300:	4c c0       	rjmp	.+152    	; 0x339a <xQueueGenericSend+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3302:	8c 81       	ldd	r24, Y+4	; 0x04
    3304:	9d 81       	ldd	r25, Y+5	; 0x05
    3306:	89 2b       	or	r24, r25
    3308:	19 f4       	brne	.+6      	; 0x3310 <xQueueGenericSend+0xa6>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    330a:	0f 90       	pop	r0
    330c:	0f be       	out	0x3f, r0	; 63
    330e:	44 c0       	rjmp	.+136    	; 0x3398 <xQueueGenericSend+0x12e>
                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
                }
                else if( xEntryTimeSet == pdFALSE )
    3310:	22 23       	and	r18, r18
    3312:	19 f4       	brne	.+6      	; 0x331a <xQueueGenericSend+0xb0>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3314:	c5 01       	movw	r24, r10
    3316:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    331a:	0f 90       	pop	r0
    331c:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    331e:	0e 94 0e 0b 	call	0x161c	; 0x161c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3322:	0f b6       	in	r0, 0x3f	; 63
    3324:	f8 94       	cli
    3326:	0f 92       	push	r0
    3328:	f8 01       	movw	r30, r16
    332a:	85 8d       	ldd	r24, Z+29	; 0x1d
    332c:	8f 3f       	cpi	r24, 0xFF	; 255
    332e:	09 f4       	brne	.+2      	; 0x3332 <xQueueGenericSend+0xc8>
    3330:	15 8e       	std	Z+29, r1	; 0x1d
    3332:	f8 01       	movw	r30, r16
    3334:	86 8d       	ldd	r24, Z+30	; 0x1e
    3336:	8f 3f       	cpi	r24, 0xFF	; 255
    3338:	09 f4       	brne	.+2      	; 0x333c <xQueueGenericSend+0xd2>
    333a:	16 8e       	std	Z+30, r1	; 0x1e
    333c:	0f 90       	pop	r0
    333e:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3340:	c5 01       	movw	r24, r10
    3342:	b3 01       	movw	r22, r6
    3344:	0e 94 88 0b 	call	0x1710	; 0x1710 <xTaskCheckForTimeOut>
    3348:	88 23       	and	r24, r24
    334a:	09 f5       	brne	.+66     	; 0x338e <xQueueGenericSend+0x124>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    334c:	0f b6       	in	r0, 0x3f	; 63
    334e:	f8 94       	cli
    3350:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3352:	f8 01       	movw	r30, r16
    3354:	92 8d       	ldd	r25, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    3356:	0f 90       	pop	r0
    3358:	0f be       	out	0x3f, r0	; 63
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    335a:	f8 01       	movw	r30, r16
    335c:	83 8d       	ldd	r24, Z+27	; 0x1b
    335e:	98 17       	cp	r25, r24
    3360:	81 f4       	brne	.+32     	; 0x3382 <xQueueGenericSend+0x118>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3362:	6c 81       	ldd	r22, Y+4	; 0x04
    3364:	7d 81       	ldd	r23, Y+5	; 0x05
    3366:	c7 01       	movw	r24, r14
    3368:	0e 94 b2 13 	call	0x2764	; 0x2764 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    336c:	c8 01       	movw	r24, r16
    336e:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    3372:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>
    3376:	88 23       	and	r24, r24
    3378:	09 f0       	breq	.+2      	; 0x337c <xQueueGenericSend+0x112>
    337a:	9e cf       	rjmp	.-196    	; 0x32b8 <xQueueGenericSend+0x4e>
                {
                    portYIELD_WITHIN_API();
    337c:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
    3380:	9b cf       	rjmp	.-202    	; 0x32b8 <xQueueGenericSend+0x4e>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    3382:	c8 01       	movw	r24, r16
    3384:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3388:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>
    338c:	95 cf       	rjmp	.-214    	; 0x32b8 <xQueueGenericSend+0x4e>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    338e:	c8 01       	movw	r24, r16
    3390:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3394:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>
    3398:	80 e0       	ldi	r24, 0x00	; 0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
    339a:	0f 90       	pop	r0
    339c:	0f 90       	pop	r0
    339e:	0f 90       	pop	r0
    33a0:	0f 90       	pop	r0
    33a2:	0f 90       	pop	r0
    33a4:	cf 91       	pop	r28
    33a6:	df 91       	pop	r29
    33a8:	1f 91       	pop	r17
    33aa:	0f 91       	pop	r16
    33ac:	ff 90       	pop	r15
    33ae:	ef 90       	pop	r14
    33b0:	df 90       	pop	r13
    33b2:	cf 90       	pop	r12
    33b4:	bf 90       	pop	r11
    33b6:	af 90       	pop	r10
    33b8:	9f 90       	pop	r9
    33ba:	7f 90       	pop	r7
    33bc:	6f 90       	pop	r6
    33be:	08 95       	ret

000033c0 <xQueueSemaphoreTake>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    33c0:	8f 92       	push	r8
    33c2:	9f 92       	push	r9
    33c4:	af 92       	push	r10
    33c6:	bf 92       	push	r11
    33c8:	df 92       	push	r13
    33ca:	ef 92       	push	r14
    33cc:	ff 92       	push	r15
    33ce:	0f 93       	push	r16
    33d0:	1f 93       	push	r17
    33d2:	df 93       	push	r29
    33d4:	cf 93       	push	r28
    33d6:	00 d0       	rcall	.+0      	; 0x33d8 <xQueueSemaphoreTake+0x18>
    33d8:	00 d0       	rcall	.+0      	; 0x33da <xQueueSemaphoreTake+0x1a>
    33da:	0f 92       	push	r0
    33dc:	cd b7       	in	r28, 0x3d	; 61
    33de:	de b7       	in	r29, 0x3e	; 62
    33e0:	8c 01       	movw	r16, r24
    33e2:	7d 83       	std	Y+5, r23	; 0x05
    33e4:	6c 83       	std	Y+4, r22	; 0x04
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    33e6:	a1 e1       	ldi	r26, 0x11	; 17
    33e8:	ea 2e       	mov	r14, r26
    33ea:	f1 2c       	mov	r15, r1
    33ec:	e8 0e       	add	r14, r24
    33ee:	f9 1e       	adc	r15, r25
    33f0:	20 e0       	ldi	r18, 0x00	; 0
    33f2:	dd 24       	eor	r13, r13
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    33f4:	5e 01       	movw	r10, r28
    33f6:	08 94       	sec
    33f8:	a1 1c       	adc	r10, r1
    33fa:	b1 1c       	adc	r11, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    33fc:	f4 e0       	ldi	r31, 0x04	; 4
    33fe:	8f 2e       	mov	r8, r31
    3400:	91 2c       	mov	r9, r1
    3402:	8c 0e       	add	r8, r28
    3404:	9d 1e       	adc	r9, r29
    3406:	01 c0       	rjmp	.+2      	; 0x340a <xQueueSemaphoreTake+0x4a>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3408:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    340a:	0f b6       	in	r0, 0x3f	; 63
    340c:	f8 94       	cli
    340e:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    3410:	d8 01       	movw	r26, r16
    3412:	5a 96       	adiw	r26, 0x1a	; 26
    3414:	8c 91       	ld	r24, X
    3416:	5a 97       	sbiw	r26, 0x1a	; 26

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    3418:	88 23       	and	r24, r24
    341a:	f1 f0       	breq	.+60     	; 0x3458 <xQueueSemaphoreTake+0x98>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    341c:	81 50       	subi	r24, 0x01	; 1
    341e:	5a 96       	adiw	r26, 0x1a	; 26
    3420:	8c 93       	st	X, r24
    3422:	5a 97       	sbiw	r26, 0x1a	; 26

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3424:	8d 91       	ld	r24, X+
    3426:	9c 91       	ld	r25, X
    3428:	89 2b       	or	r24, r25
    342a:	29 f4       	brne	.+10     	; 0x3436 <xQueueSemaphoreTake+0x76>
                        {
                            /* Record the information required to implement
                             * priority inheritance should it become necessary. */
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    342c:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <pvTaskIncrementMutexHeldCount>
    3430:	f8 01       	movw	r30, r16
    3432:	95 83       	std	Z+5, r25	; 0x05
    3434:	84 83       	std	Z+4, r24	; 0x04
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3436:	d8 01       	movw	r26, r16
    3438:	18 96       	adiw	r26, 0x08	; 8
    343a:	8c 91       	ld	r24, X
    343c:	88 23       	and	r24, r24
    343e:	41 f0       	breq	.+16     	; 0x3450 <xQueueSemaphoreTake+0x90>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3440:	c8 01       	movw	r24, r16
    3442:	08 96       	adiw	r24, 0x08	; 8
    3444:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <xTaskRemoveFromEventList>
    3448:	88 23       	and	r24, r24
    344a:	11 f0       	breq	.+4      	; 0x3450 <xQueueSemaphoreTake+0x90>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    344c:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3450:	0f 90       	pop	r0
    3452:	0f be       	out	0x3f, r0	; 63
    3454:	81 e0       	ldi	r24, 0x01	; 1
    3456:	82 c0       	rjmp	.+260    	; 0x355c <xQueueSemaphoreTake+0x19c>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3458:	8c 81       	ldd	r24, Y+4	; 0x04
    345a:	9d 81       	ldd	r25, Y+5	; 0x05
    345c:	89 2b       	or	r24, r25
    345e:	19 f4       	brne	.+6      	; 0x3466 <xQueueSemaphoreTake+0xa6>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    3460:	0f 90       	pop	r0
    3462:	0f be       	out	0x3f, r0	; 63
    3464:	7a c0       	rjmp	.+244    	; 0x355a <xQueueSemaphoreTake+0x19a>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    3466:	22 23       	and	r18, r18
    3468:	19 f4       	brne	.+6      	; 0x3470 <xQueueSemaphoreTake+0xb0>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    346a:	c5 01       	movw	r24, r10
    346c:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3470:	0f 90       	pop	r0
    3472:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3474:	0e 94 0e 0b 	call	0x161c	; 0x161c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3478:	0f b6       	in	r0, 0x3f	; 63
    347a:	f8 94       	cli
    347c:	0f 92       	push	r0
    347e:	f8 01       	movw	r30, r16
    3480:	85 8d       	ldd	r24, Z+29	; 0x1d
    3482:	8f 3f       	cpi	r24, 0xFF	; 255
    3484:	09 f4       	brne	.+2      	; 0x3488 <xQueueSemaphoreTake+0xc8>
    3486:	15 8e       	std	Z+29, r1	; 0x1d
    3488:	d8 01       	movw	r26, r16
    348a:	5e 96       	adiw	r26, 0x1e	; 30
    348c:	8c 91       	ld	r24, X
    348e:	5e 97       	sbiw	r26, 0x1e	; 30
    3490:	8f 3f       	cpi	r24, 0xFF	; 255
    3492:	11 f4       	brne	.+4      	; 0x3498 <xQueueSemaphoreTake+0xd8>
    3494:	5e 96       	adiw	r26, 0x1e	; 30
    3496:	1c 92       	st	X, r1
    3498:	0f 90       	pop	r0
    349a:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    349c:	c5 01       	movw	r24, r10
    349e:	b4 01       	movw	r22, r8
    34a0:	0e 94 88 0b 	call	0x1710	; 0x1710 <xTaskCheckForTimeOut>
    34a4:	88 23       	and	r24, r24
    34a6:	79 f5       	brne	.+94     	; 0x3506 <xQueueSemaphoreTake+0x146>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    34a8:	0f b6       	in	r0, 0x3f	; 63
    34aa:	f8 94       	cli
    34ac:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    34ae:	f8 01       	movw	r30, r16
    34b0:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    34b2:	0f 90       	pop	r0
    34b4:	0f be       	out	0x3f, r0	; 63
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    34b6:	88 23       	and	r24, r24
    34b8:	01 f5       	brne	.+64     	; 0x34fa <xQueueSemaphoreTake+0x13a>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    34ba:	d8 01       	movw	r26, r16
    34bc:	8d 91       	ld	r24, X+
    34be:	9c 91       	ld	r25, X
    34c0:	89 2b       	or	r24, r25
    34c2:	59 f4       	brne	.+22     	; 0x34da <xQueueSemaphoreTake+0x11a>
                        {
                            taskENTER_CRITICAL();
    34c4:	0f b6       	in	r0, 0x3f	; 63
    34c6:	f8 94       	cli
    34c8:	0f 92       	push	r0
                            {
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    34ca:	f8 01       	movw	r30, r16
    34cc:	84 81       	ldd	r24, Z+4	; 0x04
    34ce:	95 81       	ldd	r25, Z+5	; 0x05
    34d0:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <xTaskPriorityInherit>
    34d4:	d8 2e       	mov	r13, r24
                            }
                            taskEXIT_CRITICAL();
    34d6:	0f 90       	pop	r0
    34d8:	0f be       	out	0x3f, r0	; 63
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    34da:	6c 81       	ldd	r22, Y+4	; 0x04
    34dc:	7d 81       	ldd	r23, Y+5	; 0x05
    34de:	c7 01       	movw	r24, r14
    34e0:	0e 94 b2 13 	call	0x2764	; 0x2764 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    34e4:	c8 01       	movw	r24, r16
    34e6:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    34ea:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>
    34ee:	88 23       	and	r24, r24
    34f0:	09 f0       	breq	.+2      	; 0x34f4 <xQueueSemaphoreTake+0x134>
    34f2:	8a cf       	rjmp	.-236    	; 0x3408 <xQueueSemaphoreTake+0x48>
                {
                    portYIELD_WITHIN_API();
    34f4:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
    34f8:	87 cf       	rjmp	.-242    	; 0x3408 <xQueueSemaphoreTake+0x48>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    34fa:	c8 01       	movw	r24, r16
    34fc:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3500:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>
    3504:	81 cf       	rjmp	.-254    	; 0x3408 <xQueueSemaphoreTake+0x48>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    3506:	c8 01       	movw	r24, r16
    3508:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    350c:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    3510:	0f b6       	in	r0, 0x3f	; 63
    3512:	f8 94       	cli
    3514:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3516:	d8 01       	movw	r26, r16
    3518:	5a 96       	adiw	r26, 0x1a	; 26
    351a:	8c 91       	ld	r24, X
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    351c:	0f 90       	pop	r0
    351e:	0f be       	out	0x3f, r0	; 63

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3520:	88 23       	and	r24, r24
    3522:	09 f0       	breq	.+2      	; 0x3526 <xQueueSemaphoreTake+0x166>
    3524:	71 cf       	rjmp	.-286    	; 0x3408 <xQueueSemaphoreTake+0x48>
                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* xInheritanceOccurred could only have be set if
                         * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                         * test the mutex type again to check it is actually a mutex. */
                        if( xInheritanceOccurred != pdFALSE )
    3526:	dd 20       	and	r13, r13
    3528:	c9 f0       	breq	.+50     	; 0x355c <xQueueSemaphoreTake+0x19c>
                        {
                            taskENTER_CRITICAL();
    352a:	0f b6       	in	r0, 0x3f	; 63
    352c:	f8 94       	cli
    352e:	0f 92       	push	r0
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    3530:	f8 01       	movw	r30, r16
    3532:	81 89       	ldd	r24, Z+17	; 0x11
    3534:	88 23       	and	r24, r24
    3536:	11 f4       	brne	.+4      	; 0x353c <xQueueSemaphoreTake+0x17c>
    3538:	60 e0       	ldi	r22, 0x00	; 0
    353a:	08 c0       	rjmp	.+16     	; 0x354c <xQueueSemaphoreTake+0x18c>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    353c:	d8 01       	movw	r26, r16
    353e:	56 96       	adiw	r26, 0x16	; 22
    3540:	ed 91       	ld	r30, X+
    3542:	fc 91       	ld	r31, X
    3544:	57 97       	sbiw	r26, 0x17	; 23
    3546:	64 e0       	ldi	r22, 0x04	; 4
    3548:	80 81       	ld	r24, Z
    354a:	68 1b       	sub	r22, r24
                                 * task to inherit this task's priority.  Now this task
                                 * has timed out the priority should be disinherited
                                 * again, but only as low as the next highest priority
                                 * task that is waiting for the same mutex. */
                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    354c:	f8 01       	movw	r30, r16
    354e:	84 81       	ldd	r24, Z+4	; 0x04
    3550:	95 81       	ldd	r25, Z+5	; 0x05
    3552:	0e 94 3f 0d 	call	0x1a7e	; 0x1a7e <vTaskPriorityDisinheritAfterTimeout>
                            }
                            taskEXIT_CRITICAL();
    3556:	0f 90       	pop	r0
    3558:	0f be       	out	0x3f, r0	; 63
    355a:	80 e0       	ldi	r24, 0x00	; 0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    355c:	0f 90       	pop	r0
    355e:	0f 90       	pop	r0
    3560:	0f 90       	pop	r0
    3562:	0f 90       	pop	r0
    3564:	0f 90       	pop	r0
    3566:	cf 91       	pop	r28
    3568:	df 91       	pop	r29
    356a:	1f 91       	pop	r17
    356c:	0f 91       	pop	r16
    356e:	ff 90       	pop	r15
    3570:	ef 90       	pop	r14
    3572:	df 90       	pop	r13
    3574:	bf 90       	pop	r11
    3576:	af 90       	pop	r10
    3578:	9f 90       	pop	r9
    357a:	8f 90       	pop	r8
    357c:	08 95       	ret

0000357e <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    357e:	cf 93       	push	r28
    3580:	df 93       	push	r29
    3582:	ec 01       	movw	r28, r24
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    3584:	0f b6       	in	r0, 0x3f	; 63
    3586:	f8 94       	cli
    3588:	0f 92       	push	r0
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    358a:	ec 8d       	ldd	r30, Y+28	; 0x1c
    358c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    358e:	e2 9f       	mul	r30, r18
    3590:	c0 01       	movw	r24, r0
    3592:	11 24       	eor	r1, r1
    3594:	48 81       	ld	r20, Y
    3596:	59 81       	ldd	r21, Y+1	; 0x01
    3598:	84 0f       	add	r24, r20
    359a:	95 1f       	adc	r25, r21
    359c:	9d 83       	std	Y+5, r25	; 0x05
    359e:	8c 83       	std	Y+4, r24	; 0x04
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    35a0:	1a 8e       	std	Y+26, r1	; 0x1a
        pxQueue->pcWriteTo = pxQueue->pcHead;
    35a2:	5b 83       	std	Y+3, r21	; 0x03
    35a4:	4a 83       	std	Y+2, r20	; 0x02
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    35a6:	30 e0       	ldi	r19, 0x00	; 0
    35a8:	21 50       	subi	r18, 0x01	; 1
    35aa:	30 40       	sbci	r19, 0x00	; 0
    35ac:	f0 e0       	ldi	r31, 0x00	; 0
    35ae:	2e 9f       	mul	r18, r30
    35b0:	c0 01       	movw	r24, r0
    35b2:	2f 9f       	mul	r18, r31
    35b4:	90 0d       	add	r25, r0
    35b6:	3e 9f       	mul	r19, r30
    35b8:	90 0d       	add	r25, r0
    35ba:	11 24       	eor	r1, r1
    35bc:	48 0f       	add	r20, r24
    35be:	59 1f       	adc	r21, r25
    35c0:	5f 83       	std	Y+7, r21	; 0x07
    35c2:	4e 83       	std	Y+6, r20	; 0x06
        pxQueue->cRxLock = queueUNLOCKED;
    35c4:	8f ef       	ldi	r24, 0xFF	; 255
    35c6:	8d 8f       	std	Y+29, r24	; 0x1d
        pxQueue->cTxLock = queueUNLOCKED;
    35c8:	8e 8f       	std	Y+30, r24	; 0x1e

        if( xNewQueue == pdFALSE )
    35ca:	66 23       	and	r22, r22
    35cc:	61 f4       	brne	.+24     	; 0x35e6 <xQueueGenericReset+0x68>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    35ce:	88 85       	ldd	r24, Y+8	; 0x08
    35d0:	88 23       	and	r24, r24
    35d2:	89 f0       	breq	.+34     	; 0x35f6 <xQueueGenericReset+0x78>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    35d4:	ce 01       	movw	r24, r28
    35d6:	08 96       	adiw	r24, 0x08	; 8
    35d8:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <xTaskRemoveFromEventList>
    35dc:	88 23       	and	r24, r24
    35de:	59 f0       	breq	.+22     	; 0x35f6 <xQueueGenericReset+0x78>
                {
                    queueYIELD_IF_USING_PREEMPTION();
    35e0:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <vPortYield>
    35e4:	08 c0       	rjmp	.+16     	; 0x35f6 <xQueueGenericReset+0x78>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    35e6:	ce 01       	movw	r24, r28
    35e8:	08 96       	adiw	r24, 0x08	; 8
    35ea:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    35ee:	ce 01       	movw	r24, r28
    35f0:	41 96       	adiw	r24, 0x11	; 17
    35f2:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
        }
    }
    taskEXIT_CRITICAL();
    35f6:	0f 90       	pop	r0
    35f8:	0f be       	out	0x3f, r0	; 63

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
}
    35fa:	81 e0       	ldi	r24, 0x01	; 1
    35fc:	df 91       	pop	r29
    35fe:	cf 91       	pop	r28
    3600:	08 95       	ret

00003602 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    3602:	0f 93       	push	r16
    3604:	1f 93       	push	r17
    3606:	cf 93       	push	r28
    3608:	df 93       	push	r29
    360a:	08 2f       	mov	r16, r24
    360c:	16 2f       	mov	r17, r22
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    360e:	68 9f       	mul	r22, r24
    3610:	c0 01       	movw	r24, r0
    3612:	11 24       	eor	r1, r1
    3614:	4f 96       	adiw	r24, 0x1f	; 31
    3616:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <pvPortMalloc>
    361a:	ec 01       	movw	r28, r24

        if( pxNewQueue != NULL )
    361c:	00 97       	sbiw	r24, 0x00	; 0
    361e:	71 f0       	breq	.+28     	; 0x363c <xQueueGenericCreate+0x3a>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    3620:	11 23       	and	r17, r17
    3622:	19 f4       	brne	.+6      	; 0x362a <xQueueGenericCreate+0x28>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    3624:	99 83       	std	Y+1, r25	; 0x01
    3626:	88 83       	st	Y, r24
    3628:	03 c0       	rjmp	.+6      	; 0x3630 <xQueueGenericCreate+0x2e>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    362a:	4f 96       	adiw	r24, 0x1f	; 31
    362c:	99 83       	std	Y+1, r25	; 0x01
    362e:	88 83       	st	Y, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    3630:	0b 8f       	std	Y+27, r16	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    3632:	1c 8f       	std	Y+28, r17	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    3634:	ce 01       	movw	r24, r28
    3636:	61 e0       	ldi	r22, 0x01	; 1
    3638:	0e 94 bf 1a 	call	0x357e	; 0x357e <xQueueGenericReset>
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
    363c:	ce 01       	movw	r24, r28
    363e:	df 91       	pop	r29
    3640:	cf 91       	pop	r28
    3642:	1f 91       	pop	r17
    3644:	0f 91       	pop	r16
    3646:	08 95       	ret

00003648 <xQueueCreateCountingSemaphore>:

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
    3648:	1f 93       	push	r17
    364a:	16 2f       	mov	r17, r22
        QueueHandle_t xHandle;

        configASSERT( uxMaxCount != 0 );
        configASSERT( uxInitialCount <= uxMaxCount );

        xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    364c:	60 e0       	ldi	r22, 0x00	; 0
    364e:	42 e0       	ldi	r20, 0x02	; 2
    3650:	0e 94 01 1b 	call	0x3602	; 0x3602 <xQueueGenericCreate>
    3654:	fc 01       	movw	r30, r24

        if( xHandle != NULL )
    3656:	00 97       	sbiw	r24, 0x00	; 0
    3658:	09 f0       	breq	.+2      	; 0x365c <xQueueCreateCountingSemaphore+0x14>
        {
            ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    365a:	12 8f       	std	Z+26, r17	; 0x1a
        {
            traceCREATE_COUNTING_SEMAPHORE_FAILED();
        }

        return xHandle;
    }
    365c:	cf 01       	movw	r24, r30
    365e:	1f 91       	pop	r17
    3660:	08 95       	ret

00003662 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    {
    3662:	cf 93       	push	r28
    3664:	df 93       	push	r29
    3666:	48 2f       	mov	r20, r24
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    3668:	81 e0       	ldi	r24, 0x01	; 1
    366a:	60 e0       	ldi	r22, 0x00	; 0
    366c:	0e 94 01 1b 	call	0x3602	; 0x3602 <xQueueGenericCreate>
    3670:	ec 01       	movw	r28, r24

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
        if( pxNewQueue != NULL )
    3672:	00 97       	sbiw	r24, 0x00	; 0
    3674:	61 f0       	breq	.+24     	; 0x368e <xQueueCreateMutex+0x2c>
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    3676:	1d 82       	std	Y+5, r1	; 0x05
    3678:	1c 82       	std	Y+4, r1	; 0x04
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    367a:	19 82       	std	Y+1, r1	; 0x01
    367c:	18 82       	st	Y, r1

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    367e:	1e 82       	std	Y+6, r1	; 0x06

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    3680:	60 e0       	ldi	r22, 0x00	; 0
    3682:	70 e0       	ldi	r23, 0x00	; 0
    3684:	40 e0       	ldi	r20, 0x00	; 0
    3686:	50 e0       	ldi	r21, 0x00	; 0
    3688:	20 e0       	ldi	r18, 0x00	; 0
    368a:	0e 94 35 19 	call	0x326a	; 0x326a <xQueueGenericSend>

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );

        return xNewQueue;
    }
    368e:	ce 01       	movw	r24, r28
    3690:	df 91       	pop	r29
    3692:	cf 91       	pop	r28
    3694:	08 95       	ret

00003696 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3696:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3698:	9c 01       	movw	r18, r24
    369a:	2d 5f       	subi	r18, 0xFD	; 253
    369c:	3f 4f       	sbci	r19, 0xFF	; 255
    369e:	32 83       	std	Z+2, r19	; 0x02
    36a0:	21 83       	std	Z+1, r18	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    36a2:	8f ef       	ldi	r24, 0xFF	; 255
    36a4:	9f ef       	ldi	r25, 0xFF	; 255
    36a6:	94 83       	std	Z+4, r25	; 0x04
    36a8:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    36aa:	36 83       	std	Z+6, r19	; 0x06
    36ac:	25 83       	std	Z+5, r18	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    36ae:	30 87       	std	Z+8, r19	; 0x08
    36b0:	27 83       	std	Z+7, r18	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    36b2:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    36b4:	08 95       	ret

000036b6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    36b6:	fc 01       	movw	r30, r24
    36b8:	11 86       	std	Z+9, r1	; 0x09
    36ba:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    36bc:	08 95       	ret

000036be <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    36be:	ac 01       	movw	r20, r24
    ListItem_t * const pxIndex = pxList->pxIndex;
    36c0:	fc 01       	movw	r30, r24
    36c2:	a1 81       	ldd	r26, Z+1	; 0x01
    36c4:	b2 81       	ldd	r27, Z+2	; 0x02
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    36c6:	fb 01       	movw	r30, r22
    36c8:	b3 83       	std	Z+3, r27	; 0x03
    36ca:	a2 83       	std	Z+2, r26	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    36cc:	14 96       	adiw	r26, 0x04	; 4
    36ce:	8d 91       	ld	r24, X+
    36d0:	9c 91       	ld	r25, X
    36d2:	15 97       	sbiw	r26, 0x05	; 5
    36d4:	95 83       	std	Z+5, r25	; 0x05
    36d6:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    36d8:	14 96       	adiw	r26, 0x04	; 4
    36da:	ed 91       	ld	r30, X+
    36dc:	fc 91       	ld	r31, X
    36de:	15 97       	sbiw	r26, 0x05	; 5
    36e0:	73 83       	std	Z+3, r23	; 0x03
    36e2:	62 83       	std	Z+2, r22	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    36e4:	15 96       	adiw	r26, 0x05	; 5
    36e6:	7c 93       	st	X, r23
    36e8:	6e 93       	st	-X, r22
    36ea:	14 97       	sbiw	r26, 0x04	; 4

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    36ec:	fb 01       	movw	r30, r22
    36ee:	51 87       	std	Z+9, r21	; 0x09
    36f0:	40 87       	std	Z+8, r20	; 0x08

    ( pxList->uxNumberOfItems )++;
    36f2:	fa 01       	movw	r30, r20
    36f4:	80 81       	ld	r24, Z
    36f6:	8f 5f       	subi	r24, 0xFF	; 255
    36f8:	80 83       	st	Z, r24
}
    36fa:	08 95       	ret

000036fc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    36fc:	cf 93       	push	r28
    36fe:	df 93       	push	r29
    3700:	9c 01       	movw	r18, r24
    3702:	eb 01       	movw	r28, r22
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    3704:	48 81       	ld	r20, Y
    3706:	59 81       	ldd	r21, Y+1	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    3708:	8f ef       	ldi	r24, 0xFF	; 255
    370a:	4f 3f       	cpi	r20, 0xFF	; 255
    370c:	58 07       	cpc	r21, r24
    370e:	21 f4       	brne	.+8      	; 0x3718 <vListInsert+0x1c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    3710:	f9 01       	movw	r30, r18
    3712:	a7 81       	ldd	r26, Z+7	; 0x07
    3714:	b0 85       	ldd	r27, Z+8	; 0x08
    3716:	0d c0       	rjmp	.+26     	; 0x3732 <vListInsert+0x36>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3718:	d9 01       	movw	r26, r18
    371a:	13 96       	adiw	r26, 0x03	; 3
    371c:	12 96       	adiw	r26, 0x02	; 2
    371e:	ed 91       	ld	r30, X+
    3720:	fc 91       	ld	r31, X
    3722:	13 97       	sbiw	r26, 0x03	; 3
    3724:	80 81       	ld	r24, Z
    3726:	91 81       	ldd	r25, Z+1	; 0x01
    3728:	48 17       	cp	r20, r24
    372a:	59 07       	cpc	r21, r25
    372c:	10 f0       	brcs	.+4      	; 0x3732 <vListInsert+0x36>
    372e:	df 01       	movw	r26, r30
    3730:	f5 cf       	rjmp	.-22     	; 0x371c <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    3732:	12 96       	adiw	r26, 0x02	; 2
    3734:	ed 91       	ld	r30, X+
    3736:	fc 91       	ld	r31, X
    3738:	13 97       	sbiw	r26, 0x03	; 3
    373a:	fb 83       	std	Y+3, r31	; 0x03
    373c:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    373e:	d5 83       	std	Z+5, r29	; 0x05
    3740:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    3742:	bd 83       	std	Y+5, r27	; 0x05
    3744:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    3746:	13 96       	adiw	r26, 0x03	; 3
    3748:	dc 93       	st	X, r29
    374a:	ce 93       	st	-X, r28
    374c:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    374e:	39 87       	std	Y+9, r19	; 0x09
    3750:	28 87       	std	Y+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    3752:	f9 01       	movw	r30, r18
    3754:	80 81       	ld	r24, Z
    3756:	8f 5f       	subi	r24, 0xFF	; 255
    3758:	80 83       	st	Z, r24
}
    375a:	df 91       	pop	r29
    375c:	cf 91       	pop	r28
    375e:	08 95       	ret

00003760 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3760:	cf 93       	push	r28
    3762:	df 93       	push	r29
    3764:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    3766:	18 96       	adiw	r26, 0x08	; 8
    3768:	cd 91       	ld	r28, X+
    376a:	dc 91       	ld	r29, X
    376c:	19 97       	sbiw	r26, 0x09	; 9

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    376e:	12 96       	adiw	r26, 0x02	; 2
    3770:	4d 91       	ld	r20, X+
    3772:	5c 91       	ld	r21, X
    3774:	13 97       	sbiw	r26, 0x03	; 3
    3776:	14 96       	adiw	r26, 0x04	; 4
    3778:	8d 91       	ld	r24, X+
    377a:	9c 91       	ld	r25, X
    377c:	15 97       	sbiw	r26, 0x05	; 5
    377e:	fa 01       	movw	r30, r20
    3780:	95 83       	std	Z+5, r25	; 0x05
    3782:	84 83       	std	Z+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3784:	14 96       	adiw	r26, 0x04	; 4
    3786:	2d 91       	ld	r18, X+
    3788:	3c 91       	ld	r19, X
    378a:	15 97       	sbiw	r26, 0x05	; 5
    378c:	f9 01       	movw	r30, r18
    378e:	53 83       	std	Z+3, r21	; 0x03
    3790:	42 83       	std	Z+2, r20	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    3792:	89 81       	ldd	r24, Y+1	; 0x01
    3794:	9a 81       	ldd	r25, Y+2	; 0x02
    3796:	8a 17       	cp	r24, r26
    3798:	9b 07       	cpc	r25, r27
    379a:	11 f4       	brne	.+4      	; 0x37a0 <uxListRemove+0x40>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    379c:	3a 83       	std	Y+2, r19	; 0x02
    379e:	29 83       	std	Y+1, r18	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    37a0:	19 96       	adiw	r26, 0x09	; 9
    37a2:	1c 92       	st	X, r1
    37a4:	1e 92       	st	-X, r1
    37a6:	18 97       	sbiw	r26, 0x08	; 8
    ( pxList->uxNumberOfItems )--;
    37a8:	88 81       	ld	r24, Y
    37aa:	81 50       	subi	r24, 0x01	; 1
    37ac:	88 83       	st	Y, r24

    return pxList->uxNumberOfItems;
    37ae:	88 81       	ld	r24, Y
}
    37b0:	df 91       	pop	r29
    37b2:	cf 91       	pop	r28
    37b4:	08 95       	ret

000037b6 <xCoRoutineRemoveFromEventList>:
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    }
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    37b6:	ef 92       	push	r14
    37b8:	ff 92       	push	r15
    37ba:	0f 93       	push	r16
    37bc:	1f 93       	push	r17
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    37be:	dc 01       	movw	r26, r24
    37c0:	15 96       	adiw	r26, 0x05	; 5
    37c2:	ed 91       	ld	r30, X+
    37c4:	fc 91       	ld	r31, X
    37c6:	16 97       	sbiw	r26, 0x06	; 6
    37c8:	e6 80       	ldd	r14, Z+6	; 0x06
    37ca:	f7 80       	ldd	r15, Z+7	; 0x07
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    37cc:	87 01       	movw	r16, r14
    37ce:	04 5f       	subi	r16, 0xF4	; 244
    37d0:	1f 4f       	sbci	r17, 0xFF	; 255
    37d2:	c8 01       	movw	r24, r16
    37d4:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    37d8:	8f ee       	ldi	r24, 0xEF	; 239
    37da:	91 e0       	ldi	r25, 0x01	; 1
    37dc:	b8 01       	movw	r22, r16
    37de:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
    37e2:	20 e0       	ldi	r18, 0x00	; 0
    37e4:	e0 91 be 01 	lds	r30, 0x01BE
    37e8:	f0 91 bf 01 	lds	r31, 0x01BF
    37ec:	d7 01       	movw	r26, r14
    37ee:	56 96       	adiw	r26, 0x16	; 22
    37f0:	9c 91       	ld	r25, X
    37f2:	86 89       	ldd	r24, Z+22	; 0x16
    37f4:	98 17       	cp	r25, r24
    37f6:	08 f0       	brcs	.+2      	; 0x37fa <xCoRoutineRemoveFromEventList+0x44>
    37f8:	21 e0       	ldi	r18, 0x01	; 1
        {
            xReturn = pdFALSE;
        }

        return xReturn;
    }
    37fa:	82 2f       	mov	r24, r18
    37fc:	1f 91       	pop	r17
    37fe:	0f 91       	pop	r16
    3800:	ff 90       	pop	r15
    3802:	ef 90       	pop	r14
    3804:	08 95       	ret

00003806 <vCoRoutineSchedule>:
        xLastTickCount = xCoRoutineTickCount;
    }
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    3806:	ff 92       	push	r15
    3808:	0f 93       	push	r16
    380a:	1f 93       	push	r17
    380c:	cf 93       	push	r28
    380e:	df 93       	push	r29
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    3810:	80 91 c0 01 	lds	r24, 0x01C0
    3814:	90 91 c1 01 	lds	r25, 0x01C1
    3818:	89 2b       	or	r24, r25
    381a:	19 f5       	brne	.+70     	; 0x3862 <vCoRoutineSchedule+0x5c>
    381c:	d5 c0       	rjmp	.+426    	; 0x39c8 <vCoRoutineSchedule+0x1c2>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    381e:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    3820:	e0 91 f4 01 	lds	r30, 0x01F4
    3824:	f0 91 f5 01 	lds	r31, 0x01F5
    3828:	06 81       	ldd	r16, Z+6	; 0x06
    382a:	17 81       	ldd	r17, Z+7	; 0x07
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    382c:	c8 01       	movw	r24, r16
    382e:	0c 96       	adiw	r24, 0x0c	; 12
    3830:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    3834:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    3836:	e8 01       	movw	r28, r16
    3838:	22 96       	adiw	r28, 0x02	; 2
    383a:	ce 01       	movw	r24, r28
    383c:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    3840:	f8 01       	movw	r30, r16
    3842:	96 89       	ldd	r25, Z+22	; 0x16
    3844:	80 91 c2 01 	lds	r24, 0x01C2
    3848:	89 17       	cp	r24, r25
    384a:	10 f4       	brcc	.+4      	; 0x3850 <vCoRoutineSchedule+0x4a>
    384c:	90 93 c2 01 	sts	0x01C2, r25
    3850:	9f 9d       	mul	r25, r15
    3852:	c0 01       	movw	r24, r0
    3854:	11 24       	eor	r1, r1
    3856:	85 53       	subi	r24, 0x35	; 53
    3858:	9e 4f       	sbci	r25, 0xFE	; 254
    385a:	be 01       	movw	r22, r28
    385c:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
    3860:	02 c0       	rjmp	.+4      	; 0x3866 <vCoRoutineSchedule+0x60>
    3862:	99 e0       	ldi	r25, 0x09	; 9
    3864:	f9 2e       	mov	r15, r25
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    3866:	80 91 ef 01 	lds	r24, 0x01EF
    386a:	88 23       	and	r24, r24
    386c:	c1 f6       	brne	.-80     	; 0x381e <vCoRoutineSchedule+0x18>

    static void prvCheckDelayedList( void )
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    386e:	0e 94 14 0b 	call	0x1628	; 0x1628 <xTaskGetTickCount>
    3872:	20 91 c3 01 	lds	r18, 0x01C3
    3876:	30 91 c4 01 	lds	r19, 0x01C4
    387a:	82 1b       	sub	r24, r18
    387c:	93 0b       	sbc	r25, r19
    387e:	90 93 c6 01 	sts	0x01C6, r25
    3882:	80 93 c5 01 	sts	0x01C5, r24
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
                    }
                }
                portENABLE_INTERRUPTS();

                prvAddCoRoutineToReadyQueue( pxCRCB );
    3886:	89 e0       	ldi	r24, 0x09	; 9
    3888:	f8 2e       	mov	r15, r24
    388a:	53 c0       	rjmp	.+166    	; 0x3932 <vCoRoutineSchedule+0x12c>

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    388c:	01 96       	adiw	r24, 0x01	; 1
    388e:	90 93 c8 01 	sts	0x01C8, r25
    3892:	80 93 c7 01 	sts	0x01C7, r24
            xPassedTicks--;
    3896:	21 50       	subi	r18, 0x01	; 1
    3898:	30 40       	sbci	r19, 0x00	; 0
    389a:	30 93 c6 01 	sts	0x01C6, r19
    389e:	20 93 c5 01 	sts	0x01C5, r18

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    38a2:	89 2b       	or	r24, r25
    38a4:	09 f0       	breq	.+2      	; 0x38a8 <vCoRoutineSchedule+0xa2>
    38a6:	3e c0       	rjmp	.+124    	; 0x3924 <vCoRoutineSchedule+0x11e>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    38a8:	20 91 c0 01 	lds	r18, 0x01C0
    38ac:	30 91 c1 01 	lds	r19, 0x01C1
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    38b0:	80 91 c9 01 	lds	r24, 0x01C9
    38b4:	90 91 ca 01 	lds	r25, 0x01CA
    38b8:	90 93 c1 01 	sts	0x01C1, r25
    38bc:	80 93 c0 01 	sts	0x01C0, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    38c0:	30 93 ca 01 	sts	0x01CA, r19
    38c4:	20 93 c9 01 	sts	0x01C9, r18
    38c8:	2d c0       	rjmp	.+90     	; 0x3924 <vCoRoutineSchedule+0x11e>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    38ca:	05 80       	ldd	r0, Z+5	; 0x05
    38cc:	f6 81       	ldd	r31, Z+6	; 0x06
    38ce:	e0 2d       	mov	r30, r0
    38d0:	c6 81       	ldd	r28, Z+6	; 0x06
    38d2:	d7 81       	ldd	r29, Z+7	; 0x07

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    38d4:	20 91 c7 01 	lds	r18, 0x01C7
    38d8:	30 91 c8 01 	lds	r19, 0x01C8
    38dc:	8a 81       	ldd	r24, Y+2	; 0x02
    38de:	9b 81       	ldd	r25, Y+3	; 0x03
    38e0:	28 17       	cp	r18, r24
    38e2:	39 07       	cpc	r19, r25
    38e4:	30 f1       	brcs	.+76     	; 0x3932 <vCoRoutineSchedule+0x12c>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    38e6:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    38e8:	8e 01       	movw	r16, r28
    38ea:	0e 5f       	subi	r16, 0xFE	; 254
    38ec:	1f 4f       	sbci	r17, 0xFF	; 255
    38ee:	c8 01       	movw	r24, r16
    38f0:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    38f4:	8c 89       	ldd	r24, Y+20	; 0x14
    38f6:	9d 89       	ldd	r25, Y+21	; 0x15
    38f8:	89 2b       	or	r24, r25
    38fa:	21 f0       	breq	.+8      	; 0x3904 <vCoRoutineSchedule+0xfe>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    38fc:	ce 01       	movw	r24, r28
    38fe:	0c 96       	adiw	r24, 0x0c	; 12
    3900:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    3904:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    3906:	9e 89       	ldd	r25, Y+22	; 0x16
    3908:	80 91 c2 01 	lds	r24, 0x01C2
    390c:	89 17       	cp	r24, r25
    390e:	10 f4       	brcc	.+4      	; 0x3914 <vCoRoutineSchedule+0x10e>
    3910:	90 93 c2 01 	sts	0x01C2, r25
    3914:	9f 9d       	mul	r25, r15
    3916:	c0 01       	movw	r24, r0
    3918:	11 24       	eor	r1, r1
    391a:	85 53       	subi	r24, 0x35	; 53
    391c:	9e 4f       	sbci	r25, 0xFE	; 254
    391e:	b8 01       	movw	r22, r16
    3920:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    3924:	e0 91 c0 01 	lds	r30, 0x01C0
    3928:	f0 91 c1 01 	lds	r31, 0x01C1
    392c:	80 81       	ld	r24, Z
    392e:	88 23       	and	r24, r24
    3930:	61 f6       	brne	.-104    	; 0x38ca <vCoRoutineSchedule+0xc4>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    3932:	20 91 c5 01 	lds	r18, 0x01C5
    3936:	30 91 c6 01 	lds	r19, 0x01C6
    393a:	80 91 c7 01 	lds	r24, 0x01C7
    393e:	90 91 c8 01 	lds	r25, 0x01C8
    3942:	21 15       	cp	r18, r1
    3944:	31 05       	cpc	r19, r1
    3946:	09 f0       	breq	.+2      	; 0x394a <vCoRoutineSchedule+0x144>
    3948:	a1 cf       	rjmp	.-190    	; 0x388c <vCoRoutineSchedule+0x86>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    394a:	90 93 c4 01 	sts	0x01C4, r25
    394e:	80 93 c3 01 	sts	0x01C3, r24
    3952:	90 91 c2 01 	lds	r25, 0x01C2

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    3956:	29 e0       	ldi	r18, 0x09	; 9
    3958:	06 c0       	rjmp	.+12     	; 0x3966 <vCoRoutineSchedule+0x160>
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    395a:	99 23       	and	r25, r25
    395c:	19 f4       	brne	.+6      	; 0x3964 <vCoRoutineSchedule+0x15e>
    395e:	10 92 c2 01 	sts	0x01C2, r1
    3962:	32 c0       	rjmp	.+100    	; 0x39c8 <vCoRoutineSchedule+0x1c2>
    3964:	91 50       	subi	r25, 0x01	; 1

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    3966:	92 9f       	mul	r25, r18
    3968:	d0 01       	movw	r26, r0
    396a:	11 24       	eor	r1, r1
    396c:	a5 53       	subi	r26, 0x35	; 53
    396e:	be 4f       	sbci	r27, 0xFE	; 254
    3970:	8c 91       	ld	r24, X
    3972:	88 23       	and	r24, r24
    3974:	91 f3       	breq	.-28     	; 0x395a <vCoRoutineSchedule+0x154>
    3976:	90 93 c2 01 	sts	0x01C2, r25
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    397a:	11 96       	adiw	r26, 0x01	; 1
    397c:	ed 91       	ld	r30, X+
    397e:	fc 91       	ld	r31, X
    3980:	12 97       	sbiw	r26, 0x02	; 2
    3982:	02 80       	ldd	r0, Z+2	; 0x02
    3984:	f3 81       	ldd	r31, Z+3	; 0x03
    3986:	e0 2d       	mov	r30, r0
    3988:	12 96       	adiw	r26, 0x02	; 2
    398a:	fc 93       	st	X, r31
    398c:	ee 93       	st	-X, r30
    398e:	11 97       	sbiw	r26, 0x01	; 1
    3990:	cd 01       	movw	r24, r26
    3992:	03 96       	adiw	r24, 0x03	; 3
    3994:	e8 17       	cp	r30, r24
    3996:	f9 07       	cpc	r31, r25
    3998:	31 f4       	brne	.+12     	; 0x39a6 <vCoRoutineSchedule+0x1a0>
    399a:	82 81       	ldd	r24, Z+2	; 0x02
    399c:	93 81       	ldd	r25, Z+3	; 0x03
    399e:	12 96       	adiw	r26, 0x02	; 2
    39a0:	9c 93       	st	X, r25
    39a2:	8e 93       	st	-X, r24
    39a4:	11 97       	sbiw	r26, 0x01	; 1
    39a6:	11 96       	adiw	r26, 0x01	; 1
    39a8:	ed 91       	ld	r30, X+
    39aa:	fc 91       	ld	r31, X
    39ac:	12 97       	sbiw	r26, 0x02	; 2
    39ae:	06 80       	ldd	r0, Z+6	; 0x06
    39b0:	f7 81       	ldd	r31, Z+7	; 0x07
    39b2:	e0 2d       	mov	r30, r0
    39b4:	f0 93 bf 01 	sts	0x01BF, r31
    39b8:	e0 93 be 01 	sts	0x01BE, r30

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    39bc:	20 81       	ld	r18, Z
    39be:	31 81       	ldd	r19, Z+1	; 0x01
    39c0:	cf 01       	movw	r24, r30
    39c2:	67 89       	ldd	r22, Z+23	; 0x17
    39c4:	f9 01       	movw	r30, r18
    39c6:	09 95       	icall
        }
    }
    39c8:	df 91       	pop	r29
    39ca:	cf 91       	pop	r28
    39cc:	1f 91       	pop	r17
    39ce:	0f 91       	pop	r16
    39d0:	ff 90       	pop	r15
    39d2:	08 95       	ret

000039d4 <vCoRoutineAddToDelayedList>:
    }
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
    39d4:	0f 93       	push	r16
    39d6:	1f 93       	push	r17
    39d8:	cf 93       	push	r28
    39da:	df 93       	push	r29
    39dc:	eb 01       	movw	r28, r22
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    39de:	00 91 c7 01 	lds	r16, 0x01C7
    39e2:	10 91 c8 01 	lds	r17, 0x01C8
    39e6:	08 0f       	add	r16, r24
    39e8:	19 1f       	adc	r17, r25

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    39ea:	80 91 be 01 	lds	r24, 0x01BE
    39ee:	90 91 bf 01 	lds	r25, 0x01BF
    39f2:	02 96       	adiw	r24, 0x02	; 2
    39f4:	0e 94 b0 1b 	call	0x3760	; 0x3760 <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    39f8:	e0 91 be 01 	lds	r30, 0x01BE
    39fc:	f0 91 bf 01 	lds	r31, 0x01BF
    3a00:	13 83       	std	Z+3, r17	; 0x03
    3a02:	02 83       	std	Z+2, r16	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
    3a04:	80 91 c7 01 	lds	r24, 0x01C7
    3a08:	90 91 c8 01 	lds	r25, 0x01C8
    3a0c:	bf 01       	movw	r22, r30
    3a0e:	6e 5f       	subi	r22, 0xFE	; 254
    3a10:	7f 4f       	sbci	r23, 0xFF	; 255
    3a12:	08 17       	cp	r16, r24
    3a14:	19 07       	cpc	r17, r25
    3a16:	28 f4       	brcc	.+10     	; 0x3a22 <vCoRoutineAddToDelayedList+0x4e>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3a18:	80 91 c9 01 	lds	r24, 0x01C9
    3a1c:	90 91 ca 01 	lds	r25, 0x01CA
    3a20:	04 c0       	rjmp	.+8      	; 0x3a2a <vCoRoutineAddToDelayedList+0x56>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3a22:	80 91 c0 01 	lds	r24, 0x01C0
    3a26:	90 91 c1 01 	lds	r25, 0x01C1
    3a2a:	0e 94 7e 1b 	call	0x36fc	; 0x36fc <vListInsert>
        }

        if( pxEventList )
    3a2e:	20 97       	sbiw	r28, 0x00	; 0
    3a30:	49 f0       	breq	.+18     	; 0x3a44 <vCoRoutineAddToDelayedList+0x70>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    3a32:	60 91 be 01 	lds	r22, 0x01BE
    3a36:	70 91 bf 01 	lds	r23, 0x01BF
    3a3a:	64 5f       	subi	r22, 0xF4	; 244
    3a3c:	7f 4f       	sbci	r23, 0xFF	; 255
    3a3e:	ce 01       	movw	r24, r28
    3a40:	0e 94 7e 1b 	call	0x36fc	; 0x36fc <vListInsert>
        }
    }
    3a44:	df 91       	pop	r29
    3a46:	cf 91       	pop	r28
    3a48:	1f 91       	pop	r17
    3a4a:	0f 91       	pop	r16
    3a4c:	08 95       	ret

00003a4e <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
    3a4e:	af 92       	push	r10
    3a50:	bf 92       	push	r11
    3a52:	cf 92       	push	r12
    3a54:	df 92       	push	r13
    3a56:	ef 92       	push	r14
    3a58:	ff 92       	push	r15
    3a5a:	0f 93       	push	r16
    3a5c:	1f 93       	push	r17
    3a5e:	cf 93       	push	r28
    3a60:	df 93       	push	r29
    3a62:	6c 01       	movw	r12, r24
    3a64:	b6 2e       	mov	r11, r22
    3a66:	a4 2e       	mov	r10, r20
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    3a68:	8a e1       	ldi	r24, 0x1A	; 26
    3a6a:	90 e0       	ldi	r25, 0x00	; 0
    3a6c:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <pvPortMalloc>
    3a70:	ec 01       	movw	r28, r24

        if( pxCoRoutine )
    3a72:	00 97       	sbiw	r24, 0x00	; 0
    3a74:	11 f4       	brne	.+4      	; 0x3a7a <xCoRoutineCreate+0x2c>
    3a76:	8f ef       	ldi	r24, 0xFF	; 255
    3a78:	59 c0       	rjmp	.+178    	; 0x3b2c <xCoRoutineCreate+0xde>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
    3a7a:	80 91 be 01 	lds	r24, 0x01BE
    3a7e:	90 91 bf 01 	lds	r25, 0x01BF
    3a82:	89 2b       	or	r24, r25
    3a84:	21 f5       	brne	.+72     	; 0x3ace <xCoRoutineCreate+0x80>
            {
                pxCurrentCoRoutine = pxCoRoutine;
    3a86:	d0 93 bf 01 	sts	0x01BF, r29
    3a8a:	c0 93 be 01 	sts	0x01BE, r28
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    3a8e:	8b ec       	ldi	r24, 0xCB	; 203
    3a90:	91 e0       	ldi	r25, 0x01	; 1
    3a92:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
    3a96:	84 ed       	ldi	r24, 0xD4	; 212
    3a98:	91 e0       	ldi	r25, 0x01	; 1
    3a9a:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    3a9e:	2d ed       	ldi	r18, 0xDD	; 221
    3aa0:	e2 2e       	mov	r14, r18
    3aa2:	21 e0       	ldi	r18, 0x01	; 1
    3aa4:	f2 2e       	mov	r15, r18
    3aa6:	c7 01       	movw	r24, r14
    3aa8:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    3aac:	06 ee       	ldi	r16, 0xE6	; 230
    3aae:	11 e0       	ldi	r17, 0x01	; 1
    3ab0:	c8 01       	movw	r24, r16
    3ab2:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    3ab6:	8f ee       	ldi	r24, 0xEF	; 239
    3ab8:	91 e0       	ldi	r25, 0x01	; 1
    3aba:	0e 94 4b 1b 	call	0x3696	; 0x3696 <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    3abe:	f0 92 c1 01 	sts	0x01C1, r15
    3ac2:	e0 92 c0 01 	sts	0x01C0, r14
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    3ac6:	10 93 ca 01 	sts	0x01CA, r17
    3aca:	00 93 c9 01 	sts	0x01C9, r16
    3ace:	eb 2c       	mov	r14, r11
    3ad0:	bb 20       	and	r11, r11
    3ad2:	11 f0       	breq	.+4      	; 0x3ad8 <xCoRoutineCreate+0x8a>
    3ad4:	ee 24       	eor	r14, r14
    3ad6:	e3 94       	inc	r14
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
    3ad8:	19 8e       	std	Y+25, r1	; 0x19
    3ada:	18 8e       	std	Y+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
    3adc:	ee 8a       	std	Y+22, r14	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
    3ade:	af 8a       	std	Y+23, r10	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    3ae0:	fe 01       	movw	r30, r28
    3ae2:	c1 92       	st	Z+, r12
    3ae4:	d1 92       	st	Z+, r13
    3ae6:	8f 01       	movw	r16, r30

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    3ae8:	cf 01       	movw	r24, r30
    3aea:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    3aee:	ce 01       	movw	r24, r28
    3af0:	0c 96       	adiw	r24, 0x0c	; 12
    3af2:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    3af6:	d9 87       	std	Y+9, r29	; 0x09
    3af8:	c8 87       	std	Y+8, r28	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    3afa:	db 8b       	std	Y+19, r29	; 0x13
    3afc:	ca 8b       	std	Y+18, r28	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    3afe:	82 e0       	ldi	r24, 0x02	; 2
    3b00:	90 e0       	ldi	r25, 0x00	; 0
    3b02:	8e 19       	sub	r24, r14
    3b04:	91 09       	sbc	r25, r1
    3b06:	9d 87       	std	Y+13, r25	; 0x0d
    3b08:	8c 87       	std	Y+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
    3b0a:	9e 89       	ldd	r25, Y+22	; 0x16
    3b0c:	80 91 c2 01 	lds	r24, 0x01C2
    3b10:	89 17       	cp	r24, r25
    3b12:	10 f4       	brcc	.+4      	; 0x3b18 <xCoRoutineCreate+0xca>
    3b14:	90 93 c2 01 	sts	0x01C2, r25
    3b18:	89 e0       	ldi	r24, 0x09	; 9
    3b1a:	98 9f       	mul	r25, r24
    3b1c:	c0 01       	movw	r24, r0
    3b1e:	11 24       	eor	r1, r1
    3b20:	85 53       	subi	r24, 0x35	; 53
    3b22:	9e 4f       	sbci	r25, 0xFE	; 254
    3b24:	b8 01       	movw	r22, r16
    3b26:	0e 94 5f 1b 	call	0x36be	; 0x36be <vListInsertEnd>
    3b2a:	81 e0       	ldi	r24, 0x01	; 1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
    3b2c:	df 91       	pop	r29
    3b2e:	cf 91       	pop	r28
    3b30:	1f 91       	pop	r17
    3b32:	0f 91       	pop	r16
    3b34:	ff 90       	pop	r15
    3b36:	ef 90       	pop	r14
    3b38:	df 90       	pop	r13
    3b3a:	cf 90       	pop	r12
    3b3c:	bf 90       	pop	r11
    3b3e:	af 90       	pop	r10
    3b40:	08 95       	ret

00003b42 <vPortFree>:
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
    3b42:	08 95       	ret

00003b44 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
    3b44:	10 92 f9 01 	sts	0x01F9, r1
    3b48:	10 92 f8 01 	sts	0x01F8, r1
}
    3b4c:	08 95       	ret

00003b4e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    3b4e:	2b ed       	ldi	r18, 0xDB	; 219
    3b50:	35 e0       	ldi	r19, 0x05	; 5
    3b52:	80 91 f8 01 	lds	r24, 0x01F8
    3b56:	90 91 f9 01 	lds	r25, 0x01F9
    3b5a:	28 1b       	sub	r18, r24
    3b5c:	39 0b       	sbc	r19, r25
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
}
    3b5e:	c9 01       	movw	r24, r18
    3b60:	08 95       	ret

00003b62 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    3b62:	cf 93       	push	r28
    3b64:	df 93       	push	r29
    3b66:	ec 01       	movw	r28, r24
                }
            }
        }
    #endif

    vTaskSuspendAll();
    3b68:	0e 94 0e 0b 	call	0x161c	; 0x161c <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
    3b6c:	80 91 fa 01 	lds	r24, 0x01FA
    3b70:	90 91 fb 01 	lds	r25, 0x01FB
    3b74:	89 2b       	or	r24, r25
    3b76:	31 f4       	brne	.+12     	; 0x3b84 <pvPortMalloc+0x22>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    3b78:	8d ef       	ldi	r24, 0xFD	; 253
    3b7a:	91 e0       	ldi	r25, 0x01	; 1
    3b7c:	90 93 fb 01 	sts	0x01FB, r25
    3b80:	80 93 fa 01 	sts	0x01FA, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
    3b84:	20 97       	sbiw	r28, 0x00	; 0
    3b86:	c9 f0       	breq	.+50     	; 0x3bba <pvPortMalloc+0x58>
    3b88:	20 91 f8 01 	lds	r18, 0x01F8
    3b8c:	30 91 f9 01 	lds	r19, 0x01F9
    3b90:	ce 01       	movw	r24, r28
    3b92:	82 0f       	add	r24, r18
    3b94:	93 1f       	adc	r25, r19
    3b96:	45 e0       	ldi	r20, 0x05	; 5
    3b98:	8b 3d       	cpi	r24, 0xDB	; 219
    3b9a:	94 07       	cpc	r25, r20
    3b9c:	70 f4       	brcc	.+28     	; 0x3bba <pvPortMalloc+0x58>
    3b9e:	28 17       	cp	r18, r24
    3ba0:	39 07       	cpc	r19, r25
    3ba2:	58 f4       	brcc	.+22     	; 0x3bba <pvPortMalloc+0x58>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
    3ba4:	c0 91 fa 01 	lds	r28, 0x01FA
    3ba8:	d0 91 fb 01 	lds	r29, 0x01FB
    3bac:	c2 0f       	add	r28, r18
    3bae:	d3 1f       	adc	r29, r19
            xNextFreeByte += xWantedSize;
    3bb0:	90 93 f9 01 	sts	0x01F9, r25
    3bb4:	80 93 f8 01 	sts	0x01F8, r24
    3bb8:	02 c0       	rjmp	.+4      	; 0x3bbe <pvPortMalloc+0x5c>
    3bba:	c0 e0       	ldi	r28, 0x00	; 0
    3bbc:	d0 e0       	ldi	r29, 0x00	; 0
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    3bbe:	0e 94 2a 10 	call	0x2054	; 0x2054 <xTaskResumeAll>
            }
        }
    #endif

    return pvReturn;
}
    3bc2:	ce 01       	movw	r24, r28
    3bc4:	df 91       	pop	r29
    3bc6:	cf 91       	pop	r28
    3bc8:	08 95       	ret

00003bca <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    3bca:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    3bcc:	91 e1       	ldi	r25, 0x11	; 17
    3bce:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    3bd0:	22 e2       	ldi	r18, 0x22	; 34
    3bd2:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    3bd4:	83 e3       	ldi	r24, 0x33	; 51
    3bd6:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3bd8:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3bda:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    3bdc:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3bde:	80 e8       	ldi	r24, 0x80	; 128
    3be0:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    3be2:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    3be4:	82 e0       	ldi	r24, 0x02	; 2
    3be6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    3be8:	83 e0       	ldi	r24, 0x03	; 3
    3bea:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    3bec:	84 e0       	ldi	r24, 0x04	; 4
    3bee:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    3bf0:	85 e0       	ldi	r24, 0x05	; 5
    3bf2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    3bf4:	86 e0       	ldi	r24, 0x06	; 6
    3bf6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    3bf8:	87 e0       	ldi	r24, 0x07	; 7
    3bfa:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    3bfc:	88 e0       	ldi	r24, 0x08	; 8
    3bfe:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    3c00:	89 e0       	ldi	r24, 0x09	; 9
    3c02:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    3c04:	80 e1       	ldi	r24, 0x10	; 16
    3c06:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    3c08:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    3c0a:	82 e1       	ldi	r24, 0x12	; 18
    3c0c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    3c0e:	83 e1       	ldi	r24, 0x13	; 19
    3c10:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    3c12:	84 e1       	ldi	r24, 0x14	; 20
    3c14:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    3c16:	85 e1       	ldi	r24, 0x15	; 21
    3c18:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    3c1a:	86 e1       	ldi	r24, 0x16	; 22
    3c1c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    3c1e:	87 e1       	ldi	r24, 0x17	; 23
    3c20:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    3c22:	88 e1       	ldi	r24, 0x18	; 24
    3c24:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    3c26:	89 e1       	ldi	r24, 0x19	; 25
    3c28:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    3c2a:	80 e2       	ldi	r24, 0x20	; 32
    3c2c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    3c2e:	81 e2       	ldi	r24, 0x21	; 33
    3c30:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    3c32:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    3c34:	83 e2       	ldi	r24, 0x23	; 35
    3c36:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3c38:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3c3a:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    3c3c:	86 e2       	ldi	r24, 0x26	; 38
    3c3e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    3c40:	87 e2       	ldi	r24, 0x27	; 39
    3c42:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    3c44:	88 e2       	ldi	r24, 0x28	; 40
    3c46:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    3c48:	89 e2       	ldi	r24, 0x29	; 41
    3c4a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    3c4c:	80 e3       	ldi	r24, 0x30	; 48
    3c4e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    3c50:	81 e3       	ldi	r24, 0x31	; 49
    3c52:	82 93       	st	-Z, r24
    3c54:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    3c56:	cf 01       	movw	r24, r30
    3c58:	08 95       	ret

00003c5a <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    3c5a:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    3c5e:	85 ea       	ldi	r24, 0xA5	; 165
    3c60:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = 0;
	ucLowByte |= (portCTC_MODE_A);
	TCCR1A = ucLowByte;
    3c64:	10 92 80 00 	sts	0x0080, r1
	
	ucLowByte = 0;
	ucLowByte |= (portCTC_MODE_B | portPRESCALE_64);
	TCCR1B = ucLowByte;
    3c68:	8b e0       	ldi	r24, 0x0B	; 11
    3c6a:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = 0;
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
	TIMSK1 = ucLowByte;
    3c6e:	82 e0       	ldi	r24, 0x02	; 2
    3c70:	80 93 6f 00 	sts	0x006F, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3c74:	a0 91 57 01 	lds	r26, 0x0157
    3c78:	b0 91 58 01 	lds	r27, 0x0158
    3c7c:	cd 91       	ld	r28, X+
    3c7e:	cd bf       	out	0x3d, r28	; 61
    3c80:	dd 91       	ld	r29, X+
    3c82:	de bf       	out	0x3e, r29	; 62
    3c84:	ff 91       	pop	r31
    3c86:	ef 91       	pop	r30
    3c88:	df 91       	pop	r29
    3c8a:	cf 91       	pop	r28
    3c8c:	bf 91       	pop	r27
    3c8e:	af 91       	pop	r26
    3c90:	9f 91       	pop	r25
    3c92:	8f 91       	pop	r24
    3c94:	7f 91       	pop	r23
    3c96:	6f 91       	pop	r22
    3c98:	5f 91       	pop	r21
    3c9a:	4f 91       	pop	r20
    3c9c:	3f 91       	pop	r19
    3c9e:	2f 91       	pop	r18
    3ca0:	1f 91       	pop	r17
    3ca2:	0f 91       	pop	r16
    3ca4:	ff 90       	pop	r15
    3ca6:	ef 90       	pop	r14
    3ca8:	df 90       	pop	r13
    3caa:	cf 90       	pop	r12
    3cac:	bf 90       	pop	r11
    3cae:	af 90       	pop	r10
    3cb0:	9f 90       	pop	r9
    3cb2:	8f 90       	pop	r8
    3cb4:	7f 90       	pop	r7
    3cb6:	6f 90       	pop	r6
    3cb8:	5f 90       	pop	r5
    3cba:	4f 90       	pop	r4
    3cbc:	3f 90       	pop	r3
    3cbe:	2f 90       	pop	r2
    3cc0:	1f 90       	pop	r1
    3cc2:	0f 90       	pop	r0
    3cc4:	0f be       	out	0x3f, r0	; 63
    3cc6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3cc8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    3cca:	81 e0       	ldi	r24, 0x01	; 1
    3ccc:	08 95       	ret

00003cce <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    3cce:	08 95       	ret

00003cd0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3cd0:	0f 92       	push	r0
    3cd2:	0f b6       	in	r0, 0x3f	; 63
    3cd4:	f8 94       	cli
    3cd6:	0f 92       	push	r0
    3cd8:	1f 92       	push	r1
    3cda:	11 24       	eor	r1, r1
    3cdc:	2f 92       	push	r2
    3cde:	3f 92       	push	r3
    3ce0:	4f 92       	push	r4
    3ce2:	5f 92       	push	r5
    3ce4:	6f 92       	push	r6
    3ce6:	7f 92       	push	r7
    3ce8:	8f 92       	push	r8
    3cea:	9f 92       	push	r9
    3cec:	af 92       	push	r10
    3cee:	bf 92       	push	r11
    3cf0:	cf 92       	push	r12
    3cf2:	df 92       	push	r13
    3cf4:	ef 92       	push	r14
    3cf6:	ff 92       	push	r15
    3cf8:	0f 93       	push	r16
    3cfa:	1f 93       	push	r17
    3cfc:	2f 93       	push	r18
    3cfe:	3f 93       	push	r19
    3d00:	4f 93       	push	r20
    3d02:	5f 93       	push	r21
    3d04:	6f 93       	push	r22
    3d06:	7f 93       	push	r23
    3d08:	8f 93       	push	r24
    3d0a:	9f 93       	push	r25
    3d0c:	af 93       	push	r26
    3d0e:	bf 93       	push	r27
    3d10:	cf 93       	push	r28
    3d12:	df 93       	push	r29
    3d14:	ef 93       	push	r30
    3d16:	ff 93       	push	r31
    3d18:	a0 91 57 01 	lds	r26, 0x0157
    3d1c:	b0 91 58 01 	lds	r27, 0x0158
    3d20:	0d b6       	in	r0, 0x3d	; 61
    3d22:	0d 92       	st	X+, r0
    3d24:	0e b6       	in	r0, 0x3e	; 62
    3d26:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    3d28:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <xTaskIncrementTick>
    3d2c:	88 23       	and	r24, r24
    3d2e:	11 f0       	breq	.+4      	; 0x3d34 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    3d30:	0e 94 33 0b 	call	0x1666	; 0x1666 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    3d34:	a0 91 57 01 	lds	r26, 0x0157
    3d38:	b0 91 58 01 	lds	r27, 0x0158
    3d3c:	cd 91       	ld	r28, X+
    3d3e:	cd bf       	out	0x3d, r28	; 61
    3d40:	dd 91       	ld	r29, X+
    3d42:	de bf       	out	0x3e, r29	; 62
    3d44:	ff 91       	pop	r31
    3d46:	ef 91       	pop	r30
    3d48:	df 91       	pop	r29
    3d4a:	cf 91       	pop	r28
    3d4c:	bf 91       	pop	r27
    3d4e:	af 91       	pop	r26
    3d50:	9f 91       	pop	r25
    3d52:	8f 91       	pop	r24
    3d54:	7f 91       	pop	r23
    3d56:	6f 91       	pop	r22
    3d58:	5f 91       	pop	r21
    3d5a:	4f 91       	pop	r20
    3d5c:	3f 91       	pop	r19
    3d5e:	2f 91       	pop	r18
    3d60:	1f 91       	pop	r17
    3d62:	0f 91       	pop	r16
    3d64:	ff 90       	pop	r15
    3d66:	ef 90       	pop	r14
    3d68:	df 90       	pop	r13
    3d6a:	cf 90       	pop	r12
    3d6c:	bf 90       	pop	r11
    3d6e:	af 90       	pop	r10
    3d70:	9f 90       	pop	r9
    3d72:	8f 90       	pop	r8
    3d74:	7f 90       	pop	r7
    3d76:	6f 90       	pop	r6
    3d78:	5f 90       	pop	r5
    3d7a:	4f 90       	pop	r4
    3d7c:	3f 90       	pop	r3
    3d7e:	2f 90       	pop	r2
    3d80:	1f 90       	pop	r1
    3d82:	0f 90       	pop	r0
    3d84:	0f be       	out	0x3f, r0	; 63
    3d86:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3d88:	08 95       	ret

00003d8a <__vector_13>:
	 */
	//void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	//void SIG_OUTPUT_COMPARE1A( void )
	ISR(TIMER1_COMPA_vect, ISR_NAKED)
	{
		vPortYieldFromTick();
    3d8a:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3d8e:	18 95       	reti

00003d90 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3d90:	0f 92       	push	r0
    3d92:	0f b6       	in	r0, 0x3f	; 63
    3d94:	f8 94       	cli
    3d96:	0f 92       	push	r0
    3d98:	1f 92       	push	r1
    3d9a:	11 24       	eor	r1, r1
    3d9c:	2f 92       	push	r2
    3d9e:	3f 92       	push	r3
    3da0:	4f 92       	push	r4
    3da2:	5f 92       	push	r5
    3da4:	6f 92       	push	r6
    3da6:	7f 92       	push	r7
    3da8:	8f 92       	push	r8
    3daa:	9f 92       	push	r9
    3dac:	af 92       	push	r10
    3dae:	bf 92       	push	r11
    3db0:	cf 92       	push	r12
    3db2:	df 92       	push	r13
    3db4:	ef 92       	push	r14
    3db6:	ff 92       	push	r15
    3db8:	0f 93       	push	r16
    3dba:	1f 93       	push	r17
    3dbc:	2f 93       	push	r18
    3dbe:	3f 93       	push	r19
    3dc0:	4f 93       	push	r20
    3dc2:	5f 93       	push	r21
    3dc4:	6f 93       	push	r22
    3dc6:	7f 93       	push	r23
    3dc8:	8f 93       	push	r24
    3dca:	9f 93       	push	r25
    3dcc:	af 93       	push	r26
    3dce:	bf 93       	push	r27
    3dd0:	cf 93       	push	r28
    3dd2:	df 93       	push	r29
    3dd4:	ef 93       	push	r30
    3dd6:	ff 93       	push	r31
    3dd8:	a0 91 57 01 	lds	r26, 0x0157
    3ddc:	b0 91 58 01 	lds	r27, 0x0158
    3de0:	0d b6       	in	r0, 0x3d	; 61
    3de2:	0d 92       	st	X+, r0
    3de4:	0e b6       	in	r0, 0x3e	; 62
    3de6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3de8:	0e 94 33 0b 	call	0x1666	; 0x1666 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3dec:	a0 91 57 01 	lds	r26, 0x0157
    3df0:	b0 91 58 01 	lds	r27, 0x0158
    3df4:	cd 91       	ld	r28, X+
    3df6:	cd bf       	out	0x3d, r28	; 61
    3df8:	dd 91       	ld	r29, X+
    3dfa:	de bf       	out	0x3e, r29	; 62
    3dfc:	ff 91       	pop	r31
    3dfe:	ef 91       	pop	r30
    3e00:	df 91       	pop	r29
    3e02:	cf 91       	pop	r28
    3e04:	bf 91       	pop	r27
    3e06:	af 91       	pop	r26
    3e08:	9f 91       	pop	r25
    3e0a:	8f 91       	pop	r24
    3e0c:	7f 91       	pop	r23
    3e0e:	6f 91       	pop	r22
    3e10:	5f 91       	pop	r21
    3e12:	4f 91       	pop	r20
    3e14:	3f 91       	pop	r19
    3e16:	2f 91       	pop	r18
    3e18:	1f 91       	pop	r17
    3e1a:	0f 91       	pop	r16
    3e1c:	ff 90       	pop	r15
    3e1e:	ef 90       	pop	r14
    3e20:	df 90       	pop	r13
    3e22:	cf 90       	pop	r12
    3e24:	bf 90       	pop	r11
    3e26:	af 90       	pop	r10
    3e28:	9f 90       	pop	r9
    3e2a:	8f 90       	pop	r8
    3e2c:	7f 90       	pop	r7
    3e2e:	6f 90       	pop	r6
    3e30:	5f 90       	pop	r5
    3e32:	4f 90       	pop	r4
    3e34:	3f 90       	pop	r3
    3e36:	2f 90       	pop	r2
    3e38:	1f 90       	pop	r1
    3e3a:	0f 90       	pop	r0
    3e3c:	0f be       	out	0x3f, r0	; 63
    3e3e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3e40:	08 95       	ret

00003e42 <__subsf3>:
    3e42:	50 58       	subi	r21, 0x80	; 128

00003e44 <__addsf3>:
    3e44:	bb 27       	eor	r27, r27
    3e46:	aa 27       	eor	r26, r26
    3e48:	0e d0       	rcall	.+28     	; 0x3e66 <__addsf3x>
    3e4a:	48 c1       	rjmp	.+656    	; 0x40dc <__fp_round>
    3e4c:	39 d1       	rcall	.+626    	; 0x40c0 <__fp_pscA>
    3e4e:	30 f0       	brcs	.+12     	; 0x3e5c <__addsf3+0x18>
    3e50:	3e d1       	rcall	.+636    	; 0x40ce <__fp_pscB>
    3e52:	20 f0       	brcs	.+8      	; 0x3e5c <__addsf3+0x18>
    3e54:	31 f4       	brne	.+12     	; 0x3e62 <__addsf3+0x1e>
    3e56:	9f 3f       	cpi	r25, 0xFF	; 255
    3e58:	11 f4       	brne	.+4      	; 0x3e5e <__addsf3+0x1a>
    3e5a:	1e f4       	brtc	.+6      	; 0x3e62 <__addsf3+0x1e>
    3e5c:	2e c1       	rjmp	.+604    	; 0x40ba <__fp_nan>
    3e5e:	0e f4       	brtc	.+2      	; 0x3e62 <__addsf3+0x1e>
    3e60:	e0 95       	com	r30
    3e62:	e7 fb       	bst	r30, 7
    3e64:	24 c1       	rjmp	.+584    	; 0x40ae <__fp_inf>

00003e66 <__addsf3x>:
    3e66:	e9 2f       	mov	r30, r25
    3e68:	4a d1       	rcall	.+660    	; 0x40fe <__fp_split3>
    3e6a:	80 f3       	brcs	.-32     	; 0x3e4c <__addsf3+0x8>
    3e6c:	ba 17       	cp	r27, r26
    3e6e:	62 07       	cpc	r22, r18
    3e70:	73 07       	cpc	r23, r19
    3e72:	84 07       	cpc	r24, r20
    3e74:	95 07       	cpc	r25, r21
    3e76:	18 f0       	brcs	.+6      	; 0x3e7e <__addsf3x+0x18>
    3e78:	71 f4       	brne	.+28     	; 0x3e96 <__addsf3x+0x30>
    3e7a:	9e f5       	brtc	.+102    	; 0x3ee2 <__addsf3x+0x7c>
    3e7c:	62 c1       	rjmp	.+708    	; 0x4142 <__fp_zero>
    3e7e:	0e f4       	brtc	.+2      	; 0x3e82 <__addsf3x+0x1c>
    3e80:	e0 95       	com	r30
    3e82:	0b 2e       	mov	r0, r27
    3e84:	ba 2f       	mov	r27, r26
    3e86:	a0 2d       	mov	r26, r0
    3e88:	0b 01       	movw	r0, r22
    3e8a:	b9 01       	movw	r22, r18
    3e8c:	90 01       	movw	r18, r0
    3e8e:	0c 01       	movw	r0, r24
    3e90:	ca 01       	movw	r24, r20
    3e92:	a0 01       	movw	r20, r0
    3e94:	11 24       	eor	r1, r1
    3e96:	ff 27       	eor	r31, r31
    3e98:	59 1b       	sub	r21, r25
    3e9a:	99 f0       	breq	.+38     	; 0x3ec2 <__addsf3x+0x5c>
    3e9c:	59 3f       	cpi	r21, 0xF9	; 249
    3e9e:	50 f4       	brcc	.+20     	; 0x3eb4 <__addsf3x+0x4e>
    3ea0:	50 3e       	cpi	r21, 0xE0	; 224
    3ea2:	68 f1       	brcs	.+90     	; 0x3efe <__addsf3x+0x98>
    3ea4:	1a 16       	cp	r1, r26
    3ea6:	f0 40       	sbci	r31, 0x00	; 0
    3ea8:	a2 2f       	mov	r26, r18
    3eaa:	23 2f       	mov	r18, r19
    3eac:	34 2f       	mov	r19, r20
    3eae:	44 27       	eor	r20, r20
    3eb0:	58 5f       	subi	r21, 0xF8	; 248
    3eb2:	f3 cf       	rjmp	.-26     	; 0x3e9a <__addsf3x+0x34>
    3eb4:	46 95       	lsr	r20
    3eb6:	37 95       	ror	r19
    3eb8:	27 95       	ror	r18
    3eba:	a7 95       	ror	r26
    3ebc:	f0 40       	sbci	r31, 0x00	; 0
    3ebe:	53 95       	inc	r21
    3ec0:	c9 f7       	brne	.-14     	; 0x3eb4 <__addsf3x+0x4e>
    3ec2:	7e f4       	brtc	.+30     	; 0x3ee2 <__addsf3x+0x7c>
    3ec4:	1f 16       	cp	r1, r31
    3ec6:	ba 0b       	sbc	r27, r26
    3ec8:	62 0b       	sbc	r22, r18
    3eca:	73 0b       	sbc	r23, r19
    3ecc:	84 0b       	sbc	r24, r20
    3ece:	ba f0       	brmi	.+46     	; 0x3efe <__addsf3x+0x98>
    3ed0:	91 50       	subi	r25, 0x01	; 1
    3ed2:	a1 f0       	breq	.+40     	; 0x3efc <__addsf3x+0x96>
    3ed4:	ff 0f       	add	r31, r31
    3ed6:	bb 1f       	adc	r27, r27
    3ed8:	66 1f       	adc	r22, r22
    3eda:	77 1f       	adc	r23, r23
    3edc:	88 1f       	adc	r24, r24
    3ede:	c2 f7       	brpl	.-16     	; 0x3ed0 <__addsf3x+0x6a>
    3ee0:	0e c0       	rjmp	.+28     	; 0x3efe <__addsf3x+0x98>
    3ee2:	ba 0f       	add	r27, r26
    3ee4:	62 1f       	adc	r22, r18
    3ee6:	73 1f       	adc	r23, r19
    3ee8:	84 1f       	adc	r24, r20
    3eea:	48 f4       	brcc	.+18     	; 0x3efe <__addsf3x+0x98>
    3eec:	87 95       	ror	r24
    3eee:	77 95       	ror	r23
    3ef0:	67 95       	ror	r22
    3ef2:	b7 95       	ror	r27
    3ef4:	f7 95       	ror	r31
    3ef6:	9e 3f       	cpi	r25, 0xFE	; 254
    3ef8:	08 f0       	brcs	.+2      	; 0x3efc <__addsf3x+0x96>
    3efa:	b3 cf       	rjmp	.-154    	; 0x3e62 <__addsf3+0x1e>
    3efc:	93 95       	inc	r25
    3efe:	88 0f       	add	r24, r24
    3f00:	08 f0       	brcs	.+2      	; 0x3f04 <__addsf3x+0x9e>
    3f02:	99 27       	eor	r25, r25
    3f04:	ee 0f       	add	r30, r30
    3f06:	97 95       	ror	r25
    3f08:	87 95       	ror	r24
    3f0a:	08 95       	ret

00003f0c <__divsf3>:
    3f0c:	0c d0       	rcall	.+24     	; 0x3f26 <__divsf3x>
    3f0e:	e6 c0       	rjmp	.+460    	; 0x40dc <__fp_round>
    3f10:	de d0       	rcall	.+444    	; 0x40ce <__fp_pscB>
    3f12:	40 f0       	brcs	.+16     	; 0x3f24 <__divsf3+0x18>
    3f14:	d5 d0       	rcall	.+426    	; 0x40c0 <__fp_pscA>
    3f16:	30 f0       	brcs	.+12     	; 0x3f24 <__divsf3+0x18>
    3f18:	21 f4       	brne	.+8      	; 0x3f22 <__divsf3+0x16>
    3f1a:	5f 3f       	cpi	r21, 0xFF	; 255
    3f1c:	19 f0       	breq	.+6      	; 0x3f24 <__divsf3+0x18>
    3f1e:	c7 c0       	rjmp	.+398    	; 0x40ae <__fp_inf>
    3f20:	51 11       	cpse	r21, r1
    3f22:	10 c1       	rjmp	.+544    	; 0x4144 <__fp_szero>
    3f24:	ca c0       	rjmp	.+404    	; 0x40ba <__fp_nan>

00003f26 <__divsf3x>:
    3f26:	eb d0       	rcall	.+470    	; 0x40fe <__fp_split3>
    3f28:	98 f3       	brcs	.-26     	; 0x3f10 <__divsf3+0x4>

00003f2a <__divsf3_pse>:
    3f2a:	99 23       	and	r25, r25
    3f2c:	c9 f3       	breq	.-14     	; 0x3f20 <__divsf3+0x14>
    3f2e:	55 23       	and	r21, r21
    3f30:	b1 f3       	breq	.-20     	; 0x3f1e <__divsf3+0x12>
    3f32:	95 1b       	sub	r25, r21
    3f34:	55 0b       	sbc	r21, r21
    3f36:	bb 27       	eor	r27, r27
    3f38:	aa 27       	eor	r26, r26
    3f3a:	62 17       	cp	r22, r18
    3f3c:	73 07       	cpc	r23, r19
    3f3e:	84 07       	cpc	r24, r20
    3f40:	38 f0       	brcs	.+14     	; 0x3f50 <__divsf3_pse+0x26>
    3f42:	9f 5f       	subi	r25, 0xFF	; 255
    3f44:	5f 4f       	sbci	r21, 0xFF	; 255
    3f46:	22 0f       	add	r18, r18
    3f48:	33 1f       	adc	r19, r19
    3f4a:	44 1f       	adc	r20, r20
    3f4c:	aa 1f       	adc	r26, r26
    3f4e:	a9 f3       	breq	.-22     	; 0x3f3a <__divsf3_pse+0x10>
    3f50:	33 d0       	rcall	.+102    	; 0x3fb8 <__divsf3_pse+0x8e>
    3f52:	0e 2e       	mov	r0, r30
    3f54:	3a f0       	brmi	.+14     	; 0x3f64 <__divsf3_pse+0x3a>
    3f56:	e0 e8       	ldi	r30, 0x80	; 128
    3f58:	30 d0       	rcall	.+96     	; 0x3fba <__divsf3_pse+0x90>
    3f5a:	91 50       	subi	r25, 0x01	; 1
    3f5c:	50 40       	sbci	r21, 0x00	; 0
    3f5e:	e6 95       	lsr	r30
    3f60:	00 1c       	adc	r0, r0
    3f62:	ca f7       	brpl	.-14     	; 0x3f56 <__divsf3_pse+0x2c>
    3f64:	29 d0       	rcall	.+82     	; 0x3fb8 <__divsf3_pse+0x8e>
    3f66:	fe 2f       	mov	r31, r30
    3f68:	27 d0       	rcall	.+78     	; 0x3fb8 <__divsf3_pse+0x8e>
    3f6a:	66 0f       	add	r22, r22
    3f6c:	77 1f       	adc	r23, r23
    3f6e:	88 1f       	adc	r24, r24
    3f70:	bb 1f       	adc	r27, r27
    3f72:	26 17       	cp	r18, r22
    3f74:	37 07       	cpc	r19, r23
    3f76:	48 07       	cpc	r20, r24
    3f78:	ab 07       	cpc	r26, r27
    3f7a:	b0 e8       	ldi	r27, 0x80	; 128
    3f7c:	09 f0       	breq	.+2      	; 0x3f80 <__divsf3_pse+0x56>
    3f7e:	bb 0b       	sbc	r27, r27
    3f80:	80 2d       	mov	r24, r0
    3f82:	bf 01       	movw	r22, r30
    3f84:	ff 27       	eor	r31, r31
    3f86:	93 58       	subi	r25, 0x83	; 131
    3f88:	5f 4f       	sbci	r21, 0xFF	; 255
    3f8a:	2a f0       	brmi	.+10     	; 0x3f96 <__divsf3_pse+0x6c>
    3f8c:	9e 3f       	cpi	r25, 0xFE	; 254
    3f8e:	51 05       	cpc	r21, r1
    3f90:	68 f0       	brcs	.+26     	; 0x3fac <__divsf3_pse+0x82>
    3f92:	8d c0       	rjmp	.+282    	; 0x40ae <__fp_inf>
    3f94:	d7 c0       	rjmp	.+430    	; 0x4144 <__fp_szero>
    3f96:	5f 3f       	cpi	r21, 0xFF	; 255
    3f98:	ec f3       	brlt	.-6      	; 0x3f94 <__divsf3_pse+0x6a>
    3f9a:	98 3e       	cpi	r25, 0xE8	; 232
    3f9c:	dc f3       	brlt	.-10     	; 0x3f94 <__divsf3_pse+0x6a>
    3f9e:	86 95       	lsr	r24
    3fa0:	77 95       	ror	r23
    3fa2:	67 95       	ror	r22
    3fa4:	b7 95       	ror	r27
    3fa6:	f7 95       	ror	r31
    3fa8:	9f 5f       	subi	r25, 0xFF	; 255
    3faa:	c9 f7       	brne	.-14     	; 0x3f9e <__divsf3_pse+0x74>
    3fac:	88 0f       	add	r24, r24
    3fae:	91 1d       	adc	r25, r1
    3fb0:	96 95       	lsr	r25
    3fb2:	87 95       	ror	r24
    3fb4:	97 f9       	bld	r25, 7
    3fb6:	08 95       	ret
    3fb8:	e1 e0       	ldi	r30, 0x01	; 1
    3fba:	66 0f       	add	r22, r22
    3fbc:	77 1f       	adc	r23, r23
    3fbe:	88 1f       	adc	r24, r24
    3fc0:	bb 1f       	adc	r27, r27
    3fc2:	62 17       	cp	r22, r18
    3fc4:	73 07       	cpc	r23, r19
    3fc6:	84 07       	cpc	r24, r20
    3fc8:	ba 07       	cpc	r27, r26
    3fca:	20 f0       	brcs	.+8      	; 0x3fd4 <__divsf3_pse+0xaa>
    3fcc:	62 1b       	sub	r22, r18
    3fce:	73 0b       	sbc	r23, r19
    3fd0:	84 0b       	sbc	r24, r20
    3fd2:	ba 0b       	sbc	r27, r26
    3fd4:	ee 1f       	adc	r30, r30
    3fd6:	88 f7       	brcc	.-30     	; 0x3fba <__divsf3_pse+0x90>
    3fd8:	e0 95       	com	r30
    3fda:	08 95       	ret

00003fdc <__fixunssfsi>:
    3fdc:	98 d0       	rcall	.+304    	; 0x410e <__fp_splitA>
    3fde:	88 f0       	brcs	.+34     	; 0x4002 <__fixunssfsi+0x26>
    3fe0:	9f 57       	subi	r25, 0x7F	; 127
    3fe2:	90 f0       	brcs	.+36     	; 0x4008 <__fixunssfsi+0x2c>
    3fe4:	b9 2f       	mov	r27, r25
    3fe6:	99 27       	eor	r25, r25
    3fe8:	b7 51       	subi	r27, 0x17	; 23
    3fea:	a0 f0       	brcs	.+40     	; 0x4014 <__fixunssfsi+0x38>
    3fec:	d1 f0       	breq	.+52     	; 0x4022 <__fixunssfsi+0x46>
    3fee:	66 0f       	add	r22, r22
    3ff0:	77 1f       	adc	r23, r23
    3ff2:	88 1f       	adc	r24, r24
    3ff4:	99 1f       	adc	r25, r25
    3ff6:	1a f0       	brmi	.+6      	; 0x3ffe <__fixunssfsi+0x22>
    3ff8:	ba 95       	dec	r27
    3ffa:	c9 f7       	brne	.-14     	; 0x3fee <__fixunssfsi+0x12>
    3ffc:	12 c0       	rjmp	.+36     	; 0x4022 <__fixunssfsi+0x46>
    3ffe:	b1 30       	cpi	r27, 0x01	; 1
    4000:	81 f0       	breq	.+32     	; 0x4022 <__fixunssfsi+0x46>
    4002:	9f d0       	rcall	.+318    	; 0x4142 <__fp_zero>
    4004:	b1 e0       	ldi	r27, 0x01	; 1
    4006:	08 95       	ret
    4008:	9c c0       	rjmp	.+312    	; 0x4142 <__fp_zero>
    400a:	67 2f       	mov	r22, r23
    400c:	78 2f       	mov	r23, r24
    400e:	88 27       	eor	r24, r24
    4010:	b8 5f       	subi	r27, 0xF8	; 248
    4012:	39 f0       	breq	.+14     	; 0x4022 <__fixunssfsi+0x46>
    4014:	b9 3f       	cpi	r27, 0xF9	; 249
    4016:	cc f3       	brlt	.-14     	; 0x400a <__fixunssfsi+0x2e>
    4018:	86 95       	lsr	r24
    401a:	77 95       	ror	r23
    401c:	67 95       	ror	r22
    401e:	b3 95       	inc	r27
    4020:	d9 f7       	brne	.-10     	; 0x4018 <__fixunssfsi+0x3c>
    4022:	3e f4       	brtc	.+14     	; 0x4032 <__fixunssfsi+0x56>
    4024:	90 95       	com	r25
    4026:	80 95       	com	r24
    4028:	70 95       	com	r23
    402a:	61 95       	neg	r22
    402c:	7f 4f       	sbci	r23, 0xFF	; 255
    402e:	8f 4f       	sbci	r24, 0xFF	; 255
    4030:	9f 4f       	sbci	r25, 0xFF	; 255
    4032:	08 95       	ret

00004034 <__floatunsisf>:
    4034:	e8 94       	clt
    4036:	09 c0       	rjmp	.+18     	; 0x404a <__floatsisf+0x12>

00004038 <__floatsisf>:
    4038:	97 fb       	bst	r25, 7
    403a:	3e f4       	brtc	.+14     	; 0x404a <__floatsisf+0x12>
    403c:	90 95       	com	r25
    403e:	80 95       	com	r24
    4040:	70 95       	com	r23
    4042:	61 95       	neg	r22
    4044:	7f 4f       	sbci	r23, 0xFF	; 255
    4046:	8f 4f       	sbci	r24, 0xFF	; 255
    4048:	9f 4f       	sbci	r25, 0xFF	; 255
    404a:	99 23       	and	r25, r25
    404c:	a9 f0       	breq	.+42     	; 0x4078 <__floatsisf+0x40>
    404e:	f9 2f       	mov	r31, r25
    4050:	96 e9       	ldi	r25, 0x96	; 150
    4052:	bb 27       	eor	r27, r27
    4054:	93 95       	inc	r25
    4056:	f6 95       	lsr	r31
    4058:	87 95       	ror	r24
    405a:	77 95       	ror	r23
    405c:	67 95       	ror	r22
    405e:	b7 95       	ror	r27
    4060:	f1 11       	cpse	r31, r1
    4062:	f8 cf       	rjmp	.-16     	; 0x4054 <__floatsisf+0x1c>
    4064:	fa f4       	brpl	.+62     	; 0x40a4 <__floatsisf+0x6c>
    4066:	bb 0f       	add	r27, r27
    4068:	11 f4       	brne	.+4      	; 0x406e <__floatsisf+0x36>
    406a:	60 ff       	sbrs	r22, 0
    406c:	1b c0       	rjmp	.+54     	; 0x40a4 <__floatsisf+0x6c>
    406e:	6f 5f       	subi	r22, 0xFF	; 255
    4070:	7f 4f       	sbci	r23, 0xFF	; 255
    4072:	8f 4f       	sbci	r24, 0xFF	; 255
    4074:	9f 4f       	sbci	r25, 0xFF	; 255
    4076:	16 c0       	rjmp	.+44     	; 0x40a4 <__floatsisf+0x6c>
    4078:	88 23       	and	r24, r24
    407a:	11 f0       	breq	.+4      	; 0x4080 <__floatsisf+0x48>
    407c:	96 e9       	ldi	r25, 0x96	; 150
    407e:	11 c0       	rjmp	.+34     	; 0x40a2 <__floatsisf+0x6a>
    4080:	77 23       	and	r23, r23
    4082:	21 f0       	breq	.+8      	; 0x408c <__floatsisf+0x54>
    4084:	9e e8       	ldi	r25, 0x8E	; 142
    4086:	87 2f       	mov	r24, r23
    4088:	76 2f       	mov	r23, r22
    408a:	05 c0       	rjmp	.+10     	; 0x4096 <__floatsisf+0x5e>
    408c:	66 23       	and	r22, r22
    408e:	71 f0       	breq	.+28     	; 0x40ac <__floatsisf+0x74>
    4090:	96 e8       	ldi	r25, 0x86	; 134
    4092:	86 2f       	mov	r24, r22
    4094:	70 e0       	ldi	r23, 0x00	; 0
    4096:	60 e0       	ldi	r22, 0x00	; 0
    4098:	2a f0       	brmi	.+10     	; 0x40a4 <__floatsisf+0x6c>
    409a:	9a 95       	dec	r25
    409c:	66 0f       	add	r22, r22
    409e:	77 1f       	adc	r23, r23
    40a0:	88 1f       	adc	r24, r24
    40a2:	da f7       	brpl	.-10     	; 0x409a <__floatsisf+0x62>
    40a4:	88 0f       	add	r24, r24
    40a6:	96 95       	lsr	r25
    40a8:	87 95       	ror	r24
    40aa:	97 f9       	bld	r25, 7
    40ac:	08 95       	ret

000040ae <__fp_inf>:
    40ae:	97 f9       	bld	r25, 7
    40b0:	9f 67       	ori	r25, 0x7F	; 127
    40b2:	80 e8       	ldi	r24, 0x80	; 128
    40b4:	70 e0       	ldi	r23, 0x00	; 0
    40b6:	60 e0       	ldi	r22, 0x00	; 0
    40b8:	08 95       	ret

000040ba <__fp_nan>:
    40ba:	9f ef       	ldi	r25, 0xFF	; 255
    40bc:	80 ec       	ldi	r24, 0xC0	; 192
    40be:	08 95       	ret

000040c0 <__fp_pscA>:
    40c0:	00 24       	eor	r0, r0
    40c2:	0a 94       	dec	r0
    40c4:	16 16       	cp	r1, r22
    40c6:	17 06       	cpc	r1, r23
    40c8:	18 06       	cpc	r1, r24
    40ca:	09 06       	cpc	r0, r25
    40cc:	08 95       	ret

000040ce <__fp_pscB>:
    40ce:	00 24       	eor	r0, r0
    40d0:	0a 94       	dec	r0
    40d2:	12 16       	cp	r1, r18
    40d4:	13 06       	cpc	r1, r19
    40d6:	14 06       	cpc	r1, r20
    40d8:	05 06       	cpc	r0, r21
    40da:	08 95       	ret

000040dc <__fp_round>:
    40dc:	09 2e       	mov	r0, r25
    40de:	03 94       	inc	r0
    40e0:	00 0c       	add	r0, r0
    40e2:	11 f4       	brne	.+4      	; 0x40e8 <__fp_round+0xc>
    40e4:	88 23       	and	r24, r24
    40e6:	52 f0       	brmi	.+20     	; 0x40fc <__fp_round+0x20>
    40e8:	bb 0f       	add	r27, r27
    40ea:	40 f4       	brcc	.+16     	; 0x40fc <__fp_round+0x20>
    40ec:	bf 2b       	or	r27, r31
    40ee:	11 f4       	brne	.+4      	; 0x40f4 <__fp_round+0x18>
    40f0:	60 ff       	sbrs	r22, 0
    40f2:	04 c0       	rjmp	.+8      	; 0x40fc <__fp_round+0x20>
    40f4:	6f 5f       	subi	r22, 0xFF	; 255
    40f6:	7f 4f       	sbci	r23, 0xFF	; 255
    40f8:	8f 4f       	sbci	r24, 0xFF	; 255
    40fa:	9f 4f       	sbci	r25, 0xFF	; 255
    40fc:	08 95       	ret

000040fe <__fp_split3>:
    40fe:	57 fd       	sbrc	r21, 7
    4100:	90 58       	subi	r25, 0x80	; 128
    4102:	44 0f       	add	r20, r20
    4104:	55 1f       	adc	r21, r21
    4106:	59 f0       	breq	.+22     	; 0x411e <__fp_splitA+0x10>
    4108:	5f 3f       	cpi	r21, 0xFF	; 255
    410a:	71 f0       	breq	.+28     	; 0x4128 <__fp_splitA+0x1a>
    410c:	47 95       	ror	r20

0000410e <__fp_splitA>:
    410e:	88 0f       	add	r24, r24
    4110:	97 fb       	bst	r25, 7
    4112:	99 1f       	adc	r25, r25
    4114:	61 f0       	breq	.+24     	; 0x412e <__fp_splitA+0x20>
    4116:	9f 3f       	cpi	r25, 0xFF	; 255
    4118:	79 f0       	breq	.+30     	; 0x4138 <__fp_splitA+0x2a>
    411a:	87 95       	ror	r24
    411c:	08 95       	ret
    411e:	12 16       	cp	r1, r18
    4120:	13 06       	cpc	r1, r19
    4122:	14 06       	cpc	r1, r20
    4124:	55 1f       	adc	r21, r21
    4126:	f2 cf       	rjmp	.-28     	; 0x410c <__fp_split3+0xe>
    4128:	46 95       	lsr	r20
    412a:	f1 df       	rcall	.-30     	; 0x410e <__fp_splitA>
    412c:	08 c0       	rjmp	.+16     	; 0x413e <__fp_splitA+0x30>
    412e:	16 16       	cp	r1, r22
    4130:	17 06       	cpc	r1, r23
    4132:	18 06       	cpc	r1, r24
    4134:	99 1f       	adc	r25, r25
    4136:	f1 cf       	rjmp	.-30     	; 0x411a <__fp_splitA+0xc>
    4138:	86 95       	lsr	r24
    413a:	71 05       	cpc	r23, r1
    413c:	61 05       	cpc	r22, r1
    413e:	08 94       	sec
    4140:	08 95       	ret

00004142 <__fp_zero>:
    4142:	e8 94       	clt

00004144 <__fp_szero>:
    4144:	bb 27       	eor	r27, r27
    4146:	66 27       	eor	r22, r22
    4148:	77 27       	eor	r23, r23
    414a:	cb 01       	movw	r24, r22
    414c:	97 f9       	bld	r25, 7
    414e:	08 95       	ret

00004150 <__mulsf3>:
    4150:	0b d0       	rcall	.+22     	; 0x4168 <__mulsf3x>
    4152:	c4 cf       	rjmp	.-120    	; 0x40dc <__fp_round>
    4154:	b5 df       	rcall	.-150    	; 0x40c0 <__fp_pscA>
    4156:	28 f0       	brcs	.+10     	; 0x4162 <__mulsf3+0x12>
    4158:	ba df       	rcall	.-140    	; 0x40ce <__fp_pscB>
    415a:	18 f0       	brcs	.+6      	; 0x4162 <__mulsf3+0x12>
    415c:	95 23       	and	r25, r21
    415e:	09 f0       	breq	.+2      	; 0x4162 <__mulsf3+0x12>
    4160:	a6 cf       	rjmp	.-180    	; 0x40ae <__fp_inf>
    4162:	ab cf       	rjmp	.-170    	; 0x40ba <__fp_nan>
    4164:	11 24       	eor	r1, r1
    4166:	ee cf       	rjmp	.-36     	; 0x4144 <__fp_szero>

00004168 <__mulsf3x>:
    4168:	ca df       	rcall	.-108    	; 0x40fe <__fp_split3>
    416a:	a0 f3       	brcs	.-24     	; 0x4154 <__mulsf3+0x4>

0000416c <__mulsf3_pse>:
    416c:	95 9f       	mul	r25, r21
    416e:	d1 f3       	breq	.-12     	; 0x4164 <__mulsf3+0x14>
    4170:	95 0f       	add	r25, r21
    4172:	50 e0       	ldi	r21, 0x00	; 0
    4174:	55 1f       	adc	r21, r21
    4176:	62 9f       	mul	r22, r18
    4178:	f0 01       	movw	r30, r0
    417a:	72 9f       	mul	r23, r18
    417c:	bb 27       	eor	r27, r27
    417e:	f0 0d       	add	r31, r0
    4180:	b1 1d       	adc	r27, r1
    4182:	63 9f       	mul	r22, r19
    4184:	aa 27       	eor	r26, r26
    4186:	f0 0d       	add	r31, r0
    4188:	b1 1d       	adc	r27, r1
    418a:	aa 1f       	adc	r26, r26
    418c:	64 9f       	mul	r22, r20
    418e:	66 27       	eor	r22, r22
    4190:	b0 0d       	add	r27, r0
    4192:	a1 1d       	adc	r26, r1
    4194:	66 1f       	adc	r22, r22
    4196:	82 9f       	mul	r24, r18
    4198:	22 27       	eor	r18, r18
    419a:	b0 0d       	add	r27, r0
    419c:	a1 1d       	adc	r26, r1
    419e:	62 1f       	adc	r22, r18
    41a0:	73 9f       	mul	r23, r19
    41a2:	b0 0d       	add	r27, r0
    41a4:	a1 1d       	adc	r26, r1
    41a6:	62 1f       	adc	r22, r18
    41a8:	83 9f       	mul	r24, r19
    41aa:	a0 0d       	add	r26, r0
    41ac:	61 1d       	adc	r22, r1
    41ae:	22 1f       	adc	r18, r18
    41b0:	74 9f       	mul	r23, r20
    41b2:	33 27       	eor	r19, r19
    41b4:	a0 0d       	add	r26, r0
    41b6:	61 1d       	adc	r22, r1
    41b8:	23 1f       	adc	r18, r19
    41ba:	84 9f       	mul	r24, r20
    41bc:	60 0d       	add	r22, r0
    41be:	21 1d       	adc	r18, r1
    41c0:	82 2f       	mov	r24, r18
    41c2:	76 2f       	mov	r23, r22
    41c4:	6a 2f       	mov	r22, r26
    41c6:	11 24       	eor	r1, r1
    41c8:	9f 57       	subi	r25, 0x7F	; 127
    41ca:	50 40       	sbci	r21, 0x00	; 0
    41cc:	8a f0       	brmi	.+34     	; 0x41f0 <__mulsf3_pse+0x84>
    41ce:	e1 f0       	breq	.+56     	; 0x4208 <__mulsf3_pse+0x9c>
    41d0:	88 23       	and	r24, r24
    41d2:	4a f0       	brmi	.+18     	; 0x41e6 <__mulsf3_pse+0x7a>
    41d4:	ee 0f       	add	r30, r30
    41d6:	ff 1f       	adc	r31, r31
    41d8:	bb 1f       	adc	r27, r27
    41da:	66 1f       	adc	r22, r22
    41dc:	77 1f       	adc	r23, r23
    41de:	88 1f       	adc	r24, r24
    41e0:	91 50       	subi	r25, 0x01	; 1
    41e2:	50 40       	sbci	r21, 0x00	; 0
    41e4:	a9 f7       	brne	.-22     	; 0x41d0 <__mulsf3_pse+0x64>
    41e6:	9e 3f       	cpi	r25, 0xFE	; 254
    41e8:	51 05       	cpc	r21, r1
    41ea:	70 f0       	brcs	.+28     	; 0x4208 <__mulsf3_pse+0x9c>
    41ec:	60 cf       	rjmp	.-320    	; 0x40ae <__fp_inf>
    41ee:	aa cf       	rjmp	.-172    	; 0x4144 <__fp_szero>
    41f0:	5f 3f       	cpi	r21, 0xFF	; 255
    41f2:	ec f3       	brlt	.-6      	; 0x41ee <__mulsf3_pse+0x82>
    41f4:	98 3e       	cpi	r25, 0xE8	; 232
    41f6:	dc f3       	brlt	.-10     	; 0x41ee <__mulsf3_pse+0x82>
    41f8:	86 95       	lsr	r24
    41fa:	77 95       	ror	r23
    41fc:	67 95       	ror	r22
    41fe:	b7 95       	ror	r27
    4200:	f7 95       	ror	r31
    4202:	e7 95       	ror	r30
    4204:	9f 5f       	subi	r25, 0xFF	; 255
    4206:	c1 f7       	brne	.-16     	; 0x41f8 <__mulsf3_pse+0x8c>
    4208:	fe 2b       	or	r31, r30
    420a:	88 0f       	add	r24, r24
    420c:	91 1d       	adc	r25, r1
    420e:	96 95       	lsr	r25
    4210:	87 95       	ror	r24
    4212:	97 f9       	bld	r25, 7
    4214:	08 95       	ret
    4216:	11 f4       	brne	.+4      	; 0x421c <__mulsf3_pse+0xb0>
    4218:	0e f4       	brtc	.+2      	; 0x421c <__mulsf3_pse+0xb0>
    421a:	4f cf       	rjmp	.-354    	; 0x40ba <__fp_nan>
    421c:	3e c0       	rjmp	.+124    	; 0x429a <__fp_mpack>

0000421e <sqrt>:
    421e:	77 df       	rcall	.-274    	; 0x410e <__fp_splitA>
    4220:	d0 f3       	brcs	.-12     	; 0x4216 <__mulsf3_pse+0xaa>
    4222:	99 23       	and	r25, r25
    4224:	d9 f3       	breq	.-10     	; 0x421c <__mulsf3_pse+0xb0>
    4226:	ce f3       	brts	.-14     	; 0x421a <__mulsf3_pse+0xae>
    4228:	9f 57       	subi	r25, 0x7F	; 127
    422a:	55 0b       	sbc	r21, r21
    422c:	87 ff       	sbrs	r24, 7
    422e:	43 d0       	rcall	.+134    	; 0x42b6 <__fp_norm2>
    4230:	00 24       	eor	r0, r0
    4232:	a0 e6       	ldi	r26, 0x60	; 96
    4234:	40 ea       	ldi	r20, 0xA0	; 160
    4236:	90 01       	movw	r18, r0
    4238:	80 58       	subi	r24, 0x80	; 128
    423a:	56 95       	lsr	r21
    423c:	97 95       	ror	r25
    423e:	28 f4       	brcc	.+10     	; 0x424a <sqrt+0x2c>
    4240:	80 5c       	subi	r24, 0xC0	; 192
    4242:	66 0f       	add	r22, r22
    4244:	77 1f       	adc	r23, r23
    4246:	88 1f       	adc	r24, r24
    4248:	20 f0       	brcs	.+8      	; 0x4252 <sqrt+0x34>
    424a:	26 17       	cp	r18, r22
    424c:	37 07       	cpc	r19, r23
    424e:	48 07       	cpc	r20, r24
    4250:	30 f4       	brcc	.+12     	; 0x425e <sqrt+0x40>
    4252:	62 1b       	sub	r22, r18
    4254:	73 0b       	sbc	r23, r19
    4256:	84 0b       	sbc	r24, r20
    4258:	20 29       	or	r18, r0
    425a:	31 29       	or	r19, r1
    425c:	4a 2b       	or	r20, r26
    425e:	a6 95       	lsr	r26
    4260:	17 94       	ror	r1
    4262:	07 94       	ror	r0
    4264:	20 25       	eor	r18, r0
    4266:	31 25       	eor	r19, r1
    4268:	4a 27       	eor	r20, r26
    426a:	58 f7       	brcc	.-42     	; 0x4242 <sqrt+0x24>
    426c:	66 0f       	add	r22, r22
    426e:	77 1f       	adc	r23, r23
    4270:	88 1f       	adc	r24, r24
    4272:	20 f0       	brcs	.+8      	; 0x427c <sqrt+0x5e>
    4274:	26 17       	cp	r18, r22
    4276:	37 07       	cpc	r19, r23
    4278:	48 07       	cpc	r20, r24
    427a:	30 f4       	brcc	.+12     	; 0x4288 <sqrt+0x6a>
    427c:	62 0b       	sbc	r22, r18
    427e:	73 0b       	sbc	r23, r19
    4280:	84 0b       	sbc	r24, r20
    4282:	20 0d       	add	r18, r0
    4284:	31 1d       	adc	r19, r1
    4286:	41 1d       	adc	r20, r1
    4288:	a0 95       	com	r26
    428a:	81 f7       	brne	.-32     	; 0x426c <sqrt+0x4e>
    428c:	b9 01       	movw	r22, r18
    428e:	84 2f       	mov	r24, r20
    4290:	91 58       	subi	r25, 0x81	; 129
    4292:	88 0f       	add	r24, r24
    4294:	96 95       	lsr	r25
    4296:	87 95       	ror	r24
    4298:	08 95       	ret

0000429a <__fp_mpack>:
    429a:	9f 3f       	cpi	r25, 0xFF	; 255
    429c:	31 f0       	breq	.+12     	; 0x42aa <__fp_mpack_finite+0xc>

0000429e <__fp_mpack_finite>:
    429e:	91 50       	subi	r25, 0x01	; 1
    42a0:	20 f4       	brcc	.+8      	; 0x42aa <__fp_mpack_finite+0xc>
    42a2:	87 95       	ror	r24
    42a4:	77 95       	ror	r23
    42a6:	67 95       	ror	r22
    42a8:	b7 95       	ror	r27
    42aa:	88 0f       	add	r24, r24
    42ac:	91 1d       	adc	r25, r1
    42ae:	96 95       	lsr	r25
    42b0:	87 95       	ror	r24
    42b2:	97 f9       	bld	r25, 7
    42b4:	08 95       	ret

000042b6 <__fp_norm2>:
    42b6:	91 50       	subi	r25, 0x01	; 1
    42b8:	50 40       	sbci	r21, 0x00	; 0
    42ba:	66 0f       	add	r22, r22
    42bc:	77 1f       	adc	r23, r23
    42be:	88 1f       	adc	r24, r24
    42c0:	d2 f7       	brpl	.-12     	; 0x42b6 <__fp_norm2>
    42c2:	08 95       	ret

000042c4 <__udivmodhi4>:
    42c4:	aa 1b       	sub	r26, r26
    42c6:	bb 1b       	sub	r27, r27
    42c8:	51 e1       	ldi	r21, 0x11	; 17
    42ca:	07 c0       	rjmp	.+14     	; 0x42da <__udivmodhi4_ep>

000042cc <__udivmodhi4_loop>:
    42cc:	aa 1f       	adc	r26, r26
    42ce:	bb 1f       	adc	r27, r27
    42d0:	a6 17       	cp	r26, r22
    42d2:	b7 07       	cpc	r27, r23
    42d4:	10 f0       	brcs	.+4      	; 0x42da <__udivmodhi4_ep>
    42d6:	a6 1b       	sub	r26, r22
    42d8:	b7 0b       	sbc	r27, r23

000042da <__udivmodhi4_ep>:
    42da:	88 1f       	adc	r24, r24
    42dc:	99 1f       	adc	r25, r25
    42de:	5a 95       	dec	r21
    42e0:	a9 f7       	brne	.-22     	; 0x42cc <__udivmodhi4_loop>
    42e2:	80 95       	com	r24
    42e4:	90 95       	com	r25
    42e6:	bc 01       	movw	r22, r24
    42e8:	cd 01       	movw	r24, r26
    42ea:	08 95       	ret

000042ec <memcpy>:
    42ec:	fb 01       	movw	r30, r22
    42ee:	dc 01       	movw	r26, r24
    42f0:	02 c0       	rjmp	.+4      	; 0x42f6 <memcpy+0xa>
    42f2:	01 90       	ld	r0, Z+
    42f4:	0d 92       	st	X+, r0
    42f6:	41 50       	subi	r20, 0x01	; 1
    42f8:	50 40       	sbci	r21, 0x00	; 0
    42fa:	d8 f7       	brcc	.-10     	; 0x42f2 <memcpy+0x6>
    42fc:	08 95       	ret

000042fe <_exit>:
    42fe:	f8 94       	cli

00004300 <__stop_program>:
    4300:	ff cf       	rjmp	.-2      	; 0x4300 <__stop_program>
